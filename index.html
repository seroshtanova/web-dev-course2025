<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Веб-разработка: от основ до практики</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Веб-разработка: от основ до практики</h1>
        <p>Полный учебно-методический комплекс для студентов 3 курса</p>
        <a href="#curriculum" class="button">Начать обучение</a>
    </header>

    <nav>
        <ul>
            <li><a href="#curriculum">Программа курса</a></li>
            <li><a href="#lectures">Лекции</a></li>
            <li><a href="#practical-works">Практические работы</a></li>
            <li><a href="#code-examples">Примеры кода</a></li>
            <li><a href="#final-topics">Темы для итоговых работ</a></li>
            <li><a href="#additional-materials">Дополнительные материалы</a></li>
        </ul>
    </nav>

    <main>
        <section id="curriculum">
            <h2>Программа курса</h2>
            <h1>Учебный план дисциплины 'Основы веб-разработки'</h1>
<p><strong>Дисциплина:</strong> Основы веб-разработки
<strong>Курс:</strong> 3
<strong>Общая трудоемкость:</strong> 36 академических часов</p>
<h2>Цель дисциплины:</h2>
<p>Обеспечить студентов фундаментальными знаниями и практическими навыками в области фронтенд-разработки с использованием HTML, CSS и JavaScript для создания интерактивных и адаптивных веб-сайтов.</p>
<h2>Задачи дисциплины:</h2>
<ul>
<li>Изучить базовые принципы работы веб-технологий и архитектуры веб-сайтов.</li>
<li>Освоить синтаксис и основные концепции HTML для структурирования веб-контента.</li>
<li>Овладеть инструментами CSS для стилизации и оформления веб-страниц.</li>
<li>Понять принципы адаптивного дизайна и научиться создавать макеты, корректно отображающиеся на различных устройствах.</li>
<li>Изучить основы JavaScript для добавления интерактивности на веб-страницы.</li>
<li>Приобрести практический опыт разработки полноценного веб-сайта и его развертывания.</li>
</ul>
<h2>Структура дисциплины:</h2>
<h3>1. Введение в веб-разработку (2 часа)</h3>
<ul>
<li><strong>Темы:</strong><ul>
<li>Что такое веб-сайты, браузеры и как они работают (клиент-серверная архитектура, HTTP/HTTPS).</li>
<li>Знакомство с основными инструментами: текстовый редактор (VS Code), браузер (инструменты разработчика).</li>
</ul>
</li>
<li><strong>Цели:</strong><ul>
<li>Понять базовые концепции функционирования Интернета и веб-сайтов.</li>
<li>Ознакомиться с основными инструментами, необходимыми для веб-разработки.</li>
</ul>
</li>
<li><strong>Задачи:</strong><ul>
<li>Объяснить роль браузера и сервера в отображении веб-страниц.</li>
<li>Продемонстрировать установку и базовую настройку VS Code.</li>
<li>Показать, как использовать инструменты разработчика в браузере для инспектирования элементов.</li>
</ul>
</li>
</ul>
<h3>2. Основы HTML (8 часов)</h3>
<ul>
<li><strong>Темы:</strong><ul>
<li>Структура HTML-документа: <code>&lt;!DOCTYPE&gt;</code>, <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>.</li>
<li>Основные теги для работы с текстом: <code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code>.</li>
<li>Работа с изображениями: <code>&lt;img&gt;</code> (атрибуты <code>src</code>, <code>alt</code>, <code>width</code>, <code>height</code>).</li>
<li>Создание форм и полей ввода: <code>&lt;form&gt;</code>, <code>&lt;input&gt;</code> (типы <code>text</code>, <code>password</code>, <code>checkbox</code>, <code>radio</code>, <code>submit</code>), <code>&lt;textarea&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;label&gt;</code>.</li>
<li>Таблицы: <code>&lt;table&gt;</code>, <code>&lt;thead&gt;</code>, <code>&lt;tbody&gt;</code>, <code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code>, <code>&lt;td&gt;</code>.</li>
<li>Семантические элементы HTML5: <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;aside&gt;</code>.</li>
<li>Атрибуты тегов (глобальные и специфические).</li>
</ul>
</li>
<li><strong>Цели:</strong><ul>
<li>Научиться создавать корректную структуру HTML-документа.</li>
<li>Освоить основные HTML-теги для разметки текстового и медиа-контента.</li>
<li>Понимать и применять семантические элементы HTML5 для улучшения структуры и доступности.</li>
</ul>
</li>
<li><strong>Задачи:</strong><ul>
<li>Создать базовую HTML-страницу с заголовками, параграфами, списками и ссылками.</li>
<li>Вставить изображения на страницу и настроить их отображение.</li>
<li>Разработать простую форму обратной связи с различными типами полей ввода.</li>
<li>Использовать семантические теги для создания логичной структуры веб-страницы.</li>
</ul>
</li>
</ul>
<h3>3. Основы CSS (10 часов)</h3>
<ul>
<li><strong>Темы:</strong><ul>
<li>Способы подключения CSS: инлайн, внутренний, внешний.</li>
<li>Селекторы: по тегу, классу (<code>.class</code>), ID (<code>#id</code>), атрибуту, псевдоклассы (<code>:hover</code>, <code>:active</code>), псевдоэлементы (<code>::before</code>, <code>::after</code>).</li>
<li>Основные свойства CSS: <code>color</code>, <code>font-family</code>, <code>font-size</code>, <code>background-color</code>, <code>background-image</code>, <code>margin</code>, <code>padding</code>, <code>border</code>.</li>
<li>Блочная модель: <code>display</code> (block, inline, inline-block), <code>box-sizing</code> (content-box, border-box).</li>
<li>Работа с цветом (HEX, RGB, RGBA) и шрифтами (Google Fonts).</li>
<li>Стилизация ссылок и изображений.</li>
<li>Основы Flexbox для создания одномерных макетов: <code>display: flex</code>, <code>flex-direction</code>, <code>justify-content</code>, <code>align-items</code>, <code>flex-wrap</code>.</li>
<li>Основы Grid для создания двумерных макетов: <code>display: grid</code>, <code>grid-template-columns</code>, <code>grid-template-rows</code>, <code>grid-gap</code>.</li>
</ul>
</li>
<li><strong>Цели:</strong><ul>
<li>Овладеть различными способами применения стилей к HTML-элементам.</li>
<li>Научиться использовать разнообразные CSS-селекторы для точного таргетирования элементов.</li>
<li>Понимать и применять блочную модель CSS для контроля над размерами и расположением элементов.</li>
<li>Освоить базовые принципы Flexbox и Grid для создания сложных и гибких макетов.</li>
</ul>
</li>
<li><strong>Задачи:</strong><ul>
<li>Применить внешние и внутренние стили к HTML-странице.</li>
<li>Использовать различные селекторы для стилизации элементов по классу, ID и тегу.</li>
<li>Создать навигационное меню с использованием Flexbox.</li>
<li>Разработать двухколоночный макет страницы с использованием Grid.</li>
<li>Оформить текстовые блоки, ссылки и изображения с использованием различных CSS-свойств.</li>
</ul>
</li>
</ul>
<h3>4. Адаптивный дизайн (6 часов)</h3>
<ul>
<li><strong>Темы:</strong><ul>
<li>Что такое адаптивный дизайн и его важность.</li>
<li>Принцип Mobile First.</li>
<li>Медиа-запросы (<code>@media screen and (max-width: ...)</code>).</li>
<li>Создание макетов, адаптирующихся под разные устройства (десктоп, планшет, мобильный телефон).</li>
<li>Гибкие изображения и видео (<code>max-width: 100%</code>).</li>
<li>Viewport мета-тег.</li>
</ul>
</li>
<li><strong>Цели:</strong><ul>
<li>Понять концепцию адаптивного дизайна и его необходимость в современной веб-разработке.</li>
<li>Научиться использовать медиа-запросы для создания отзывчивых макетов.</li>
</ul>
</li>
<li><strong>Задачи:</strong><ul>
<li>Адаптировать ранее созданный макет страницы для корректного отображения на мобильных устройствах и планшетах.</li>
<li>Применить принцип Mobile First при разработке нового макета.</li>
<li>Обеспечить гибкость изображений и видео на странице.</li>
</ul>
</li>
</ul>
<h3>5. Модель документа (DOM) (4 часа)</h3>
<ul>
<li><strong>Темы:</strong><ul>
<li>Что такое DOM и его древовидная структура.</li>
<li>Доступ к элементам: <code>getElementById</code>, <code>getElementsByClassName</code>, <code>getElementsByTagName</code>, <code>querySelector</code>, <code>querySelectorAll</code>.</li>
<li>Манипуляции с элементами: изменение содержимого (<code>innerHTML</code>, <code>textContent</code>), атрибутов и стилей.</li>
<li>Создание, добавление и удаление элементов.</li>
<li>Обработка событий: <code>addEventListener</code>, объект события, всплытие и делегирование.</li>
</ul>
</li>
<li><strong>Цели:</strong><ul>
<li>Понять, как браузер представляет HTML-документ в виде объекта.</li>
<li>Научиться находить и изменять любые элементы на странице с помощью JavaScript.</li>
<li>Освоить основы обработки пользовательских событий для создания интерактивности.</li>
</ul>
</li>
<li><strong>Задачи:</strong><ul>
<li>Написать скрипт для изменения текста и стилей элемента по клику.</li>
<li>Создать и добавить новый элемент на страницу при помощи JavaScript.</li>
<li>Реализовать простое делегирование событий на списке элементов.</li>
</ul>
</li>
</ul>
<h3>6. Введение в JavaScript (8 часов)</h3>
<ul>
<li><strong>Темы:</strong><ul>
<li>Что такое JavaScript, его роль в веб-разработке и место в браузере.</li>
<li>Подключение JavaScript к HTML-документу.</li>
<li>Переменные (<code>var</code>, <code>let</code>, <code>const</code>), типы данных (строки, числа, булевы, массивы, объекты), операторы (арифметические, сравнения, логические).</li>
<li>Условные конструкции (<code>if</code>/<code>else if</code>/<code>else</code>, <code>switch</code>).</li>
<li>Циклы (<code>for</code>, <code>while</code>, <code>do...while</code>, <code>for...of</code>, <code>for...in</code>).</li>
<li>Функции (объявление, вызов, параметры, возвращаемое значение).</li>
<li>Работа с событиями: обработчики событий (клики, ввод, наведение мыши).</li>
<li>Манипуляции с DOM (Document Object Model): выбор элементов (<code>document.getElementById</code>, <code>document.querySelector</code>, <code>document.querySelectorAll</code>), изменение содержимого (<code>textContent</code>, <code>innerHTML</code>), изменение стилей (<code>style</code>), добавление/удаление классов (<code>classList</code>), создание/удаление элементов.</li>
</ul>
</li>
<li><strong>Цели:</strong><ul>
<li>Понять основы программирования на JavaScript и его применение в веб-разработке.</li>
<li>Научиться работать с переменными, типами данных, операторами и управляющими структурами.</li>
<li>Освоить принципы взаимодействия с DOM для динамического изменения веб-страниц.</li>
<li>Приобрести навыки обработки пользовательских событий.</li>
</ul>
</li>
<li><strong>Задачи:</strong><ul>
<li>Написать скрипт, который изменяет текст элемента по клику кнопки.</li>
<li>Создать простой калькулятор, выполняющий базовые арифметические операции.</li>
<li>Реализовать переключение классов для изменения стилей элемента при наведении мыши.</li>
<li>Добавить новые элементы на страницу с помощью JavaScript.</li>
<li>Разработать интерактивную форму с валидацией полей ввода.</li>
</ul>
</li>
</ul>
<h3>6. Практика и развертывание (2 часа)</h3>
<ul>
<li><strong>Темы:</strong><ul>
<li>Создание простого сайта-портфолио (или лендинга) с использованием всех изученных технологий.</li>
<li>Обзор инструментов для сборки и автоматизации (опционально, кратко).</li>
<li>Основы развертывания проекта: публикация на GitHub Pages.</li>
<li>Обзор дальнейших шагов в веб-разработке (фреймворки, библиотеки).</li>
</ul>
</li>
<li><strong>Цели:</strong><ul>
<li>Закрепить полученные знания и навыки на практике, создав полноценный веб-сайт.</li>
<li>Научиться публиковать свой проект в Интернете.</li>
<li>Ознакомиться с дальнейшими перспективами развития в веб-разработке.</li>
</ul>
</li>
<li><strong>Задачи:</strong><ul>
<li>Разработать структуру и дизайн сайта-портфолио.</li>
<li>Наполнить сайт контентом (текст, изображения, ссылки).</li>
<li>Обеспечить адаптивность сайта для различных устройств.</li>
<li>Развернуть сайт на GitHub Pages и предоставить ссылку.</li>
</ul>
</li>
</ul>
<h2>Итоговое задание:</h2>
<p>Разработка интерактивного и адаптивного веб-сайта (например, сайт-портфолио, лендинг продукта, небольшой информационный сайт) с использованием HTML, CSS и JavaScript. Проект должен демонстрировать владение всеми основными концепциями, изученными в рамках дисциплины.</p>
        </section>

        <section id="lectures">
            <h2>Лекции</h2>
            <h1>Лекция 1: Введение в веб-разработку</h1>
<h2>1.1. Что такое веб-сайты, браузеры и как они работают</h2>
<p>Веб-сайты, или просто сайты, представляют собой совокупность взаимосвязанных веб-страниц, доступных через Интернет. Эти страницы содержат текст, изображения, видео, аудио и другие мультимедийные элементы, а также интерактивные компоненты. Веб-сайты являются основным средством распространения информации и предоставления услуг в глобальной сети. Для доступа к веб-сайтам используются специальные программы, называемые веб-браузерами.</p>
<h3>Веб-браузеры</h3>
<p>Веб-браузер — это программное обеспечение, которое позволяет пользователю получать, обрабатывать, отображать и взаимодействовать с веб-страницами. Когда вы вводите адрес веб-сайта (URL) в адресную строку браузера, происходит серия сложных операций, которые в конечном итоге приводят к отображению запрошенной страницы на вашем экране. Среди наиболее популярных браузеров можно выделить Google Chrome, Mozilla Firefox, Microsoft Edge, Safari и Opera.</p>
<p>Основные функции веб-браузера включают:</p>
<ul>
<li><strong>Запрос и получение данных:</strong> Браузер отправляет запрос на веб-сервер, где хранится веб-сайт, и получает в ответ HTML, CSS, JavaScript файлы, а также изображения и другие ресурсы.</li>
<li><strong>Рендеринг (отображение):</strong> Полученные данные интерпретируются браузером. HTML-код используется для определения структуры и содержимого страницы, CSS — для ее стилизации и оформления, а JavaScript — для добавления интерактивности и динамического поведения.</li>
<li><strong>Интерпретация JavaScript:</strong> Браузер содержит движок JavaScript, который выполняет скрипты, встроенные в веб-страницы, позволяя создавать динамические элементы, обрабатывать пользовательский ввод и взаимодействовать с сервером без перезагрузки страницы.</li>
<li><strong>Управление сессиями и куки:</strong> Браузеры хранят информацию о пользовательских сессиях, такую как куки (cookies), которые используются для сохранения состояния между запросами, например, для авторизации или отслеживания предпочтений пользователя.</li>
</ul>
<h3>Как работают веб-сайты: Клиент-серверная архитектура</h3>
<p>В основе работы веб-сайтов лежит клиент-серверная архитектура. В этой модели существуют две основные стороны взаимодействия:</p>
<ul>
<li><strong>Клиент (Client):</strong> Это ваш веб-браузер, который запрашивает информацию. Когда вы вводите URL, ваш браузер выступает в роли клиента, отправляя HTTP-запрос на сервер.</li>
<li><strong>Сервер (Server):</strong> Это компьютер, на котором хранятся файлы веб-сайта (HTML, CSS, JavaScript, изображения и т.д.) и который отвечает на запросы клиентов. Веб-серверы постоянно работают и ожидают входящих запросов. Когда сервер получает запрос от клиента, он находит запрошенные файлы и отправляет их обратно клиенту.</li>
</ul>
<p>Процесс взаимодействия выглядит следующим образом:</p>
<ol>
<li><strong>Пользователь вводит URL:</strong> Вы вводите адрес веб-сайта (например, <code>https://www.example.com</code>) в адресную строку браузера.</li>
<li><strong>DNS-запрос:</strong> Браузер обращается к системе доменных имен (DNS) для преобразования доменного имени (<code>www.example.com</code>) в IP-адрес веб-сервера. Это похоже на поиск номера телефона по имени в телефонной книге.</li>
<li><strong>Установление соединения:</strong> После получения IP-адреса браузер устанавливает TCP-соединение с веб-сервером по этому IP-адресу.</li>
<li><strong>HTTP-запрос:</strong> Браузер отправляет HTTP-запрос (Hypertext Transfer Protocol) на сервер. Этот запрос содержит информацию о том, какой ресурс запрашивается (например, главная страница), а также другую информацию, такую как тип браузера, поддерживаемые языки и т.д.</li>
<li><strong>Обработка запроса сервером:</strong> Веб-сервер получает запрос, обрабатывает его, находит запрошенные файлы (например, <code>index.html</code>, <code>style.css</code>, <code>script.js</code>) и формирует HTTP-ответ.</li>
<li><strong>HTTP-ответ:</strong> Сервер отправляет HTTP-ответ обратно браузеру. Этот ответ содержит запрошенные файлы и статус ответа (например, 200 OK, если все в порядке, или 404 Not Found, если страница не найдена).</li>
<li><strong>Рендеринг страницы:</strong> Браузер получает HTTP-ответ, парсит (анализирует) HTML-код, применяет стили из CSS-файлов и выполняет JavaScript-скрипты. В результате этих операций веб-страница отображается на экране пользователя.</li>
</ol>
<h3>HTTP и HTTPS</h3>
<p><strong>HTTP (Hypertext Transfer Protocol)</strong> — это протокол передачи гипертекста, который используется для обмена данными между веб-браузером и веб-сервером. Это основной протокол для передачи информации в Интернете. Однако HTTP не обеспечивает шифрование данных, что делает его уязвимым для перехвата информации.</p>
<p><strong>HTTPS (Hypertext Transfer Protocol Secure)</strong> — это защищенная версия HTTP. В HTTPS данные шифруются с использованием протоколов SSL (Secure Sockets Layer) или TLS (Transport Layer Security). Это обеспечивает конфиденциальность и целостность данных, передаваемых между клиентом и сервером, что крайне важно для защиты личной информации, такой как пароли, данные кредитных карт и т.д. Сайты, использующие HTTPS, обычно имеют значок замка в адресной строке браузера.</p>
<h2>1.2. Знакомство с основными инструментами: текстовый редактор (VS Code) и браузер</h2>
<p>Для эффективной веб-разработки необходимо освоить несколько ключевых инструментов. Два из них являются абсолютно базовыми: текстовый редактор кода и веб-браузер с инструментами разработчика.</p>
<h3>Текстовый редактор кода: Visual Studio Code (VS Code)</h3>
<p>Visual Studio Code (VS Code) — это бесплатный, кроссплатформенный и мощный текстовый редактор кода, разработанный Microsoft. Он стал де-факто стандартом для многих веб-разработчиков благодаря своей гибкости, обширной экосистеме расширений и встроенным функциям, которые значительно упрощают процесс кодирования.</p>
<p><strong>Основные возможности VS Code для веб-разработки:</strong></p>
<ul>
<li><strong>Подсветка синтаксиса:</strong> Автоматически выделяет различные элементы кода (теги, атрибуты, ключевые слова) разными цветами, что улучшает читаемость и помогает быстро находить ошибки.</li>
<li><strong>Автодополнение кода (IntelliSense):</strong> Предлагает варианты завершения кода по мере ввода, что ускоряет процесс написания и снижает количество опечаток. Поддерживает HTML, CSS, JavaScript и многие другие языки.</li>
<li><strong>Встроенный терминал:</strong> Позволяет выполнять команды командной строки прямо из редактора, что удобно для запуска локальных серверов, установки пакетов и работы с Git.</li>
<li><strong>Интеграция с Git:</strong> Позволяет легко управлять версиями кода, отслеживать изменения, делать коммиты и работать с удаленными репозиториями (например, GitHub) прямо из VS Code.</li>
<li><strong>Расширения:</strong> Огромное количество расширений, которые добавляют новую функциональность, такую как Live Server (для автоматического обновления страницы в браузере при сохранении изменений), Prettier (для форматирования кода), ESLint (для анализа кода на ошибки и соответствие стандартам) и многие другие.</li>
<li><strong>Отладка:</strong> Встроенные инструменты для отладки JavaScript-кода, позволяющие пошагово выполнять код, устанавливать точки останова и проверять значения переменных.</li>
</ul>
<p><strong>Установка VS Code:</strong></p>
<ol>
<li>Перейдите на официальный сайт Visual Studio Code: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></li>
<li>Скачайте установочный файл, соответствующий вашей операционной системе (Windows, macOS, Linux).</li>
<li>Запустите установочный файл и следуйте инструкциям. Рекомендуется оставить все настройки по умолчанию.</li>
</ol>
<p><strong>Базовая настройка и использование:</strong></p>
<ul>
<li><strong>Открытие папки проекта:</strong> В VS Code вы работаете с папками. Откройте папку, в которой будут храниться файлы вашего веб-сайта, через меню <code>File &gt; Open Folder...</code>.</li>
<li><strong>Создание нового файла:</strong> <code>File &gt; New File</code> или <code>Ctrl+N</code> (Cmd+N на macOS). Сохраните файл с соответствующим расширением (например, <code>index.html</code>, <code>style.css</code>, <code>script.js</code>).</li>
<li><strong>Установка расширений:</strong> Нажмите на иконку </li>
</ul>
<p>Расширения<code>(квадрат из четырех квадратов) на боковой панели, найдите нужное расширение (например,</code>Live Server<code>) и нажмите</code>Install`.</p>
<h3>Браузер и инструменты разработчика</h3>
<p>Веб-браузер — это не только средство просмотра веб-страниц, но и мощный инструмент для их разработки и отладки. Все современные браузеры (Chrome, Firefox, Edge, Safari) имеют встроенные «Инструменты разработчика» (Developer Tools), которые предоставляют доступ к внутренней структуре страницы, стилям, скриптам, сетевым запросам и многому другому.</p>
<p><strong>Как открыть Инструменты разработчика:</strong></p>
<ul>
<li><strong>Google Chrome / Microsoft Edge:</strong> Нажмите <code>F12</code> или <code>Ctrl+Shift+I</code> (Cmd+Option+I на macOS). Также можно кликнуть правой кнопкой мыши на любом элементе страницы и выбрать <code>Inspect</code> (Просмотреть код).</li>
<li><strong>Mozilla Firefox:</strong> Нажмите <code>F12</code> или <code>Ctrl+Shift+I</code> (Cmd+Option+I на macOS). Также можно кликнуть правой кнопкой мыши на любом элементе страницы и выбрать <code>Inspect Element</code> (Исследовать элемент).</li>
<li><strong>Safari:</strong> Сначала нужно включить меню «Разработка» в настройках Safari (<code>Safari &gt; Preferences &gt; Advanced &gt; Show Develop menu in menu bar</code>), затем <code>Develop &gt; Show Web Inspector</code> (Cmd+Option+I).</li>
</ul>
<p><strong>Основные вкладки Инструментов разработчика:</strong></p>
<ul>
<li>
<p><strong>Elements (Элементы):</strong> Позволяет просматривать и редактировать HTML-структуру страницы в реальном времени. Вы можете видеть, как элементы вложены друг в друга, изменять их атрибуты и содержимое. В правой части этой вкладки отображаются примененные CSS-стили, что очень удобно для отладки стилей.</p>
<ul>
<li><strong>Практическое применение:</strong> Изменение текста заголовка, скрытие элемента, изменение цвета фона элемента.</li>
</ul>
</li>
<li>
<p><strong>Console (Консоль):</strong> Используется для вывода сообщений из JavaScript-кода (например, <code>console.log()</code>), а также для выполнения JavaScript-команд в реальном времени. Здесь отображаются ошибки JavaScript и сетевые ошибки.</p>
<ul>
<li><strong>Практическое применение:</strong> Проверка значений переменных, вызов функций, отладка ошибок скриптов.</li>
</ul>
</li>
<li>
<p><strong>Sources (Источники):</strong> Позволяет просматривать исходный код HTML, CSS и JavaScript файлов, загруженных страницей. Здесь можно устанавливать точки останова (breakpoints) в JavaScript-коде для пошаговой отладки.</p>
<ul>
<li><strong>Практическое применение:</strong> Отладка сложного JavaScript-кода, понимание логики работы сторонних скриптов.</li>
</ul>
</li>
<li>
<p><strong>Network (Сеть):</strong> Отображает все сетевые запросы, которые браузер делает для загрузки страницы (HTML, CSS, JS, изображения, шрифты и т.д.). Здесь можно увидеть время загрузки каждого ресурса, размер файла, статус ответа сервера.</p>
<ul>
<li><strong>Практическое применение:</strong> Оптимизация скорости загрузки страницы, выявление медленных запросов, проверка наличия ресурсов.</li>
</ul>
</li>
<li>
<p><strong>Application (Приложение):</strong> Позволяет просматривать и управлять различными типами хранилищ данных, используемых веб-сайтом, такими как Local Storage, Session Storage, Cookies, IndexedDB, а также Service Workers и Manifest.</p>
<ul>
<li><strong>Практическое применение:</strong> Отладка авторизации, проверка данных, сохраняемых на стороне клиента.</li>
</ul>
</li>
</ul>
<p><strong>Важность использования Инструментов разработчика:</strong></p>
<p>Инструменты разработчика являются незаменимым помощником для любого веб-разработчика. Они позволяют:</p>
<ul>
<li><strong>Быстро отлаживать проблемы:</strong> Мгновенно видеть, почему элемент выглядит не так, как ожидалось, или почему скрипт не работает.</li>
<li><strong>Экспериментировать в реальном времени:</strong> Изменять HTML и CSS прямо в браузере, чтобы увидеть результат без перезагрузки страницы и редактирования файлов.</li>
<li><strong>Понимать, как работают другие сайты:</strong> Изучать структуру и стили чужих веб-страниц для обучения и вдохновения.</li>
<li><strong>Оптимизировать производительность:</strong> Анализировать время загрузки ресурсов и выявлять узкие места.</li>
</ul>
<p>В ходе курса мы будем активно использовать Инструменты разработчика для понимания и отладки нашего кода. Рекомендуется постоянно держать их открытыми во время практических занятий.</p>
<hr />
<h1>Лекция 2: Основы HTML</h1>
<h2>2.1. Структура HTML-документа</h2>
<p>HTML (HyperText Markup Language) — это стандартный язык разметки документов для просмотра веб-страниц в браузере. Он используется для определения структуры и содержимого веб-страницы. HTML не является языком программирования; это язык разметки, который использует теги для описания различных частей документа.</p>
<p>Каждый HTML-документ имеет базовую структуру, которая является обязательной для корректного отображения в браузере. Эта структура включает в себя несколько ключевых элементов:</p>
<ul>
<li>
<p><code>&lt;!DOCTYPE html&gt;</code>: Это объявление типа документа (Document Type Declaration). Оно всегда должно быть первой строкой в HTML-документе. <code>&lt;!DOCTYPE html&gt;</code> сообщает браузеру, что документ написан на HTML5, самой современной версии HTML. Это не HTML-тег, а инструкция для браузера.</p>
</li>
<li>
<p><code>&lt;html&gt;</code>: Корневой элемент HTML-страницы. Все остальное содержимое страницы должно находиться внутри этого тега. Атрибут `lang=</p>
</li>
</ul>
<p><code>lang</code> (например, <code>lang="ru"</code> для русского языка) рекомендуется использовать для указания основного языка документа, что улучшает доступность и помогает поисковым системам.</p>
<ul>
<li>
<p><code>&lt;head&gt;</code>: Этот элемент содержит метаданные о HTML-документе, которые не отображаются непосредственно на веб-странице. Метаданные включают в себя информацию о кодировке символов, заголовок страницы, ссылки на внешние таблицы стилей (CSS) и скрипты (JavaScript), а также другие данные, используемые браузерами и поисковыми системами.</p>
<p>Основные элементы внутри <code>&lt;head&gt;</code>:
*   <code>&lt;meta charset="UTF-8"&gt;</code>: Указывает кодировку символов для документа. <code>UTF-8</code> является наиболее распространенной и рекомендуемой кодировкой, так как она поддерживает большинство символов из всех языков.
*   <code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code>: Важный мета-тег для адаптивного дизайна. Он указывает браузеру, как масштабировать страницу на различных устройствах. <code>width=device-width</code> устанавливает ширину области просмотра равной ширине экрана устройства, а <code>initial-scale=1.0</code> устанавливает начальный уровень масштабирования.
*   <code>&lt;title&gt;Заголовок страницы&lt;/title&gt;</code>: Определяет заголовок веб-страницы, который отображается во вкладке браузера или в заголовке окна. Этот заголовок также используется поисковыми системами.
*   <code>&lt;link rel="stylesheet" href="style.css"&gt;</code>: Используется для подключения внешних таблиц стилей CSS. Атрибут <code>rel="stylesheet"</code> указывает на то, что это таблица стилей, а <code>href="style.css"</code> указывает путь к файлу CSS.
*   <code>&lt;script src="script.js"&gt;&lt;/script&gt;</code>: Используется для подключения внешних JavaScript-файлов. Атрибут <code>src="script.js"</code> указывает путь к файлу JavaScript. Обычно скрипты размещают в конце <code>&lt;body&gt;</code> для оптимизации загрузки страницы, но могут быть и в <code>&lt;head&gt;</code>.</p>
</li>
<li>
<p><code>&lt;body&gt;</code>: Этот элемент содержит все видимое содержимое веб-страницы. Все, что вы видите в окне браузера (текст, изображения, ссылки, таблицы, формы и т.д.), находится внутри тега <code>&lt;body&gt;</code>.</p>
</li>
</ul>
<p><strong>Пример базовой структуры HTML-документа:</strong></p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моя первая веб-страница</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Привет, мир!</h1>
    <p>Это моя первая веб-страница, созданная с использованием HTML.</p>
    <script src="script.js"></script>
</body>
</html>
<p>```</p>
<h2>2.2. Основные теги для работы с текстом</h2>
<p>HTML предоставляет множество тегов для структурирования и форматирования текстового содержимого. Правильное использование этих тегов не только делает ваш контент читаемым, но и улучшает его семантику, что важно для доступности и поисковой оптимизации.</p>
<h3>Заголовки: <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code></h3>
<p>Заголовки используются для определения иерархии и структуры контента на странице. Существует шесть уровней заголовков, от <code>&lt;h1&gt;</code> (самый важный, обычно используется для основного заголовка страницы) до <code>&lt;h6&gt;</code> (наименее важный). Использование заголовков помогает пользователям и поисковым системам понять структуру документа.</p>
<p>```html</p>
<h1>Главный заголовок страницы</h1>
<h2>Подзаголовок раздела</h2>
<h3>Подзаголовок подраздела</h3>
<h4>Еще один уровень заголовка</h4>
<h5>Мелкий заголовок</h5>
<h6>Самый мелкий заголовок</h6>
<p>```</p>
<h3>Параграфы: <code>&lt;p&gt;</code></h3>
<p>Тег <code>&lt;p&gt;</code> используется для определения текстовых параграфов. Каждый параграф обычно отображается с отступом сверху и снизу, отделяя его от других элементов.</p>
<p>```html</p>
<p>Это первый параграф текста на моей веб-странице. Здесь я могу написать любую информацию, которую хочу донести до читателя.</p>
<p>Это второй параграф. HTML автоматически добавляет отступы между параграфами, делая текст более читаемым.</p>
<p>```</p>
<h3>Ссылки: <code>&lt;a&gt;</code></h3>
<p>Тег <code>&lt;a&gt;</code> (anchor) используется для создания гиперссылок, которые позволяют пользователям переходить между страницами или к определенным разделам на той же странице. Самый важный атрибут для <code>&lt;a&gt;</code> — это <code>href</code> (hypertext reference), который указывает URL назначения ссылки.</p>
<p>```html</p>
<p>Посетите <a href="https://www.google.com">Google</a> для поиска информации.</p>
<p>Узнайте больше о <a href="#html-basics">основах HTML</a> на этой же странице.</p>
<p>```</p>
<p><strong>Важные атрибуты <code>&lt;a&gt;</code>:</strong></p>
<ul>
<li><code>href</code>: Указывает URL, на который ведет ссылка. Может быть абсолютным (начинается с <code>http://</code> или <code>https://</code>) или относительным (путь к файлу в рамках того же сайта).</li>
<li><code>target</code>: Определяет, где будет открыта связанная ссылка.<ul>
<li><code>_self</code> (по умолчанию): Открывает ссылку в том же окне/вкладке.</li>
<li><code>_blank</code>: Открывает ссылку в новом окне/вкладке.</li>
<li><code>_parent</code>: Открывает ссылку в родительском фрейме.</li>
<li><code>_top</code>: Открывает ссылку в полном теле окна.</li>
</ul>
</li>
<li><code>title</code>: Предоставляет всплывающую подсказку, которая появляется при наведении курсора на ссылку.</li>
</ul>
<p>```html</p>
<p>Откройте <a href="https://www.wikipedia.org" target="_blank" title="Энциклопедия Wikipedia">Википедию</a> в новой вкладке.</p>
<p>```</p>
<h3>Списки: <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code></h3>
<p>HTML поддерживает два основных типа списков:</p>
<ul>
<li>
<p><strong>Неупорядоченные списки (<code>&lt;ul&gt;</code> - unordered list):</strong> Элементы списка обозначаются маркерами (обычно точками). Каждый элемент списка определяется тегом <code>&lt;li&gt;</code> (list item).</p>
<p><code>html
&lt;h2&gt;Мои любимые фрукты:&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;Яблоки&lt;/li&gt;
    &lt;li&gt;Бананы&lt;/li&gt;
    &lt;li&gt;Апельсины&lt;/li&gt;
&lt;/ul&gt;</code></p>
</li>
<li>
<p><strong>Упорядоченные списки (<code>&lt;ol&gt;</code> - ordered list):</strong> Элементы списка нумеруются (по умолчанию арабскими цифрами). Каждый элемент списка также определяется тегом <code>&lt;li&gt;</code>.</p>
<p><code>html
&lt;h2&gt;Шаги приготовления кофе:&lt;/h2&gt;
&lt;ol&gt;
    &lt;li&gt;Нагрейте воду.&lt;/li&gt;
    &lt;li&gt;Добавьте кофе в чашку.&lt;/li&gt;
    &lt;li&gt;Залейте горячей водой.&lt;/li&gt;
    &lt;li&gt;Наслаждайтесь!&lt;/li&gt;
&lt;/ol&gt;</code></p>
</li>
</ul>
<h3>Выделение текста: <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code></h3>
<ul>
<li><code>&lt;strong&gt;</code>: Используется для выделения важного текста. Браузеры обычно отображают его жирным шрифтом. Семантически указывает на важность содержимого.</li>
<li><code>&lt;em&gt;</code> (emphasis): Используется для выделения текста с акцентом. Браузеры обычно отображают его курсивом. Семантически указывает на акцент или ударение.</li>
</ul>
<p>```html</p>
<p>Это <strong>очень важная</strong> информация, которую необходимо запомнить.</p>
<p>Я <em>действительно</em> люблю программировать.</p>
<p>```</p>
<hr />
<h2>2.3. Работа с изображениями: <code>&lt;img&gt;</code></h2>
<p>Изображения являются неотъемлемой частью большинства веб-сайтов, делая их более привлекательными и информативными. Тег <code>&lt;img&gt;</code> используется для встраивания изображений в HTML-документ. Это самозакрывающийся тег, то есть у него нет закрывающего тега.</p>
<p><code>html
&lt;img src="путь/к/изображению.jpg" alt="Описание изображения"&gt;</code></p>
<p><strong>Основные атрибуты <code>&lt;img&gt;</code>:</strong></p>
<ul>
<li>
<p><code>src</code> (source): <strong>Обязательный</strong> атрибут, который указывает путь к файлу изображения. Путь может быть абсолютным URL (например, <code>https://example.com/images/photo.jpg</code>) или относительным (например, <code>images/photo.jpg</code> или <code>../photo.png</code>).</p>
</li>
<li>
<p><code>alt</code> (alternative text): <strong>Обязательный</strong> атрибут, который предоставляет альтернативный текст для изображения. Этот текст отображается, если изображение не может быть загружено (например, из-за ошибки в пути или проблем с сетью), или если пользователь использует скринридер (программу для чтения экрана). <code>alt</code> текст крайне важен для доступности веб-сайта и для SEO (поисковой оптимизации).</p>
<p><code>html
&lt;img src="images/nature.jpg" alt="Красивый пейзаж с горами и озером"&gt;</code></p>
</li>
<li>
<p><code>width</code> и <code>height</code>: Используются для указания ширины и высоты изображения в пикселях. Хотя эти атрибуты можно использовать для изменения размера изображения, <strong>рекомендуется делать это с помощью CSS</strong> для лучшего контроля и адаптивности. Если указан только один из этих атрибутов, браузер автоматически масштабирует изображение, сохраняя пропорции.</p>
<p><code>html
&lt;img src="images/logo.png" alt="Логотип компании" width="150" height="100"&gt;</code></p>
<p><strong>Важное замечание:</strong> Указание <code>width</code> и <code>height</code> в HTML помогает браузеру зарезервировать место для изображения до его полной загрузки, что предотвращает </p>
</li>
</ul>
<p>сдвиги макета (layout shifts) при загрузке страницы.</p>
<h2>2.4. Формы и поля ввода: <code>&lt;form&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>, <code>&lt;label&gt;</code></h2>
<p>Веб-формы являются ключевым элементом интерактивности на веб-сайтах, позволяя пользователям вводить данные, отправлять запросы, регистрироваться, авторизоваться, делать покупки и многое другое. HTML предоставляет набор тегов для создания форм и различных элементов ввода.</p>
<h3>Форма: <code>&lt;form&gt;</code></h3>
<p>Тег <code>&lt;form&gt;</code> используется для создания HTML-формы. Он служит контейнером для всех элементов управления формой (полей ввода, кнопок, выпадающих списков и т.д.).</p>
<p><strong>Основные атрибуты <code>&lt;form&gt;</code>:</strong></p>
<ul>
<li><code>action</code>: Указывает URL-адрес, на который будут отправлены данные формы при ее отправке. Обычно это адрес скрипта на сервере, который обрабатывает данные.</li>
<li><code>method</code>: Определяет HTTP-метод, используемый для отправки данных формы. Наиболее распространенные значения:<ul>
<li><code>GET</code>: Данные формы добавляются к URL-ададресу в виде параметров запроса. Подходит для отправки небольших объемов нечувствительных данных (например, поисковые запросы). Данные видны в адресной строке браузера.</li>
<li><code>POST</code>: Данные формы отправляются в теле HTTP-запроса. Подходит для отправки больших объемов данных или конфиденциальной информации (пароли, личные данные). Данные не видны в адресной строке.</li>
</ul>
</li>
</ul>
<p>```html</p>
<form action="/submit-form" method="POST">
    <!-- Элементы формы будут здесь -->
</form>
<p>```</p>
<h3>Поля ввода: <code>&lt;input&gt;</code></h3>
<p>Тег <code>&lt;input&gt;</code> является одним из самых универсальных элементов формы. Его поведение определяется атрибутом <code>type</code>. Это самозакрывающийся тег.</p>
<p><strong>Основные атрибуты <code>&lt;input&gt;</code>:</strong></p>
<ul>
<li>
<p><code>type</code>: Определяет тип поля ввода. Вот некоторые из наиболее часто используемых типов:</p>
<ul>
<li><code>text</code>: Однострочное текстовое поле (по умолчанию).</li>
<li><code>password</code>: Поле для ввода пароля (символы скрыты).</li>
<li><code>email</code>: Поле для ввода адреса электронной почты. Браузеры могут выполнять базовую валидацию формата.</li>
<li><code>number</code>: Поле для ввода чисел. Браузеры могут отображать стрелки для увеличения/уменьшения значения.</li>
<li><code>checkbox</code>: Флажок. Позволяет выбрать несколько опций.</li>
<li><code>radio</code>: Переключатель. Позволяет выбрать только одну опцию из группы (группируются по атрибуту <code>name</code>).</li>
<li><code>submit</code>: Кнопка для отправки формы.</li>
<li><code>button</code>: Обычная кнопка (не отправляет форму по умолчанию).</li>
<li><code>file</code>: Поле для выбора файла для загрузки.</li>
<li><code>date</code>: Поле для выбора даты.</li>
<li><code>hidden</code>: Скрытое поле. Используется для передачи данных, которые не должны быть видны пользователю.</li>
</ul>
</li>
<li>
<p><code>name</code>: <strong>Обязательный</strong> атрибут для всех полей ввода, данные которых должны быть отправлены на сервер. Значение <code>name</code> используется как ключ для идентификации данных при их получении на сервере.</p>
</li>
<li>
<p><code>value</code>: Начальное значение поля ввода.</p>
</li>
<li>
<p><code>placeholder</code>: Краткая подсказка, которая отображается в поле ввода, когда оно пустое. Исчезает при вводе текста.</p>
</li>
<li>
<p><code>required</code>: Булевый атрибут. Если присутствует, поле должно быть заполнено перед отправкой формы.</p>
</li>
<li>
<p><code>disabled</code>: Булевый атрибут. Если присутствует, поле неактивно и его значение не может быть изменено или отправлено.</p>
</li>
<li>
<p><code>readonly</code>: Булевый атрибут. Если присутствует, поле доступно только для чтения, но его значение будет отправлено с формой.</p>
</li>
</ul>
<p><strong>Примеры использования <code>&lt;input&gt;</code>:</strong></p>
<p>```html
<input type="text" name="username" placeholder="Введите ваше имя" required>
<input type="password" name="password" placeholder="Пароль">
<input type="email" name="user_email" value="test@example.com"></p>
<p><input type="checkbox" name="newsletter" value="yes" id="newsletter_signup">
<label for="newsletter_signup">Подписаться на рассылку</label></p>
<p><input type="radio" name="gender" value="male" id="gender_male">
<label for="gender_male">Мужской</label>
<input type="radio" name="gender" value="female" id="gender_female">
<label for="gender_female">Женский</label></p>
<p><input type="submit" value="Отправить форму">
```</p>
<h3>Многострочное текстовое поле: <code>&lt;textarea&gt;</code></h3>
<p>Тег <code>&lt;textarea&gt;</code> используется для создания многострочного текстового поля, где пользователи могут вводить более длинные тексты, например, сообщения или комментарии. В отличие от <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> имеет закрывающий тег, и начальное значение помещается между открывающим и закрывающим тегами.</p>
<p><strong>Основные атрибуты <code>&lt;textarea&gt;</code>:</strong></p>
<ul>
<li><code>name</code>: Имя поля для отправки данных.</li>
<li><code>rows</code>: Количество видимых строк.</li>
<li><code>cols</code>: Количество видимых столбцов.</li>
<li><code>placeholder</code>, <code>required</code>, <code>disabled</code>, <code>readonly</code>: Аналогично атрибутам <code>&lt;input&gt;</code>.</li>
</ul>
<p>```html</p>
<textarea name="message" rows="5" cols="30" placeholder="Ваше сообщение..."></textarea>
<p>```</p>
<h3>Кнопка: <code>&lt;button&gt;</code></h3>
<p>Тег <code>&lt;button&gt;</code> используется для создания кнопок. В отличие от <code>&lt;input type="button"&gt;</code> или <code>&lt;input type="submit"&gt;</code>, тег <code>&lt;button&gt;</code> позволяет размещать внутри себя HTML-содержимое (например, текст, изображения), что дает больше гибкости в стилизации.</p>
<p><strong>Основные атрибуты <code>&lt;button&gt;</code>:</strong></p>
<ul>
<li><code>type</code>: Определяет поведение кнопки.<ul>
<li><code>submit</code> (по умолчанию): Отправляет форму.</li>
<li><code>button</code>: Обычная кнопка, которая не отправляет форму. Используется для JavaScript-функций.</li>
<li><code>reset</code>: Сбрасывает все поля формы к их начальным значениям.</li>
</ul>
</li>
</ul>
<p><code>html
&lt;button type="submit"&gt;Отправить&lt;/button&gt;
&lt;button type="button"&gt;Нажми меня&lt;/button&gt;
&lt;button type="reset"&gt;Очистить форму&lt;/button&gt;</code></p>
<h3>Метка для поля ввода: <code>&lt;label&gt;</code></h3>
<p>Тег <code>&lt;label&gt;</code> используется для создания метки (подписи) для элемента формы. Связывание метки с полем ввода улучшает доступность, так как при клике на метку фокус переходит к соответствующему полю ввода. Это особенно полезно для флажков и переключателей.</p>
<p><strong>Как связать <code>&lt;label&gt;</code> с полем ввода:</strong></p>
<p>Используйте атрибут <code>for</code> в теге <code>&lt;label&gt;</code>, значение которого должно совпадать со значением атрибута <code>id</code> соответствующего поля ввода.</p>
<p>```html
<label for="user_name">Имя пользователя:</label>
<input type="text" id="user_name" name="username"></p>
<p><input type="checkbox" id="agree_terms" name="terms">
<label for="agree_terms">Я согласен с условиями</label>
```</p>
<p>Правильное использование форм и их элементов является фундаментальным для создания интерактивных веб-приложений. Понимание различных типов ввода и их атрибутов позволит вам создавать эффективные и удобные для пользователя формы.</p>
<hr />
<h1>Лекция 3: Основы CSS</h1>
<h2>3.1. Способы подключения CSS</h2>
<p>CSS (Cascading Style Sheets) — это язык таблиц стилей, используемый для описания представления документа, написанного на языке разметки, таком как HTML. CSS отделяет содержание документа от его представления, что позволяет значительно упростить процесс веб-разработки, улучшить доступность и обеспечить гибкость отображения на различных устройствах. Без CSS веб-страницы выглядели бы как простой текст с синими ссылками, без какого-либо дизайна или форматирования.</p>
<p>Существует три основных способа подключения CSS к HTML-документу:</p>
<h3>1. Внешние таблицы стилей (External Style Sheets)</h3>
<p>Это наиболее рекомендуемый и часто используемый способ подключения CSS. Стили хранятся в отдельном файле с расширением <code>.css</code> (например, <code>style.css</code>), который затем подключается к HTML-документу. Это позволяет применять одни и те же стили к нескольким HTML-страницам, что значительно упрощает управление дизайном и его обновление.</p>
<p><strong>Преимущества:</strong>
*   <strong>Разделение ответственности:</strong> HTML отвечает за структуру, CSS — за внешний вид. Это делает код более чистым и легким для чтения и поддержки.
*   <strong>Повторное использование:</strong> Один CSS-файл может быть использован для стилизации множества HTML-страниц, что экономит время и уменьшает размер файлов.
*   <strong>Кэширование:</strong> Браузеры кэшируют внешние CSS-файлы, что ускоряет загрузку страниц при повторных посещениях.</p>
<p><strong>Как подключить:</strong>
Внутри тега <code>&lt;head&gt;</code> HTML-документа используется тег <code>&lt;link&gt;</code>:</p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моя страница</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Привет!</h1>
    <p>Это пример использования внешних стилей.</p>
</body>
</html>
<p>```</p>
<p>В данном примере <code>style.css</code> — это имя файла, содержащего CSS-правила. Он должен находиться в той же директории, что и HTML-файл, или по указанному относительному/абсолютному пути.</p>
<p><strong>Пример <code>style.css</code>:</strong></p>
<p><code>css
/* style.css */
body {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    color: #333;
}
h1 {
    color: navy;
    text-align: center;
}</code></p>
<h3>2. Внутренние таблицы стилей (Internal Style Sheets)</h3>
<p>Стили определяются непосредственно внутри HTML-документа, в теге <code>&lt;style&gt;</code>, который размещается внутри тега <code>&lt;head&gt;</code>. Этот метод подходит для стилизации одной конкретной страницы, когда стили не будут использоваться на других страницах.</p>
<p><strong>Преимущества:</strong>
*   <strong>Удобство для одной страницы:</strong> Все стили находятся в одном файле с HTML, что удобно для небольших проектов или отдельных страниц.</p>
<p><strong>Недостатки:</strong>
*   <strong>Отсутствие повторного использования:</strong> Стили не могут быть легко применены к другим страницам.
*   <strong>Увеличение размера HTML-файла:</strong> Стили загружаются каждый раз при загрузке страницы, даже если они не изменились.</p>
<p><strong>Как подключить:</strong></p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моя страница</title>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            background-color: #e0e0e0;
            color: #222;
        }
        h1 {
            color: darkgreen;
            text-align: left;
        }
    </style>
</head>
<body>
    <h1>Привет!</h1>
    <p>Это пример использования внутренних стилей.</p>
</body>
</html>
<p>```</p>
<h3>3. Инлайн-стили (Inline Styles)</h3>
<p>Стили применяются непосредственно к отдельному HTML-элементу с помощью атрибута <code>style</code>. Этот метод наименее предпочтителен, так как он смешивает структуру и представление, затрудняет поддержку кода и не позволяет повторно использовать стили.</p>
<p><strong>Преимущества:</strong>
*   <strong>Высокий приоритет:</strong> Инлайн-стили имеют наивысший приоритет и переопределяют все другие стили (кроме <code>!important</code>).
*   <strong>Быстрое тестирование:</strong> Удобно для быстрого тестирования или применения уникальных стилей к одному элементу.</p>
<p><strong>Недостатки:</strong>
*   <strong>Плохая читаемость и поддержка:</strong> Код становится громоздким и сложным для чтения.
*   <strong>Отсутствие повторного использования:</strong> Стили привязаны к конкретному элементу.
*   <strong>Проблемы с доступностью:</strong> Затрудняет изменение стилей для всей страницы или сайта.</p>
<p><strong>Как подключить:</strong></p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моя страница</title>
</head>
<body>
    <h1 style="color: purple; text-align: right;">Привет!</h1>
    <p style="font-size: 18px; background-color: lightblue;">Это пример использования инлайн-стилей.</p>
</body>
</html>
<p>```</p>
<h3>Приоритет стилей (Каскадность)</h3>
<p>Важно понимать, что CSS расшифровывается как Cascading Style Sheets, что означает </p>
<p>что стили применяются в определенном порядке, и более специфичные или позднее определенные стили переопределяют менее специфичные или ранее определенные. Порядок приоритета (от низшего к высшему):</p>
<ol>
<li><strong>Стили браузера по умолчанию</strong> (User Agent Stylesheets)</li>
<li><strong>Внешние и внутренние таблицы стилей</strong> (External and Internal Style Sheets) — порядок имеет значение: тот, что определен позже, имеет больший приоритет.</li>
<li><strong>Инлайн-стили</strong> (Inline Styles)</li>
<li><strong><code>!important</code> правило:</strong> Использование <code>!important</code> после значения свойства (например, <code>color: red !important;</code>) придает этому свойству наивысший приоритет, переопределяя все остальные стили, включая инлайн-стили. Однако его использование <strong>не рекомендуется</strong> без крайней необходимости, так как оно затрудняет отладку и поддержку кода.</li>
</ol>
<h2>3.2. Селекторы</h2>
<p>Селекторы CSS используются для «нахождения» (или выбора) HTML-элементов, которые вы хотите стилизовать. После того как элемент выбран, вы можете применить к нему набор CSS-свойств.</p>
<h3>1. Селектор по тегу (Element Selector)</h3>
<p>Выбирает все элементы с указанным именем тега.</p>
<p><code>css
p {
    font-family: Verdana, sans-serif;
    line-height: 1.6;
}
h1 {
    font-size: 36px;
    color: #333;
}</code></p>
<p>В этом примере все параграфы (<code>&lt;p&gt;</code>) на странице будут иметь шрифт Verdana и межстрочный интервал 1.6, а все заголовки первого уровня (<code>&lt;h1&gt;</code>) будут иметь размер шрифта 36px и темно-серый цвет.</p>
<h3>2. Селектор по классу (Class Selector)</h3>
<p>Выбирает элементы с указанным атрибутом <code>class</code>. Классы позволяют применять одни и те же стили к нескольким элементам, независимо от их типа. Имя класса в CSS начинается с точки (<code>.</code>).</p>
<p>```html</p>
<p class="highlight">Этот текст будет выделен.</p>
<div class="highlight">Этот блок тоже будет выделен.</div>
<p>```</p>
<p><code>css
.highlight {
    background-color: yellow;
    font-weight: bold;
}</code></p>
<h3>3. Селектор по ID (ID Selector)</h3>
<p>Выбирает элемент с указанным атрибутом <code>id</code>. ID должен быть уникальным на всей HTML-странице, поэтому селектор по ID используется для стилизации одного конкретного элемента. Имя ID в CSS начинается с символа решетки (<code>#</code>).</p>
<p>```html</p>
<h2 id="main-title">Добро пожаловать!</h2>
<p>```</p>
<p>```css</p>
<h1>main-title {</h1>
<pre><code>color: blue;
text-align: center;
</code></pre>
<p>}
```</p>
<p><strong>Разница между Class и ID:</strong>
*   <strong>Class:</strong> Может быть применен к множеству элементов. Используется для стилизации групп элементов.
*   <strong>ID:</strong> Должен быть уникальным на странице (применяется только к одному элементу). Используется для стилизации конкретного, уникального элемента или для JavaScript-манипуляций.</p>
<h3>4. Селектор по атрибуту (Attribute Selector)</h3>
<p>Выбирает элементы на основе наличия или значения их атрибутов.</p>
<p><code>css
a[target="_blank"] {
    color: green;
}
input[type="text"] {
    border: 1px solid gray;
}</code></p>
<h3>5. Псевдоклассы (Pseudo-classes)</h3>
<p>Используются для определения особого состояния элемента. Они начинаются с двоеточия (<code>:</code>).</p>
<ul>
<li><code>:hover</code>: Применяется, когда указатель мыши находится над элементом.</li>
<li><code>:active</code>: Применяется, когда элемент активирован (например, при нажатии кнопки мыши).</li>
<li><code>:focus</code>: Применяется, когда элемент получает фокус (например, поле ввода).</li>
<li><code>:nth-child(n)</code>: Выбирает элемент, который является n-м дочерним элементом своего родителя.</li>
<li><code>:first-child</code>, <code>:last-child</code> и т.д.</li>
</ul>
<p><code>css
a:hover {
    color: red;
    text-decoration: underline;
}
input:focus {
    border-color: blue;
    box-shadow: 0 0 5px rgba(0, 0, 255, 0.5);
}
li:nth-child(odd) {
    background-color: #f2f2f2;
}</code></p>
<h3>6. Псевдоэлементы (Pseudo-elements)</h3>
<p>Используются для стилизации определенной части элемента. Они начинаются с двойного двоеточия (<code>::</code>).</p>
<ul>
<li><code>::before</code>: Вставляет содержимое перед содержимым элемента.</li>
<li><code>::after</code>: Вставляет содержимое после содержимого элемента.</li>
<li><code>::first-line</code>: Стилизует первую строку текстового блока.</li>
<li><code>::first-letter</code>: Стилизует первую букву текстового блока.</li>
</ul>
<p><code>css
p::first-letter {
    font-size: 200%;
    color: #888;
}
h1::after {
    content: " -- New!";
    color: orange;
}</code></p>
<h3>Комбинаторы (Combinators)</h3>
<p>Комбинаторы используются для объединения селекторов, чтобы выбрать элементы на основе их отношения друг к другу.</p>
<ul>
<li>
<p><strong>Селектор потомка (Descendant Selector):</strong> Пробел (<code></code>) между селекторами. Выбирает все элементы, которые являются потомками указанного элемента.</p>
<p><code>css
div p {
color: brown;
}
/* Выберет все &lt;p&gt; внутри &lt;div&gt; */</code></p>
</li>
<li>
<p><strong>Дочерний селектор (Child Selector):</strong> Знак больше (<code>&gt;</code>). Выбирает элементы, которые являются прямыми дочерними элементами указанного элемента.</p>
<p><code>css
div &gt; p {
font-weight: bold;
}
/* Выберет только те &lt;p&gt;, которые являются непосредственными дочерними элементами &lt;div&gt; */</code></p>
</li>
<li>
<p><strong>Селектор соседнего элемента (Adjacent Sibling Selector):</strong> Знак плюс (<code>+</code>). Выбирает элемент, который непосредственно следует за указанным элементом и является его соседом.</p>
<p><code>css
h1 + p {
margin-top: 0;
}
/* Выберет &lt;p&gt;, который идет сразу после &lt;h1&gt; */</code></p>
</li>
<li>
<p><strong>Селектор общего соседнего элемента (General Sibling Selector):</strong> Тильда (<code>~</code>). Выбирает все элементы, которые являются соседями указанного элемента и следуют за ним.</p>
<p><code>css
p ~ span {
background-color: lightgray;
}
/* Выберет все &lt;span&gt;, которые являются соседями &lt;p&gt; и идут после него */</code></p>
</li>
</ul>
<p>Понимание и умелое использование селекторов — это основа эффективной работы с CSS. Они позволяют точно нацеливаться на нужные элементы и применять к ним желаемые стили.</p>
<hr />
<h2>3.3. Основные свойства CSS</h2>
<p>После того как вы выбрали элементы с помощью селекторов, вы можете применять к ним различные CSS-свойства для изменения их внешнего вида. Каждое CSS-правило состоит из селектора и блока объявлений, который содержит одно или несколько объявлений. Каждое объявление состоит из имени свойства и его значения, разделенных двоеточием, и заканчивается точкой с запятой.</p>
<p><code>css
селектор {
    свойство: значение;
    свойство-2: значение-2;
}</code></p>
<p>Рассмотрим некоторые из наиболее часто используемых CSS-свойств.</p>
<h3>Цвет текста: <code>color</code></h3>
<p>Свойство <code>color</code> используется для установки цвета текста элемента.</p>
<p><strong>Значения цвета могут быть заданы различными способами:</strong></p>
<ul>
<li><strong>По имени:</strong> <code>red</code>, <code>blue</code>, <code>green</code>, <code>black</code>, <code>white</code> и т.д. (ограниченный набор).</li>
<li><strong>HEX-коды:</strong> Шестнадцатеричное представление цвета, например, <code>#FF0000</code> (красный), <code>#0000FF</code> (синий), <code>#336699</code>.</li>
<li><strong>RGB:</strong> <code>rgb(красный, зеленый, синий)</code>, где каждое значение от 0 до 255. Например, <code>rgb(255, 0, 0)</code> (красный).</li>
<li><strong>RGBA:</strong> <code>rgba(красный, зеленый, синий, альфа)</code>, где <code>альфа</code> — это значение прозрачности от 0 (полностью прозрачный) до 1 (полностью непрозрачный). Например, <code>rgba(255, 0, 0, 0.5)</code> (полупрозрачный красный).</li>
<li><strong>HSL:</strong> <code>hsl(оттенок, насыщенность, светлота)</code>. Оттенок (hue) от 0 до 360 градусов, насыщенность (saturation) и светлота (lightness) от 0% до 100%.</li>
<li><strong>HSLA:</strong> <code>hsla(оттенок, насыщенность, светлота, альфа)</code>.</li>
</ul>
<p><code>css
p {
    color: blue; /* Цвет текста синий */
}
h1 {
    color: #FF4500; /* Оранжево-красный */
}
.warning {
    color: rgb(255, 99, 71); /* Томатный */
}
.transparent-text {
    color: rgba(0, 0, 0, 0.7); /* Черный, 70% прозрачности */
}</code></p>
<h3>Размер шрифта: <code>font-size</code></h3>
<p>Свойство <code>font-size</code> устанавливает размер шрифта текста.</p>
<p><strong>Единицы измерения размера шрифта:</strong></p>
<ul>
<li><strong><code>px</code> (пиксели):</strong> Абсолютная единица. 1px = 1/96 дюйма. Не масштабируется пользователем.</li>
<li><strong><code>em</code>:</strong> Относительная единица. Размер шрифта элемента относительно размера шрифта его родительского элемента. Например, если родительский элемент имеет <code>font-size: 16px</code>, то <code>1em</code> будет равен <code>16px</code>, а <code>1.5em</code> — <code>24px</code>.</li>
<li><strong><code>rem</code>:</strong> Относительная единица. Размер шрифта элемента относительно размера шрифта корневого элемента (<code>&lt;html&gt;</code>). Это более предсказуемо, чем <code>em</code>, так как не зависит от размера шрифта ближайшего родителя.</li>
<li><strong><code>%</code> (проценты):</strong> Относительно размера шрифта родительского элемента.</li>
<li><strong><code>vw</code> (viewport width):</strong> Относительно ширины области просмотра (viewport). <code>1vw</code> равен 1% ширины области просмотра.</li>
<li><strong><code>vh</code> (viewport height):</strong> Относительно высоты области просмотра. <code>1vh</code> равен 1% высоты области просмотра.</li>
<li><strong><code>vmin</code> / <code>vmax</code>:</strong> Относительно меньшей/большей стороны области просмотра.</li>
</ul>
<p><code>css
p {
    font-size: 16px; /* Размер шрифта 16 пикселей */
}
h2 {
    font-size: 2em; /* В два раза больше размера шрифта родителя */
}
body {
    font-size: 100%; /* Базовый размер шрифта */
}
.responsive-text {
    font-size: 3vw; /* Размер шрифта зависит от ширины экрана */
}</code></p>
<h3>Фон: <code>background</code> (сокращенное свойство)</h3>
<p>Свойство <code>background</code> является сокращенным свойством для установки всех свойств фона элемента. Оно позволяет задать цвет фона, изображение фона, его повторение, позицию и прикрепление.</p>
<p><strong>Отдельные свойства фона:</strong></p>
<ul>
<li><code>background-color</code>: Цвет фона.</li>
<li><code>background-image</code>: Изображение фона (URL).</li>
<li><code>background-repeat</code>: Повторение изображения (<code>no-repeat</code>, <code>repeat-x</code>, <code>repeat-y</code>, <code>repeat</code>).</li>
<li><code>background-position</code>: Позиция изображения (<code>top</code>, <code>center</code>, <code>bottom</code>, <code>left</code>, <code>right</code>, или значения в <code>px</code>, <code>%</code>).</li>
<li><code>background-size</code>: Размер изображения (<code>auto</code>, <code>cover</code>, <code>contain</code>, или значения в <code>px</code>, <code>%</code>).</li>
<li><code>background-attachment</code>: Прикрепление изображения (<code>scroll</code>, <code>fixed</code>, <code>local</code>).</li>
</ul>
<p><strong>Примеры использования <code>background</code>:</strong></p>
<p>```css
body {
    background-color: #f4f4f4; /<em> Светло-серый фон </em>/
}</p>
<p>.hero-section {
    background-image: url("../images/hero-bg.jpg"); /<em> Фоновое изображение </em>/
    background-repeat: no-repeat; /<em> Не повторять изображение </em>/
    background-position: center center; /<em> Центрировать изображение </em>/
    background-size: cover; /<em> Растянуть изображение, чтобы оно покрывало всю область </em>/
    height: 400px;
}</p>
<p>/<em> Сокращенная запись </em>/
.card {
    background: #fff url("../icons/icon.png") no-repeat top right / 50px 50px;
    padding: 20px;
    border-radius: 8px;
}
```</p>
<h3>Внешние отступы: <code>margin</code></h3>
<p>Свойство <code>margin</code> используется для создания внешнего пространства вокруг элемента, отделяя его от других элементов. Отступы не являются частью элемента и не имеют фонового цвета.</p>
<p><strong>Свойства <code>margin</code>:</strong></p>
<ul>
<li><code>margin-top</code>: Отступ сверху.</li>
<li><code>margin-right</code>: Отступ справа.</li>
<li><code>margin-bottom</code>: Отступ снизу.</li>
<li><code>margin-left</code>: Отступ слева.</li>
</ul>
<p><strong>Сокращенная запись <code>margin</code>:</strong></p>
<ul>
<li><code>margin: 20px;</code> (все стороны: 20px)</li>
<li><code>margin: 10px 20px;</code> (сверху/снизу: 10px, слева/справа: 20px)</li>
<li><code>margin: 10px 20px 30px;</code> (сверху: 10px, слева/справа: 20px, снизу: 30px)</li>
<li><code>margin: 10px 20px 30px 40px;</code> (сверху: 10px, справа: 20px, снизу: 30px, слева: 40px - по часовой стрелке)</li>
</ul>
<p><strong>Автоматические отступы:</strong></p>
<ul>
<li><code>margin: auto;</code> часто используется для горизонтального центрирования блочных элементов с заданной шириной.</li>
</ul>
<p>```css
div {
    margin-top: 30px;
    margin-bottom: 15px;
    margin-left: 10px;
    margin-right: 10px;
}</p>
<p>.container {
    width: 80%;
    margin: 0 auto; /<em> Центрирование по горизонтали </em>/
    padding: 20px;
    border: 1px solid #ccc;
}</p>
<p>p {
    margin: 1em 0; /<em> 1em сверху и снизу, 0 слева и справа </em>/
}
```</p>
<h3>Внутренние отступы: <code>padding</code></h3>
<p>Свойство <code>padding</code> используется для создания внутреннего пространства внутри элемента, между его содержимым и границей (border). Внутренние отступы имеют тот же фоновый цвет, что и сам элемент.</p>
<p><strong>Свойства <code>padding</code>:</strong></p>
<ul>
<li><code>padding-top</code>: Внутренний отступ сверху.</li>
<li><code>padding-right</code>: Внутренний отступ справа.</li>
<li><code>padding-bottom</code>: Внутренний отступ снизу.</li>
<li><code>padding-left</code>: Внутренний отступ слева.</li>
</ul>
<p><strong>Сокращенная запись <code>padding</code>:</strong></p>
<p>Аналогично <code>margin</code>:</p>
<ul>
<li><code>padding: 20px;</code> (все стороны: 20px)</li>
<li><code>padding: 10px 20px;</code> (сверху/снизу: 10px, слева/справа: 20px)</li>
<li><code>padding: 10px 20px 30px;</code> (сверху: 10px, слева/справа: 20px, снизу: 30px)</li>
<li><code>padding: 10px 20px 30px 40px;</code> (сверху: 10px, справа: 20px, снизу: 30px, слева: 40px - по часовой стрелке)</li>
</ul>
<p>```css
.button {
    padding: 10px 20px; /<em> 10px сверху/снизу, 20px слева/справа </em>/
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
}</p>
<p>.box {
    padding: 25px;
    background-color: lightgreen;
    border: 1px solid green;
}
```</p>
<p>Правильное использование этих базовых свойств является фундаментом для создания привлекательного и хорошо структурированного дизайна веб-страниц. Понимание разницы между <code>margin</code> и <code>padding</code> критически важно для работы с блочной моделью CSS.</p>
<hr />
<h2>3.4. Блочная модель: <code>display</code>, <code>box-sizing</code></h2>
<p>Каждый элемент в HTML рассматривается браузером как прямоугольный блок. Это концепция известна как <strong>блочная модель CSS (CSS Box Model)</strong>. Она описывает, как элементы отображаются на странице, включая их содержимое, внутренние отступы (padding), границы (border) и внешние отступы (margin).</p>
<p>Понимание блочной модели критически важно для правильного расположения и стилизации элементов на веб-странице.</p>
<h3>Компоненты блочной модели:</h3>
<ol>
<li><strong>Content (Содержимое):</strong> Фактическое содержимое элемента, такое как текст, изображения или видео. Размер содержимого определяется свойствами <code>width</code> и <code>height</code>.</li>
<li><strong>Padding (Внутренний отступ):</strong> Пространство между содержимым элемента и его границей. <code>padding</code> увеличивает общий размер элемента. Цвет фона элемента распространяется на область padding.</li>
<li><strong>Border (Граница):</strong> Линия, которая окружает padding и содержимое. Граница имеет свойства <code>border-width</code>, <code>border-style</code> и <code>border-color</code>.</li>
<li><strong>Margin (Внешний отступ):</strong> Пространство вокруг границы элемента, отделяющее его от других элементов. <code>margin</code> не имеет фонового цвета и не является частью элемента с точки зрения его размеров.</li>
</ol>
<p><code>+-----------------------------------+
|              Margin               |
|  +-----------------------------+  |
|  |           Border            |  |
|  |  +-----------------------+  |  |
|  |  |        Padding        |  |  |
|  |  |  +-----------------+  |  |  |
|  |  |  |     Content     |  |  |  |
|  |  |  +-----------------+  |  |  |
|  |  |                       |  |  |
|  |  +-----------------------+  |  |
|  |                             |  |
|  +-----------------------------+  |
|                                   |
+-----------------------------------+</code></p>
<h3>Свойство <code>display</code></h3>
<p>Свойство <code>display</code> определяет, как элемент будет отображаться в документе, то есть как он будет вести себя в контексте блочной модели и как он будет взаимодействовать с другими элементами. Наиболее распространенные значения:</p>
<ul>
<li>
<p><strong><code>block</code> (блочный элемент):</strong></p>
<ul>
<li>Занимает всю доступную ширину, начиная с новой строки.</li>
<li>Высота и ширина могут быть заданы (<code>width</code>, <code>height</code>).</li>
<li><code>margin</code>, <code>padding</code>, <code>border</code> применяются со всех сторон.</li>
<li>Примеры: <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;li&gt;</code>, <code>&lt;form&gt;</code>.</li>
</ul>
<p><code>css
div {
    display: block;
    width: 200px;
    height: 100px;
    background-color: lightcoral;
    margin: 10px;
}</code></p>
</li>
<li>
<p><strong><code>inline</code> (строчный элемент):</strong></p>
<ul>
<li>Занимает только столько ширины, сколько необходимо для его содержимого.</li>
<li>Не начинает новую строку.</li>
<li>Свойства <code>width</code> и <code>height</code> <strong>не применяются</strong>.</li>
<li><code>margin-top</code> и <code>margin-bottom</code> <strong>не применяются</strong>; <code>padding-top</code> и <code>padding-bottom</code> применяются, но не влияют на расположение соседних элементов.</li>
<li>Примеры: <code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code>, <code>&lt;img&gt;</code>.</li>
</ul>
<p><code>css
span {
    display: inline;
    background-color: lightblue;
    padding: 5px;
    margin: 5px; /* Только горизонтальные отступы будут видны */
}</code></p>
</li>
<li>
<p><strong><code>inline-block</code> (строчно-блочный элемент):</strong></p>
<ul>
<li>Ведет себя как строчный элемент (не начинает новую строку), но при этом позволяет задавать <code>width</code>, <code>height</code>, <code>margin</code> и <code>padding</code> со всех сторон, как блочный элемент.</li>
<li>Полезен для создания элементов, которые должны быть в одной строке, но при этом иметь блочные свойства (например, кнопки навигации, карточки товаров).</li>
</ul>
<p><code>css
.button-inline {
    display: inline-block;
    width: 150px;
    padding: 10px 20px;
    margin: 5px;
    background-color: lightgreen;
    text-align: center;
}</code></p>
</li>
<li>
<p><strong><code>none</code>:</strong> Полностью скрывает элемент, удаляя его из потока документа. Элемент не занимает места и не влияет на макет.</p>
<p><code>css
.hidden {
    display: none;
}</code></p>
</li>
</ul>
<h3>Свойство <code>box-sizing</code></h3>
<p>По умолчанию, когда вы задаете <code>width</code> и <code>height</code> для элемента, эти значения применяются только к области содержимого (content box). <code>padding</code> и <code>border</code> добавляются к этим размерам, увеличивая общий размер элемента. Это может быть неочевидно и приводить к проблемам с расчетом макета.</p>
<p>Свойство <code>box-sizing</code> позволяет изменить это поведение.</p>
<ul>
<li>
<p><strong><code>content-box</code> (по умолчанию):</strong></p>
<ul>
<li><code>width</code> и <code>height</code> включают только содержимое.</li>
<li><code>padding</code> и <code>border</code> добавляются к общей ширине и высоте элемента.</li>
<li>Пример: Если <code>width: 100px</code>, <code>padding: 10px</code>, <code>border: 1px</code>, то фактическая ширина элемента будет <code>100px + 2*10px (padding) + 2*1px (border) = 122px</code>.</li>
</ul>
</li>
<li>
<p><strong><code>border-box</code>:</strong></p>
<ul>
<li><code>width</code> и <code>height</code> включают содержимое, padding и border.</li>
<li><code>padding</code> и <code>border</code> не увеличивают общий размер элемента; они </li>
</ul>
</li>
</ul>
<p>«съедают» место из области содержимого.
    *   Пример: Если <code>width: 100px</code>, <code>padding: 10px</code>, <code>border: 1px</code>, то фактическая ширина элемента будет <code>100px</code>. Содержимое займет <code>100px - 2*10px (padding) - 2*1px (border) = 78px</code>.</p>
<p><code>border-box</code> значительно упрощает расчеты макета, так как заданная ширина и высота элемента всегда соответствуют его фактическим размерам на странице. Поэтому <code>border-box</code> является предпочтительным значением для большинства современных веб-разработок.</p>
<p><strong>Рекомендуемая практика:</strong></p>
<p>Часто в начале CSS-файла можно увидеть следующее правило, которое устанавливает <code>box-sizing: border-box</code> для всех элементов на странице, включая псевдоэлементы <code>::before</code> и <code>::after</code>:</p>
<p><code>css
*,
*::before,
*::after {
    box-sizing: border-box;
}</code></p>
<p>Это правило гарантирует, что все элементы будут вести себя предсказуемо с точки зрения размеров, что значительно упрощает верстку и предотвращает многие распространенные проблемы с макетом.</p>
<h2>3.5. Работа с цветом и шрифтами</h2>
<h3>Работа с цветом</h3>
<p>Как уже упоминалось в разделе о свойстве <code>color</code>, цвета в CSS могут быть заданы различными способами. Понимание этих форматов и их применение является ключевым для создания визуально привлекательных веб-страниц.</p>
<p><strong>1. Имена цветов:</strong>
Самый простой способ, но ограниченный. Существует около 140 предопределенных имен цветов (например, <code>red</code>, <code>blue</code>, <code>green</code>, <code>white</code>, <code>black</code>, <code>tomato</code>, <code>DodgerBlue</code>, <code>MediumSeaGreen</code>).</p>
<p><code>css
h1 {
    color: tomato;
}
body {
    background-color: DodgerBlue;
}</code></p>
<p><strong>2. HEX-коды (шестнадцатеричные):</strong>
Наиболее распространенный формат. Представляют собой 6-значное шестнадцатеричное число, предваряемое символом <code>#</code>. Каждая пара цифр (00-FF) представляет собой значение для красного, зеленого и синего каналов соответственно.</p>
<ul>
<li><code>#RRGGBB</code><ul>
<li><code>RR</code>: Красный (Red) от 00 до FF</li>
<li><code>GG</code>: Зеленый (Green) от 00 до FF</li>
<li><code>BB</code>: Синий (Blue) от 00 до FF</li>
</ul>
</li>
</ul>
<p>Примеры:
*   <code>#FF0000</code> - Красный
*   <code>#00FF00</code> - Зеленый
*   <code>#0000FF</code> - Синий
*   <code>#FFFFFF</code> - Белый
*   <code>#000000</code> - Черный</p>
<p>Сокращенная запись для повторяющихся пар: <code>#RGB</code> (например, <code>#F00</code> для <code>#FF0000</code>).</p>
<p><code>css
p {
    color: #336699; /* Темно-синий */
}
.header {
    background-color: #F0F; /* Пурпурный (сокращенная запись для #FF00FF) */
}</code></p>
<p><strong>3. RGB/RGBA (Red, Green, Blue, Alpha):</strong>
Функция <code>rgb()</code> принимает три значения (от 0 до 255) для красного, зеленого и синего. <code>rgba()</code> добавляет четвертое значение — альфа-канал (прозрачность), от 0 (полностью прозрачный) до 1 (полностью непрозрачный).</p>
<p><code>css
.box {
    background-color: rgb(255, 99, 71); /* Томатный */
}
.overlay {
    background-color: rgba(0, 0, 0, 0.5); /* Полупрозрачный черный */
}</code></p>
<p><strong>4. HSL/HSLA (Hue, Saturation, Lightness, Alpha):</strong>
Представляет цвет в терминах оттенка, насыщенности и светлоты. Более интуитивен для человеческого восприятия цвета.</p>
<ul>
<li><code>Hue</code> (оттенок): Градусы на цветовом круге (0-360). 0 (или 360) - красный, 120 - зеленый, 240 - синий.</li>
<li><code>Saturation</code> (насыщенность): Процент от 0% (оттенки серого) до 100% (полностью насыщенный цвет).</li>
<li><code>Lightness</code> (светлота): Процент от 0% (черный) до 100% (белый).</li>
</ul>
<p><code>css
.element {
    background-color: hsl(120, 100%, 50%); /* Чистый зеленый */
}
.faded-element {
    background-color: hsla(240, 100%, 50%, 0.3); /* Полупрозрачный синий */
}</code></p>
<h3>Работа со шрифтами</h3>
<p>Шрифты играют огромную роль в дизайне веб-сайта. CSS предоставляет множество свойств для управления типографикой.</p>
<p><strong>1. Семейство шрифтов: <code>font-family</code></strong></p>
<p>Определяет шрифт, который будет использоваться для текста. Можно указать несколько шрифтов через запятую; браузер будет использовать первый доступный шрифт из списка. В конце списка всегда рекомендуется указывать общее семейство шрифтов (generic family) на случай, если ни один из указанных шрифтов не будет доступен.</p>
<p>Общие семейства шрифтов:
*   <code>serif</code> (с засечками: Times New Roman, Georgia)
*   <code>sans-serif</code> (без засечек: Arial, Helvetica, Verdana)
*   <code>monospace</code> (моноширинные: Courier New, Consolas)
*   <code>cursive</code> (рукописные)
*   <code>fantasy</code> (декоративные)</p>
<p><code>css
body {
    font-family: Arial, Helvetica, sans-serif;
}
h1 {
    font-family: "Times New Roman", serif;
}
.code {
    font-family: "Courier New", monospace;
}</code></p>
<p><strong>2. Размер шрифта: <code>font-size</code></strong></p>
<p>Уже рассмотрено в разделе 3.3. Напомним, что рекомендуется использовать относительные единицы (<code>em</code>, <code>rem</code>, <code>vw</code>) для лучшей адаптивности.</p>
<p><strong>3. Вес шрифта (жирность): <code>font-weight</code></strong></p>
<p>Определяет жирность шрифта. Значения могут быть ключевыми словами (<code>normal</code>, <code>bold</code>, <code>bolder</code>, <code>lighter</code>) или числовыми значениями (100-900, где 400 - <code>normal</code>, 700 - <code>bold</code>).</p>
<p><code>css
p {
    font-weight: normal;
}
strong {
    font-weight: bold;
}
.thin-text {
    font-weight: 300;
}</code></p>
<p><strong>4. Стиль шрифта: <code>font-style</code></strong></p>
<p>Определяет стиль шрифта. Значения: <code>normal</code>, <code>italic</code> (курсив), <code>oblique</code> (наклонный).</p>
<p><code>css
em {
    font-style: italic;
}</code></p>
<p><strong>5. Высота строки: <code>line-height</code></strong></p>
<p>Устанавливает высоту каждой строки текста. Может быть задана в пикселях, <code>em</code>, <code>rem</code> или безразмерным числом (рекомендуется, так как это значение является множителем текущего <code>font-size</code>).</p>
<p><code>css
p {
    line-height: 1.5; /* Высота строки в 1.5 раза больше размера шрифта */
}</code></p>
<p><strong>6. Выравнивание текста: <code>text-align</code></strong></p>
<p>Выравнивает текст внутри элемента. Значения: <code>left</code>, <code>right</code>, <code>center</code>, <code>justify</code> (выравнивание по ширине).</p>
<p><code>css
h1 {
    text-align: center;
}
.article-text {
    text-align: justify;
}</code></p>
<p><strong>7. Декорации текста: <code>text-decoration</code></strong></p>
<p>Добавляет или удаляет декоративные линии. Значения: <code>none</code> (убирает подчеркивание у ссылок), <code>underline</code> (подчеркивание), <code>overline</code> (надчеркивание), <code>line-through</code> (зачеркивание).</p>
<p><code>css
a {
    text-decoration: none; /* Убрать подчеркивание у ссылок */
}
.strike {
    text-decoration: line-through;
}</code></p>
<h3>Использование Google Fonts</h3>
<p>Для использования красивых и разнообразных шрифтов, которые не всегда установлены на компьютере пользователя, часто используются веб-шрифты. Google Fonts — это популярный сервис, предоставляющий бесплатные веб-шрифты.</p>
<p><strong>Как использовать Google Fonts:</strong></p>
<ol>
<li>Перейдите на сайт <a href="https://fonts.google.com/">Google Fonts</a>.</li>
<li>Выберите нужные шрифты и их начертания (например, Regular 400, Bold 700).</li>
<li>
<p>Google Fonts предоставит вам <code>&lt;link&gt;</code> тег для вставки в <code>&lt;head&gt;</code> вашего HTML-документа или <code>@import</code> правило для CSS.</p>
<p><strong>Пример <code>&lt;link&gt;</code>:</strong>
<code>html
&lt;head&gt;
    &lt;link rel="preconnect" href="https://fonts.googleapis.com"&gt;
    &lt;link rel="preconnect" href="https://fonts.gstatic.com" crossorigin&gt;
    &lt;link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&amp;display=swap" rel="stylesheet"&gt;
&lt;/head&gt;</code></p>
</li>
<li>
<p>После подключения шрифта, вы можете использовать его в своем CSS с помощью свойства <code>font-family</code>:</p>
<p><code>css
body {
    font-family: 'Roboto', sans-serif;
}</code></p>
</li>
</ol>
<p>Использование веб-шрифтов позволяет создавать более уникальный и профессиональный дизайн, обеспечивая при этом единообразное отображение шрифтов для всех пользователей.</p>
<hr />
<h2>3.6. Стилизация ссылок и изображений</h2>
<p>Ссылки и изображения являются одними из наиболее часто используемых элементов на веб-страницах. CSS предоставляет широкие возможности для их стилизации, позволяя создавать уникальный и привлекательный дизайн.</p>
<h3>Стилизация ссылок (<code>&lt;a&gt;</code>)</h3>
<p>Ссылки по умолчанию имеют синий цвет и подчеркивание. При посещении они становятся фиолетовыми. CSS позволяет полностью изменить их внешний вид, а также добавить интерактивные эффекты при наведении или клике.</p>
<p><strong>Основные псевдоклассы для ссылок:</strong></p>
<ul>
<li><code>:link</code>: Стили для непосещенных ссылок.</li>
<li><code>:visited</code>: Стили для посещенных ссылок.</li>
<li><code>:hover</code>: Стили при наведении курсора мыши на ссылку.</li>
<li><code>:active</code>: Стили при активации ссылки (момент клика).</li>
<li><code>:focus</code>: Стили при получении ссылкой фокуса (например, при навигации с клавиатуры).</li>
</ul>
<p><strong>Рекомендуемый порядок применения псевдоклассов (LVHA-порядок):</strong></p>
<p>Для корректного отображения стилей важно соблюдать следующий порядок:</p>
<ol>
<li><code>:link</code></li>
<li><code>:visited</code></li>
<li><code>:focus</code></li>
<li><code>:hover</code></li>
<li><code>:active</code></li>
</ol>
<p>```css
/<em> Базовые стили для всех ссылок </em>/
a {
    color: #007bff; /<em> Синий цвет текста </em>/
    text-decoration: none; /<em> Убрать подчеркивание по умолчанию </em>/
    transition: color 0.3s ease; /<em> Плавный переход цвета при наведении </em>/
}</p>
<p>/<em> Стили для посещенных ссылок </em>/
a:visited {
    color: #6610f2; /<em> Фиолетовый для посещенных </em>/
}</p>
<p>/<em> Стили при фокусе (для доступности) </em>/
a:focus {
    outline: 2px solid #0056b3; /<em> Обводка при фокусе </em>/
}</p>
<p>/<em> Стили при наведении </em>/
a:hover {
    color: #0056b3; /<em> Темно-синий при наведении </em>/
    text-decoration: underline; /<em> Добавить подчеркивание при наведении </em>/
}</p>
<p>/<em> Стили при активном состоянии (клике) </em>/
a:active {
    color: #003d7a; /<em> Еще темнее при клике </em>/
}</p>
<p>/<em> Пример стилизации кнопки-ссылки </em>/
.button-link {
    display: inline-block;
    padding: 10px 20px;
    background-color: #28a745; /<em> Зеленый фон </em>/
    color: white; /<em> Белый текст </em>/
    border-radius: 5px;
    text-align: center;
    font-weight: bold;
    text-decoration: none;
    transition: background-color 0.3s ease;
}</p>
<p>.button-link:hover {
    background-color: #218838; /<em> Темнее зеленый при наведении </em>/
}
```</p>
<p><strong>Важные свойства для стилизации ссылок:</strong></p>
<ul>
<li><code>color</code>: Цвет текста ссылки.</li>
<li><code>text-decoration</code>: Управляет подчеркиванием, надчеркиванием, зачеркиванием. <code>none</code> часто используется для удаления стандартного подчеркивания.</li>
<li><code>background-color</code>: Цвет фона ссылки (особенно полезно для кнопок-ссылок).</li>
<li><code>padding</code>, <code>margin</code>, <code>border</code>: Для создания отступов и границ, превращая ссылку в блочный элемент или кнопку.</li>
<li><code>font-family</code>, <code>font-size</code>, <code>font-weight</code>: Для изменения шрифтовых характеристик.</li>
<li><code>transition</code>: Для создания плавных анимаций при изменении состояния (например, при наведении).</li>
</ul>
<h3>Стилизация изображений (<code>&lt;img&gt;</code>)</h3>
<p>Изображения также можно стилизовать с помощью CSS, чтобы они лучше вписывались в дизайн страницы, были адаптивными и имели различные эффекты.</p>
<p><strong>Основные свойства для стилизации изображений:</strong></p>
<ul>
<li>
<p><code>width</code> и <code>height</code>: Установка размеров изображения. <strong>Рекомендуется использовать относительные единицы или <code>max-width: 100%</code> для адаптивности.</strong></p>
<p><code>css
img {
    max-width: 100%; /* Изображение не будет выходить за пределы родительского контейнера */
    height: auto; /* Сохранять пропорции */
    display: block; /* Убрать лишний пробел под изображением */
}</code></p>
</li>
<li>
<p><code>border</code>: Добавление рамки вокруг изображения.</p>
<p><code>css
img {
    border: 2px solid #ccc;
    border-radius: 5px; /* Скругленные углы */
}</code></p>
</li>
<li>
<p><code>border-radius</code>: Скругление углов изображения. Значение <code>50%</code> превратит квадратное изображение в круг.</p>
<p><code>css
.avatar {
    border-radius: 50%;
    width: 100px;
    height: 100px;
    object-fit: cover; /* Обрезка изображения, чтобы оно полностью заполнило круг */
}</code></p>
</li>
<li>
<p><code>margin</code> и <code>padding</code>: Отступы вокруг и внутри изображения.</p>
<p><code>css
img {
    margin-bottom: 15px;
}</code></p>
</li>
<li>
<p><code>box-shadow</code>: Добавление тени к изображению.</p>
<p><code>css
img {
    box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.2);
}</code></p>
</li>
<li>
<p><code>opacity</code>: Установка прозрачности изображения (от 0 до 1).</p>
<p><code>css
img:hover {
    opacity: 0.8;
}</code></p>
</li>
<li>
<p><code>filter</code>: Применение различных графических эффектов (например, <code>grayscale</code>, <code>blur</code>, <code>sepia</code>).</p>
<p><code>css
img.grayscale {
    filter: grayscale(100%);
}
img.grayscale:hover {
    filter: grayscale(0%);
}</code></p>
</li>
<li>
<p><code>object-fit</code>: Определяет, как содержимое <code>&lt;img&gt;</code> или <code>&lt;video&gt;</code> должно подгоняться под контейнер. Полезно при использовании <code>width</code> и <code>height</code> для изображений, чтобы избежать искажений.</p>
<ul>
<li><code>fill</code>: Изображение заполняет весь контейнер, возможно, искажая пропорции.</li>
<li><code>contain</code>: Изображение масштабируется так, чтобы полностью поместиться в контейнер, сохраняя пропорции. Могут появиться пустые области (letterboxing).</li>
<li><code>cover</code>: Изображение масштабируется так, чтобы полностью покрыть контейнер, сохраняя пропорции. Части изображения могут быть обрезаны.</li>
<li><code>none</code>: Изображение не масштабируется.</li>
<li><code>scale-down</code>: Изображение масштабируется до наименьшего размера из <code>none</code> или <code>contain</code>.</li>
</ul>
<p><code>css
.image-container {
    width: 200px;
    height: 200px;
    overflow: hidden;
}
.image-container img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}</code></p>
</li>
</ul>
<p>Правильная стилизация ссылок и изображений не только улучшает внешний вид веб-страницы, но и повышает ее удобство использования и доступность. Использование адаптивных подходов (например, <code>max-width: 100%</code> для изображений) является ключевым для создания современных веб-сайтов.</p>
<hr />
<h2>3.7. Основы Flexbox для создания макетов</h2>
<p>Flexbox (Flexible Box Layout Module) — это одномерный модуль макета CSS, который позволяет эффективно распределять пространство между элементами в контейнере и выравнивать их. Он предназначен для управления расположением элементов в одном измерении (либо по горизонтали, либо по вертикали). Flexbox идеально подходит для создания навигационных меню, выравнивания элементов в шапке сайта, распределения элементов в карточках и других задач, где требуется гибкое выравнивание по одной оси.</p>
<h3>Основные концепции Flexbox</h3>
<p>Flexbox работает на основе двух основных типов элементов:</p>
<ol>
<li><strong>Flex-контейнер (Flex Container):</strong> Родительский элемент, к которому применяется свойство <code>display: flex</code> или <code>display: inline-flex</code>. Он становится контейнером для гибких элементов.</li>
<li><strong>Flex-элементы (Flex Items):</strong> Дочерние элементы flex-контейнера. Они автоматически становятся гибкими элементами и их расположением можно управлять с помощью свойств flex-контейнера или свойств самих flex-элементов.</li>
</ol>
<h3>Свойства Flex-контейнера</h3>
<p>Эти свойства применяются к родительскому элементу (flex-контейнеру) и определяют, как его дочерние элементы (flex-элементы) будут располагаться внутри него.</p>
<ol>
<li>
<p><strong><code>display: flex | inline-flex</code></strong></p>
<ul>
<li><code>flex</code>: Создает блочный flex-контейнер.</li>
<li><code>inline-flex</code>: Создает строчно-блочный flex-контейнер.</li>
</ul>
<p><code>css
.container {
    display: flex;
}</code></p>
</li>
<li>
<p><strong><code>flex-direction</code></strong>
    Определяет основную ось, по которой будут располагаться flex-элементы, и направление их размещения.</p>
<ul>
<li><code>row</code> (по умолчанию): Элементы располагаются слева направо (в LTR языках).</li>
<li><code>row-reverse</code>: Элементы располагаются справа налево.</li>
<li><code>column</code>: Элементы располагаются сверху вниз.</li>
<li><code>column-reverse</code>: Элементы располагаются снизу вверх.</li>
</ul>
<p><code>css
.navbar {
    display: flex;
    flex-direction: row; /* Элементы меню будут идти горизонтально */
}
.sidebar {
    display: flex;
    flex-direction: column; /* Элементы сайдбара будут идти вертикально */
}</code></p>
</li>
<li>
<p><strong><code>justify-content</code></strong>
    Выравнивает flex-элементы вдоль основной оси (main axis). Распределяет свободное пространство между элементами или вокруг них.</p>
<ul>
<li><code>flex-start</code> (по умолчанию): Элементы прижимаются к началу основной оси.</li>
<li><code>flex-end</code>: Элементы прижимаются к концу основной оси.</li>
<li><code>center</code>: Элементы центрируются вдоль основной оси.</li>
<li><code>space-between</code>: Элементы равномерно распределяются по основной оси; первый элемент прижимается к началу, последний — к концу.</li>
<li><code>space-around</code>: Элементы равномерно распределяются по основной оси с равным пространством вокруг них (пространство по краям вдвое меньше, чем между элементами).</li>
<li><code>space-evenly</code>: Элементы равномерно распределяются по основной оси с равным пространством между ними и по краям.</li>
</ul>
<p><code>css
.header {
    display: flex;
    justify-content: space-between; /* Логотип слева, навигация справа */
}
.buttons {
    display: flex;
    justify-content: center; /* Кнопки по центру */
}</code></p>
</li>
<li>
<p><strong><code>align-items</code></strong>
    Выравнивает flex-элементы вдоль поперечной оси (cross axis). Поперечная ось перпендикулярна основной оси (если <code>flex-direction: row</code>, то поперечная ось вертикальная; если <code>flex-direction: column</code>, то поперечная ось горизонтальная).</p>
<ul>
<li><code>stretch</code> (по умолчанию): Элементы растягиваются, чтобы заполнить контейнер по поперечной оси (если не задана фиксированная высота/ширина).</li>
<li><code>flex-start</code>: Элементы прижимаются к началу поперечной оси.</li>
<li><code>flex-end</code>: Элементы прижимаются к концу поперечной оси.</li>
<li><code>center</code>: Элементы центрируются вдоль поперечной оси.</li>
<li><code>baseline</code>: Элементы выравниваются по их базовой линии.</li>
</ul>
<p><code>css
.card-footer {
    display: flex;
    align-items: center; /* Элементы в футере карточки выравниваются по центру по вертикали */
}</code></p>
</li>
<li>
<p><strong><code>flex-wrap</code></strong>
    Определяет, будут ли flex-элементы переноситься на новую строку, если они не помещаются в одну строку.</p>
<ul>
<li><code>nowrap</code> (по умолчанию): Все элементы остаются в одной строке, возможно, выходя за пределы контейнера.</li>
<li><code>wrap</code>: Элементы переносятся на новую строку, если не хватает места.</li>
<li><code>wrap-reverse</code>: Элементы переносятся на новую строку в обратном порядке.</li>
</ul>
<p><code>css
.tags-container {
    display: flex;
    flex-wrap: wrap; /* Теги будут переноситься на новую строку */
}</code></p>
</li>
<li>
<p><strong><code>align-content</code></strong>
    Выравнивает строки flex-элементов (когда <code>flex-wrap: wrap</code>) вдоль поперечной оси. Работает аналогично <code>justify-content</code>, но для строк, а не для отдельных элементов.</p>
<ul>
<li><code>stretch</code> (по умолчанию), <code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>space-between</code>, <code>space-around</code>.</li>
</ul>
<p><code>css
.gallery {
    display: flex;
    flex-wrap: wrap;
    height: 500px; /* Для демонстрации align-content нужна фиксированная высота */
    align-content: space-around; /* Распределить пространство между строками */
}</code></p>
</li>
</ol>
<h3>Свойства Flex-элементов</h3>
<p>Эти свойства применяются к дочерним элементам flex-контейнера и определяют, как они будут вести себя внутри него.</p>
<ol>
<li><strong><code>flex-grow</code></strong>
    Определяет, насколько flex-элемент может </li>
</ol>
<p>расти, если в контейнере есть свободное пространство. Принимает безразмерное число (по умолчанию 0).
    *   Если все элементы имеют <code>flex-grow: 1</code>, они будут расти равномерно.
    *   Если один элемент имеет <code>flex-grow: 2</code>, а остальные <code>flex-grow: 1</code>, то первый элемент будет занимать в два раза больше свободного пространства, чем остальные.</p>
<pre><code>```css
.item {
    flex-grow: 1;
}
.item-double {
    flex-grow: 2;
}
```
</code></pre>
<ol>
<li>
<p><strong><code>flex-shrink</code></strong>
    Определяет, насколько flex-элемент может сжиматься, если в контейнере недостаточно места. Принимает безразмерное число (по умолчанию 1).</p>
<ul>
<li><code>flex-shrink: 0</code> предотвращает сжатие элемента.</li>
</ul>
<p><code>css
.item {
    flex-shrink: 1;
}
.item-no-shrink {
    flex-shrink: 0;
}</code></p>
</li>
<li>
<p><strong><code>flex-basis</code></strong>
    Определяет начальный размер flex-элемента до того, как свободное пространство будет распределено. Может быть задан в пикселях, процентах или <code>auto</code> (по умолчанию, размер определяется содержимым).</p>
<p><code>css
.item {
    flex-basis: 100px;
}
.item-half {
    flex-basis: 50%;
}</code></p>
</li>
<li>
<p><strong><code>flex</code> (сокращенное свойство)</strong>
    Сокращенное свойство для <code>flex-grow</code>, <code>flex-shrink</code> и <code>flex-basis</code>.</p>
<ul>
<li><code>flex: 1</code> эквивалентно <code>flex: 1 1 0%</code> (растет, сжимается, начальный размер 0).</li>
<li><code>flex: auto</code> эквивалентно <code>flex: 1 1 auto</code>.</li>
<li><code>flex: none</code> эквивалентно <code>flex: 0 0 auto</code> (не растет, не сжимается).</li>
</ul>
<p><code>css
.item {
    flex: 1;
}
.item-fixed {
    flex: 0 0 200px; /* Не растет, не сжимается, ширина 200px */
}</code></p>
</li>
<li>
<p><strong><code>order</code></strong>
    Определяет порядок отображения flex-элементов внутри контейнера. Принимает целое число (по умолчанию 0). Элементы с меньшим значением <code>order</code> отображаются раньше.</p>
<p><code>css
.item-first {
    order: -1;
}
.item-last {
    order: 1;
}</code></p>
</li>
<li>
<p><strong><code>align-self</code></strong>
    Переопределяет значение <code>align-items</code> для отдельного flex-элемента. Принимает те же значения, что и <code>align-items</code>.</p>
<p><code>css
.item-center {
    align-self: center;
}</code></p>
</li>
</ol>
<h3>Пример использования Flexbox</h3>
<p>Рассмотрим создание простого навигационного меню с использованием Flexbox.</p>
<p><strong>HTML:</strong></p>
<p>```html</p>
<nav class="navbar">
    <a href="#" class="logo">Логотип</a>
    <ul class="nav-links">
        <li><a href="#">Главная</a></li>
        <li><a href="#">О нас</a></li>
        <li><a href="#">Услуги</a></li>
        <li><a href="#">Контакты</a></li>
    </ul>
</nav>
<p>```</p>
<p><strong>CSS:</strong></p>
<p>```css
.navbar {
    display: flex; /<em> Делаем контейнер гибким </em>/
    justify-content: space-between; /<em> Распределяем элементы по краям </em>/
    align-items: center; /<em> Выравниваем по центру по вертикали </em>/
    background-color: #333;
    padding: 10px 20px;
    color: white;
}</p>
<p>.logo {
    font-size: 24px;
    font-weight: bold;
    color: white;
    text-decoration: none;
}</p>
<p>.nav-links {
    list-style: none; /<em> Убираем маркеры списка </em>/
    margin: 0;
    padding: 0;
    display: flex; /<em> Делаем элементы списка гибкими </em>/
}</p>
<p>.nav-links li {
    margin-left: 20px; /<em> Отступ между элементами меню </em>/
}</p>
<p>.nav-links a {
    color: white;
    text-decoration: none;
    padding: 5px 10px;
    transition: background-color 0.3s ease;
}</p>
<p>.nav-links a:hover {
    background-color: #555;
    border-radius: 4px;
}
```</p>
<p>Flexbox является мощным инструментом для создания гибких и адаптивных макетов. Он значительно упрощает выравнивание и распределение элементов по сравнению с традиционными методами (например, float). Освоение Flexbox является ключевым навыком для современного веб-разработчика.</p>
<hr />
<h2>3.8. Основы Grid для создания макетов</h2>
<p>CSS Grid Layout (или просто Grid) — это двумерная система макетов CSS, которая позволяет создавать сложные, адаптивные макеты, управляя как строками, так и столбцами одновременно. В отличие от Flexbox, который является одномерным (работает либо по строкам, либо по столбцам), Grid позволяет точно позиционировать элементы в двух измерениях, что делает его идеальным для создания общей структуры страницы или сложных компонентов.</p>
<h3>Основные концепции Grid</h3>
<p>Grid также работает на основе двух основных типов элементов:</p>
<ol>
<li><strong>Grid-контейнер (Grid Container):</strong> Родительский элемент, к которому применяется свойство <code>display: grid</code> или <code>display: inline-grid</code>. Он становится контейнером для элементов сетки.</li>
<li><strong>Grid-элементы (Grid Items):</strong> Непосредственные дочерние элементы grid-контейнера. Они автоматически становятся элементами сетки и их расположением можно управлять с помощью свойств grid-контейнера или свойств самих grid-элементов.</li>
</ol>
<p>Grid-контейнер определяет сетку, состоящую из строк (rows) и столбцов (columns), разделенных линиями сетки (grid lines) и промежутками (gutters).</p>
<h3>Свойства Grid-контейнера</h3>
<p>Эти свойства применяются к родительскому элементу (grid-контейнеру) и определяют структуру сетки.</p>
<ol>
<li>
<p><strong><code>display: grid | inline-grid</code></strong></p>
<ul>
<li><code>grid</code>: Создает блочный grid-контейнер.</li>
<li><code>inline-grid</code>: Создает строчно-блочный grid-контейнер.</li>
</ul>
<p><code>css
.container {
    display: grid;
}</code></p>
</li>
<li>
<p><strong><code>grid-template-columns</code></strong>
    Определяет количество и ширину столбцов в сетке. Значения могут быть в <code>px</code>, <code>%</code>, <code>em</code>, <code>rem</code>, <code>fr</code> (fractional unit) или <code>auto</code>.</p>
<ul>
<li><code>fr</code>: Фракционная единица. <code>1fr</code> означает одну часть доступного пространства. Например, <code>1fr 2fr 1fr</code> создаст три столбца, где второй столбец будет в два раза шире первого и третьего.</li>
<li><code>auto</code>: Столбец автоматически подстраивается под содержимое.</li>
<li><code>repeat()</code>: Функция для повторения шаблона. <code>repeat(3, 1fr)</code> эквивалентно <code>1fr 1fr 1fr</code>.</li>
<li><code>minmax()</code>: Функция для установки минимального и максимального размера столбца/строки. <code>minmax(100px, 1fr)</code> означает, что столбец будет не менее 100px, но не более 1fr.</li>
</ul>
<p><code>css
.grid-layout {
    display: grid;
    grid-template-columns: 200px 1fr 1fr; /* Фиксированный, затем два равных */
    /* Или: grid-template-columns: repeat(3, 1fr); */
}</code></p>
</li>
<li>
<p><strong><code>grid-template-rows</code></strong>
    Определяет количество и высоту строк в сетке. Работает аналогично <code>grid-template-columns</code>.</p>
<p><code>css
.grid-layout {
    display: grid;
    grid-template-rows: auto 100px 1fr; /* Автоматическая высота, 100px, затем оставшееся */
}</code></p>
</li>
<li>
<p><strong><code>grid-gap</code> (или <code>gap</code>, <code>row-gap</code>, <code>column-gap</code>)</strong>
    Определяет промежутки (gutters) между строками и столбцами сетки.</p>
<ul>
<li><code>gap</code>: Сокращенное свойство для <code>row-gap</code> и <code>column-gap</code>.</li>
<li><code>row-gap</code>: Промежуток между строками.</li>
<li><code>column-gap</code>: Промежуток между столбцами.</li>
</ul>
<p><code>css
.grid-layout {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-gap: 20px; /* 20px между строками и столбцами */
    /* Или: row-gap: 15px; column-gap: 25px; */
}</code></p>
</li>
<li>
<p><strong><code>justify-items</code></strong>
    Выравнивает содержимое grid-элементов внутри их ячеек по горизонтали (вдоль оси строк).</p>
<ul>
<li><code>stretch</code> (по умолчанию): Растягивает содержимое для заполнения ячейки.</li>
<li><code>start</code>: Прижимает содержимое к началу ячейки.</li>
<li><code>end</code>: Прижимает содержимое к концу ячейки.</li>
<li><code>center</code>: Центрирует содержимое в ячейке.</li>
</ul>
<p><code>css
.grid-container {
    justify-items: center;
}</code></p>
</li>
<li>
<p><strong><code>align-items</code></strong>
    Выравнивает содержимое grid-элементов внутри их ячеек по вертикали (вдоль оси столбцов).</p>
<ul>
<li><code>stretch</code> (по умолчанию), <code>start</code>, <code>end</code>, <code>center</code>.</li>
</ul>
<p><code>css
.grid-container {
    align-items: center;
}</code></p>
</li>
<li>
<p><strong><code>justify-content</code></strong>
    Выравнивает всю сетку внутри grid-контейнера по горизонтали, если сетка не занимает всю доступную ширину.</p>
<ul>
<li><code>start</code>, <code>end</code>, <code>center</code>, <code>space-between</code>, <code>space-around</code>, <code>space-evenly</code>.</li>
</ul>
<p><code>css
.grid-container {
    justify-content: center;
}</code></p>
</li>
<li>
<p><strong><code>align-content</code></strong>
    Выравнивает всю сетку внутри grid-контейнера по вертикали, если сетка не занимает всю доступную высоту.</p>
<ul>
<li><code>start</code>, <code>end</code>, <code>center</code>, <code>space-between</code>, <code>space-around</code>, <code>space-evenly</code>.</li>
</ul>
<p><code>css
.grid-container {
    align-content: center;
}</code></p>
</li>
</ol>
<h3>Свойства Grid-элементов</h3>
<p>Эти свойства применяются к дочерним элементам grid-контейнера и определяют их расположение в сетке.</p>
<ol>
<li>
<p><strong><code>grid-column-start</code>, <code>grid-column-end</code>, <code>grid-row-start</code>, <code>grid-row-end</code></strong>
    Определяют, с какой линии сетки начинается и заканчивается элемент по столбцам и строкам. Можно использовать номера линий или имена линий (если они заданы).</p>
<p><code>css
.item-1 {
    grid-column-start: 1;
    grid-column-end: 3; /* Элемент займет 1-й и 2-й столбцы */
    /* Сокращенная запись: grid-column: 1 / 3; */
}
.item-2 {
    grid-row: 2 / span 2; /* Элемент начнется со 2-й строки и займет 2 строки */
}</code></p>
</li>
<li>
<p><strong><code>grid-area</code></strong>
    Сокращенное свойство для <code>grid-row-start</code>, <code>grid-column-start</code>, <code>grid-row-end</code>, <code>grid-column-end</code>.</p>
<p><code>css
.item-header {
    grid-area: 1 / 1 / 2 / 4; /* row-start / column-start / row-end / column-end */
}</code></p>
</li>
<li>
<p><strong><code>justify-self</code></strong>
    Выравнивает отдельный grid-элемент внутри его ячейки по горизонтали. Переопределяет <code>justify-items</code> для этого элемента.</p>
<ul>
<li><code>stretch</code> (по умолчанию), <code>start</code>, <code>end</code>, <code>center</code>.</li>
</ul>
<p><code>css
.item-button {
    justify-self: end;
}</code></p>
</li>
<li>
<p><strong><code>align-self</code></strong>
    Выравнивает отдельный grid-элемент внутри его ячейки по вертикали. Переопределяет <code>align-items</code> для этого элемента.</p>
<ul>
<li><code>stretch</code> (по умолчанию), <code>start</code>, <code>end</code>, <code>center</code>.</li>
</ul>
<p><code>css
.item-image {
    align-self: center;
}</code></p>
</li>
</ol>
<h3>Пример использования Grid</h3>
<p>Создадим простой макет страницы с шапкой, сайдбаром, основным контентом и футером.</p>
<p><strong>HTML:</strong></p>
<p>```html</p>
<div class="page-layout">
    <header class="header">Шапка</header>
    <aside class="sidebar">Сайдбар</aside>
    <main class="content">Основной контент</main>
    <footer class="footer">Футер</footer>
</div>
<p>```</p>
<p><strong>CSS:</strong></p>
<p>```css
.page-layout {
    display: grid;
    /<em> Определяем 3 столбца: 150px для сайдбара, 1fr для контента, 1fr для пустого места (или еще одного сайдбара) </em>/
    grid-template-columns: 150px 1fr;
    /<em> Определяем 3 строки: авто для шапки, 1fr для контента, авто для футера </em>/
    grid-template-rows: auto 1fr auto;
    /<em> Задаем области для элементов, используя grid-template-areas </em>/
    grid-template-areas:
        "header header"
        "sidebar content"
        "footer footer";
    min-height: 100vh; /<em> Растягиваем контейнер на всю высоту экрана </em>/
    gap: 10px; /<em> Промежутки между элементами </em>/
}</p>
<p>.header {
    grid-area: header;
    background-color: #f8f9fa;
    padding: 20px;
    text-align: center;
}</p>
<p>.sidebar {
    grid-area: sidebar;
    background-color: #e9ecef;
    padding: 20px;
}</p>
<p>.content {
    grid-area: content;
    background-color: #ffffff;
    padding: 20px;
}</p>
<p>.footer {
    grid-area: footer;
    background-color: #f8f9fa;
    padding: 20px;
    text-align: center;
}</p>
<p>/<em> Базовые стили для демонстрации </em>/
body {
    margin: 0;
    font-family: Arial, sans-serif;
}
```</p>
<p>CSS Grid — это мощный инструмент для создания сложных двумерных макетов. Он значительно упрощает позиционирование элементов по сравнению с традиционными методами и Flexbox, особенно когда требуется контроль над расположением как по строкам, так и по столбцам. Сочетание Flexbox (для одномерных компонентов) и Grid (для общей структуры страницы) является очень эффективным подходом в современной веб-разработке.</p>
<hr />
<h1>Лекция 4: Адаптивный дизайн</h1>
<h2>4.1. Что такое адаптивный дизайн и его важность</h2>
<p>В современном мире пользователи получают доступ к веб-сайтам с огромного разнообразия устройств: настольные компьютеры с большими мониторами, ноутбуки, планшеты, смартфоны, смарт-телевизоры и даже умные часы. Каждое из этих устройств имеет свои уникальные характеристики, такие как размер экрана, разрешение, ориентация (портретная или альбомная), тип ввода (мышь, сенсорный экран) и скорость соединения.</p>
<p><strong>Адаптивный дизайн (Responsive Web Design - RWD)</strong> — это подход к веб-разработке, который позволяет веб-сайтам автоматически подстраиваться под размер экрана и характеристики устройства пользователя, обеспечивая оптимальное отображение и удобство использования. Цель адаптивного дизайна — предоставить пользователю наилучший возможный опыт просмотра, независимо от того, какое устройство он использует.</p>
<p><strong>Ключевые принципы адаптивного дизайна:</strong></p>
<ol>
<li><strong>Гибкие сетки (Fluid Grids):</strong> Использование относительных единиц измерения (проценты, <code>em</code>, <code>rem</code>, <code>vw</code>, <code>vh</code>) вместо фиксированных пикселей для ширины и высоты элементов. Это позволяет элементам масштабироваться пропорционально размеру экрана.</li>
<li><strong>Гибкие изображения и медиа (Flexible Images and Media):</strong> Изображения и видео также должны масштабироваться, чтобы не выходить за пределы родительского контейнера и не вызывать горизонтальную прокрутку. Обычно это достигается с помощью <code>max-width: 100%</code>.</li>
<li><strong>Медиа-запросы (Media Queries):</strong> Позволяют применять различные CSS-стили в зависимости от характеристик устройства, таких как ширина экрана, высота, ориентация, разрешение и т.д. Это основной инструмент для создания </li>
</ol>
<p>различных макетов для разных размеров экрана.</p>
<p><strong>Почему адаптивный дизайн важен?</strong></p>
<ul>
<li><strong>Улучшенный пользовательский опыт:</strong> Пользователи ожидают, что веб-сайты будут хорошо выглядеть и функционировать на любом устройстве. Плохой опыт на мобильных устройствах может привести к потере посетителей.</li>
<li><strong>SEO (Поисковая оптимизация):</strong> Google и другие поисковые системы отдают предпочтение сайтам, оптимизированным для мобильных устройств. Адаптивный дизайн является одним из ключевых факторов ранжирования.</li>
<li><strong>Экономия времени и ресурсов:</strong> Вместо создания отдельных версий сайта для каждого устройства, адаптивный дизайн позволяет поддерживать одну кодовую базу, что упрощает разработку и обслуживание.</li>
<li><strong>Широкий охват аудитории:</strong> Доступность сайта на всех устройствах расширяет потенциальную аудиторию.</li>
<li><strong>Будущее-ориентированность:</strong> С появлением новых устройств и размеров экранов, адаптивный дизайн обеспечивает гибкость и масштабируемость.</li>
</ul>
<h2>4.2. Принцип Mobile First</h2>
<p><strong>Mobile First (Сначала мобильные)</strong> — это подход к веб-дизайну и разработке, при котором создание веб-сайта начинается с проектирования и реализации его версии для самых маленьких экранов (мобильных устройств), а затем постепенно расширяется до больших экранов (планшетов, настольных компьютеров). Этот подход противоположен традиционному методу «Desktop First», когда сначала создается версия для больших экранов, а затем она адаптируется для мобильных.</p>
<p><strong>Преимущества подхода Mobile First:</strong></p>
<ul>
<li><strong>Приоритет контента и функциональности:</strong> На маленьких экранах меньше места, что заставляет разработчиков сосредоточиться на самом важном контенте и функциональности. Это помогает избежать избыточности и улучшить юзабилити.</li>
<li><strong>Оптимизация производительности:</strong> Мобильные устройства часто имеют ограниченные ресурсы (меньшая мощность процессора, медленное интернет-соединение). Проектирование для мобильных устройств с самого начала способствует созданию более легких и быстрых сайтов, что выгодно для всех пользователей.</li>
<li><strong>Улучшенная доступность:</strong> Приоритизация мобильных устройств часто приводит к более чистому и логичному HTML-коду, что улучшает доступность для пользователей с ограниченными возможностями и скринридеров.</li>
<li><strong>Лучшее использование медиа-запросов:</strong> При подходе Mobile First, базовые стили пишутся для мобильных устройств, а медиа-запросы используются для <em>добавления</em> стилей для больших экранов (min-width). Это более логично и эффективно, чем пытаться <em>удалять</em> или <em>переопределять</em> стили для мобильных устройств.</li>
<li><strong>Соответствие современным тенденциям:</strong> Большая часть интернет-трафика приходится на мобильные устройства, и эта тенденция продолжает расти. Mobile First соответствует поведению современных пользователей.</li>
</ul>
<p><strong>Как это работает на практике:</strong></p>
<ol>
<li><strong>Дизайн и прототипирование:</strong> Начните с создания макетов и прототипов для мобильных устройств. Определите ключевые элементы, навигацию и взаимодействие.</li>
<li><strong>HTML-разметка:</strong> Создайте HTML-структуру, которая будет работать на мобильных устройствах. Убедитесь, что она логична и семантична.</li>
<li><strong>Базовые CSS-стили:</strong> Напишите CSS-стили, которые будут применяться по умолчанию ко всем устройствам (т.е. для мобильных). Используйте относительные единицы измерения.</li>
<li><strong>Медиа-запросы для больших экранов:</strong> Используйте медиа-запросы с правилом <code>min-width</code> для добавления стилей, которые будут применяться только на экранах, превышающих определенную ширину. Это позволяет постепенно улучшать макет для планшетов и десктопов.</li>
</ol>
<p><strong>Пример структуры CSS с Mobile First:</strong></p>
<p>```css
/<em> Базовые стили для мобильных устройств (по умолчанию) </em>/
body {
    font-size: 16px;
    padding: 10px;
}
.container {
    width: 100%;
}</p>
<p>/<em> Медиа-запрос для планшетов (от 768px и выше) </em>/
@media screen and (min-width: 768px) {
    body {
        font-size: 18px;
        padding: 20px;
    }
    .container {
        width: 750px;
        margin: 0 auto;
    }
}</p>
<p>/<em> Медиа-запрос для десктопов (от 1200px и выше) </em>/
@media screen and (min-width: 1200px) {
    body {
        font-size: 20px;
    }
    .container {
        width: 1140px;
    }
}
```</p>
<p>Подход Mobile First является современной и эффективной стратегией для создания адаптивных веб-сайтов, обеспечивающей лучший пользовательский опыт и производительность на всех устройствах.</p>
<hr />
<h2>4.3. Медиа-запросы (Media Queries)</h2>
<p>Медиа-запросы являются краеугольным камнем адаптивного дизайна. Они позволяют применять различные наборы CSS-правил в зависимости от характеристик устройства, на котором просматривается веб-страница. Это дает возможность создавать уникальные макеты и стили для разных размеров экрана, разрешений, ориентаций и других параметров.</p>
<h3>Синтаксис медиа-запросов</h3>
<p>Базовый синтаксис медиа-запроса выглядит следующим образом:</p>
<p><code>css
@media media_type and (media_feature) {
    /* CSS-правила, которые применяются, если условие истинно */
}</code></p>
<ul>
<li><code>@media</code>: Ключевое слово, указывающее на начало медиа-запроса.</li>
<li><code>media_type</code>: Тип устройства, для которого предназначен стиль. Наиболее распространенные:<ul>
<li><code>all</code>: Для всех типов устройств (по умолчанию, если не указан).</li>
<li><code>screen</code>: Для компьютерных экранов, планшетов, смартфонов.</li>
<li><code>print</code>: Для принтеров (стили для печати).</li>
<li><code>speech</code>: Для речевых синтезаторов.</li>
</ul>
</li>
<li><code>and</code>: Логический оператор, используемый для объединения нескольких условий.</li>
<li><code>media_feature</code>: Характеристика устройства, которую мы проверяем. Заключается в круглые скобки. Наиболее часто используемые:<ul>
<li><code>width</code>: Ширина области просмотра (viewport).</li>
<li><code>height</code>: Высота области просмотра.</li>
<li><code>min-width</code>: Минимальная ширина области просмотра (стили применяются, если ширина viewport больше или равна указанному значению).</li>
<li><code>max-width</code>: Максимальная ширина области просмотра (стили применяются, если ширина viewport меньше или равна указанному значению).</li>
<li><code>orientation</code>: Ориентация устройства (<code>portrait</code> или <code>landscape</code>).</li>
<li><code>resolution</code>: Разрешение экрана.</li>
</ul>
</li>
</ul>
<h3>Примеры использования медиа-запросов</h3>
<p><strong>1. Изменение стилей для разных размеров экрана:</strong></p>
<p>Предположим, у нас есть базовые стили для мобильных устройств (Mobile First), и мы хотим изменить размер шрифта и ширину контейнера для планшетов и десктопов.</p>
<p>```css
/<em> Базовые стили (для мобильных устройств) </em>/
body {
    font-size: 16px;
    line-height: 1.5;
}
.container {
    width: 90%;
    margin: 0 auto;
}</p>
<p>/<em> Стили для экранов шириной от 768px (планшеты и выше) </em>/
@media screen and (min-width: 768px) {
    body {
        font-size: 18px;
    }
    .container {
        width: 720px;
    }
}</p>
<p>/<em> Стили для экранов шириной от 1200px (десктопы) </em>/
@media screen and (min-width: 1200px) {
    body {
        font-size: 20px;
    }
    .container {
        width: 1140px;
    }
}
```</p>
<p><strong>2. Изменение макета для разных ориентаций:</strong></p>
<p>Мы можем изменить расположение элементов, когда устройство находится в альбомной ориентации.</p>
<p>```css
.gallery {
    display: flex;
    flex-direction: column; /<em> По умолчанию элементы в колонку </em>/
}</p>
<p>@media screen and (orientation: landscape) {
    .gallery {
        flex-direction: row; /<em> В альбомной ориентации элементы в ряд </em>/
        flex-wrap: wrap;
        justify-content: center;
    }
    .gallery-item {
        width: 30%;
        margin: 10px;
    }
}
```</p>
<p><strong>3. Комбинирование условий:</strong></p>
<p>Можно объединять несколько условий с помощью <code>and</code>, <code>or</code> (ключевое слово <code>or</code> не поддерживается в старых версиях, вместо него можно использовать запятую <code>,</code>) и <code>not</code>.</p>
<p>```css
/<em> Стили для экранов с минимальной шириной 600px и альбомной ориентацией </em>/
@media screen and (min-width: 600px) and (orientation: landscape) {
    .sidebar {
        display: block;
    }
}</p>
<p>/<em> Стили для экранов с максимальной шириной 767px ИЛИ максимальной высотой 400px </em>/
@media screen and (max-width: 767px), screen and (max-height: 400px) {
    .header-nav {
        flex-direction: column;
    }
}
```</p>
<h3>Точки останова (Breakpoints)</h3>
<p>Точки останова — это значения ширины экрана, при которых макет страницы меняется. Нет универсальных «правильных» точек останова; они зависят от контента и дизайна вашего сайта. Однако существуют общепринятые диапазоны, основанные на размерах популярных устройств:</p>
<ul>
<li><strong>Малые мобильные:</strong> до 320px</li>
<li><strong>Мобильные:</strong> 320px - 480px</li>
<li><strong>Большие мобильные / малые планшеты:</strong> 481px - 767px</li>
<li><strong>Планшеты:</strong> 768px - 1024px</li>
<li><strong>Ноутбуки / малые десктопы:</strong> 1025px - 1200px</li>
<li><strong>Большие десктопы:</strong> 1201px и выше</li>
</ul>
<p>При подходе Mobile First, вы начинаете с базовых стилей для самых маленьких экранов, а затем используете <code>min-width</code> для применения стилей к более крупным экранам:</p>
<p>```css
/<em> Базовые стили для всех (мобильных) </em>/</p>
<p>@media (min-width: 768px) {
    /<em> Стили для планшетов и выше </em>/
}</p>
<p>@media (min-width: 1024px) {
    /<em> Стили для десктопов и выше </em>/
}
```</p>
<h3>Важность мета-тега Viewport</h3>
<p>Для корректной работы медиа-запросов и адаптивного дизайна в целом, крайне важно включить мета-тег <code>viewport</code> в <code>&lt;head&gt;</code> вашего HTML-документа:</p>
<p><code>html
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code></p>
<ul>
<li><code>width=device-width</code>: Устанавливает ширину области просмотра равной ширине экрана устройства. Без этого тега мобильные браузеры могут отображать страницу в режиме «десктопного» масштаба, а затем уменьшать ее, что приведет к некорректному отображению.</li>
<li><code>initial-scale=1.0</code>: Устанавливает начальный уровень масштабирования страницы при первой загрузке. Значение 1.0 означает отсутствие масштабирования.</li>
</ul>
<p>Без этого мета-тега браузеры могут некорректно интерпретировать ширину экрана, и ваши медиа-запросы могут не работать должным образом. Это первый шаг к созданию адаптивного сайта.</p>
<p>Медиа-запросы являются мощным инструментом, который позволяет создавать гибкие и отзывчивые веб-сайты, обеспечивая отличный пользовательский опыт на любом устройстве. Правильное их использование в сочетании с гибкими сетками и изображениями является основой современного веб-дизайна.</p>
<hr />
<h1>Лекция 5: Введение в JavaScript</h1>
<h2>5.1. Что такое JavaScript и его роль в веб-разработке</h2>
<p>JavaScript (JS) — это высокоуровневый, интерпретируемый язык программирования, который является одной из трех ключевых технологий Всемирной паутины, наряду с HTML и CSS. В то время как HTML определяет структуру веб-страницы, а CSS — ее внешний вид, JavaScript добавляет интерактивность и динамическое поведение. Без JavaScript веб-страницы были бы статичными документами, похожими на страницы книги.</p>
<p><strong>Роль JavaScript в веб-разработке:</strong></p>
<ol>
<li>
<p><strong>Интерактивность на стороне клиента (Client-side scripting):</strong> Основная роль JavaScript — это выполнение кода непосредственно в браузере пользователя. Это позволяет создавать динамические элементы, которые реагируют на действия пользователя без необходимости перезагрузки страницы. Примеры:</p>
<ul>
<li>Проверка данных, введенных в формы (валидация).</li>
<li>Динамическое изменение содержимого HTML и CSS (например, скрытие/показ элементов, изменение стилей).</li>
<li>Создание интерактивных карт, графиков, анимаций.</li>
<li>Обработка событий пользователя (клики, наведение мыши, нажатия клавиш).</li>
<li>Загрузка данных с сервера без перезагрузки страницы (AJAX).</li>
</ul>
</li>
<li>
<p><strong>Разработка на стороне сервера (Server-side scripting):</strong> С появлением Node.js JavaScript вышел за пределы браузера и теперь может использоваться для создания серверных приложений, API, баз данных и многого другого. Это позволяет использовать один язык программирования для всего стека разработки (Full-stack JavaScript).</p>
</li>
<li>
<p><strong>Мобильные и десктопные приложения:</strong> С помощью фреймворков, таких как React Native (для мобильных) и Electron (для десктопных), JavaScript может использоваться для создания нативных мобильных приложений и кроссплатформенных десктопных приложений.</p>
</li>
<li>
<p><strong>Игры:</strong> JavaScript также используется для разработки браузерных игр.</p>
</li>
</ol>
<p><strong>Как JavaScript работает в браузере:</strong></p>
<p>Каждый современный веб-браузер имеет встроенный <strong>движок JavaScript</strong> (например, V8 в Chrome, SpiderMonkey в Firefox), который интерпретирует и выполняет JavaScript-код. Когда браузер загружает веб-страницу, он парсит HTML, строит DOM (Document Object Model), применяет CSS, а затем выполняет JavaScript-код, который может манипулировать DOM, изменять стили и реагировать на события.</p>
<p><strong>Краткая история:</strong></p>
<p>JavaScript был создан Бренданом Эйхом в Netscape в 1995 году и изначально назывался LiveScript. Позже он был переименован в JavaScript, чтобы воспользоваться популярностью Java. Несмотря на схожесть названий, JavaScript и Java — это совершенно разные языки программирования. JavaScript быстро стал стандартом для интерактивности в вебе и продолжает активно развиваться, обрастая новыми возможностями и фреймворками.</p>
<h2>5.2. Подключение JavaScript к HTML-документу</h2>
<p>Существует несколько способов подключения JavaScript-кода к HTML-документу, аналогично CSS.</p>
<h3>1. Внешний JavaScript (External JavaScript)</h3>
<p>Это наиболее предпочтительный способ. JavaScript-код хранится в отдельном файле с расширением <code>.js</code> (например, <code>script.js</code>), который затем подключается к HTML-документу с помощью тега <code>&lt;script&gt;</code>.</p>
<p><strong>Преимущества:</strong>
*   <strong>Разделение ответственности:</strong> HTML для структуры, CSS для стилей, JavaScript для поведения. Это делает код более организованным и легким для поддержки.
*   <strong>Кэширование:</strong> Браузеры кэшируют внешние JS-файлы, что ускоряет загрузку страниц при повторных посещениях.
*   <strong>Повторное использование:</strong> Один JS-файл может быть использован на нескольких HTML-страницах.</p>
<p><strong>Как подключить:</strong>
Тег <code>&lt;script&gt;</code> с атрибутом <code>src</code> указывает путь к файлу JavaScript.</p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моя страница с JS</title>
</head>
<body>
    <h1>Привет, JavaScript!</h1>
    <button id="myButton">Нажми меня</button>

    <!-- Рекомендуемое место для подключения скриптов -->
    <script src="script.js"></script>
</body>
</html>
<p>```</p>
<p><strong>Пример <code>script.js</code>:</strong></p>
<p><code>javascript
// script.js
document.getElementById("myButton").addEventListener("click", function() {
    alert("Кнопка нажата!");
});</code></p>
<p><strong>Важное замечание о размещении <code>&lt;script&gt;</code>:</strong></p>
<p>Традиционно тег <code>&lt;script&gt;</code> размещают непосредственно перед закрывающим тегом <code>&lt;/body&gt;</code>. Это делается для того, чтобы HTML-документ был полностью загружен и DOM был построен до того, как JavaScript начнет манипулировать элементами страницы. Если скрипт попытается получить доступ к элементу, который еще не загружен, это приведет к ошибке.</p>
<p>Альтернативно, можно использовать атрибуты <code>defer</code> или <code>async</code> в теге <code>&lt;script&gt;</code>:</p>
<ul>
<li><code>&lt;script src="script.js" defer&gt;&lt;/script&gt;</code>: Скрипт загружается асинхронно, но выполняется только после того, как HTML-документ будет полностью разобран. Порядок выполнения скриптов с <code>defer</code> сохраняется.</li>
<li><code>&lt;script src="script.js" async&gt;&lt;/script&gt;</code>: Скрипт загружается асинхронно и выполняется сразу же, как только будет загружен, не дожидаясь разбора HTML. Порядок выполнения скриптов с <code>async</code> не гарантируется.</li>
</ul>
<p>Для большинства случаев, когда скрипт взаимодействует с DOM, размещение <code>&lt;script&gt;</code> перед <code>&lt;/body&gt;</code> или использование <code>defer</code> является хорошей практикой.</p>
<h3>2. Внутренний JavaScript (Internal JavaScript)</h3>
<p>JavaScript-код пишется непосредственно внутри HTML-документа, внутри тега <code>&lt;script&gt;</code>. Этот метод подходит для небольших скриптов, которые используются только на одной странице.</p>
<p><strong>Преимущества:</strong>
*   Удобство для небольших, специфичных для страницы скриптов.</p>
<p><strong>Недостатки:</strong>
*   Смешивает HTML и JavaScript, что затрудняет чтение и поддержку кода.
*   Невозможно повторно использовать код на других страницах.
*   Скрипт загружается каждый раз при загрузке страницы.</p>
<p><strong>Как подключить:</strong></p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моя страница с JS</title>
</head>
<body>
    <h1>Привет, JavaScript!</h1>
    <button id="myButton">Нажми меня</button>

    <script>
        // Внутренний JavaScript-код
        document.getElementById("myButton").addEventListener("click", function() {
            alert("Кнопка нажата!");
        });
    </script>
</body>
</html>
<p>```</p>
<h3>3. Инлайн-JavaScript (Inline JavaScript)</h3>
<p>JavaScript-код встраивается непосредственно в HTML-атрибуты элементов, обычно в обработчики событий (например, <code>onclick</code>, <code>onmouseover</code>). Этот метод <strong>не рекомендуется</strong> для современной веб-разработки, так как он сильно смешивает структуру и поведение, затрудняет поддержку и отладку.</p>
<p><strong>Недостатки:</strong>
*   Очень плохая читаемость и поддержка кода.
*   Невозможно повторно использовать код.
*   Проблемы с безопасностью (XSS-уязвимости).</p>
<p><strong>Как подключить (не рекомендуется):</strong></p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моя страница с JS</title>
</head>
<body>
    <h1>Привет, JavaScript!</h1>
    <button onclick="alert('Кнопка нажата!');">Нажми меня</button>
</body>
</html>
<p>```</p>
<p>В дальнейшем мы будем использовать преимущественно внешний JavaScript для всех наших проектов, так как это является лучшей практикой в индустрии.</p>
<hr />
<h2>5.3. Переменные, типы данных, операторы</h2>
<p>JavaScript, как и любой язык программирования, оперирует данными. Для хранения и манипулирования этими данными используются переменные и различные типы данных. Операторы позволяют выполнять действия над этими данными.</p>
<h3>Переменные: <code>var</code>, <code>let</code>, <code>const</code></h3>
<p>Переменная — это именованное хранилище для данных. В JavaScript существует три ключевых слова для объявления переменных:</p>
<ol>
<li>
<p><strong><code>var</code> (устаревший способ)</strong></p>
<ul>
<li>Объявляет переменную с функциональной или глобальной областью видимости.</li>
<li>Переменные, объявленные с <code>var</code>, могут быть переобъявлены и переназначены.</li>
<li>Подвержены «поднятию» (hoisting), что может приводить к неочевидному поведению.</li>
</ul>
<p>```javascript
var greeting = "Привет, мир!";
console.log(greeting); // Привет, мир!</p>
<p>var greeting = "Hello, world!"; // Переобъявление допустимо
console.log(greeting); // Hello, world!</p>
<p>function exampleVar() {
    if (true) {
        var x = 10;
    }
    console.log(x); // 10 (x доступна вне блока if)
}
exampleVar();
```</p>
<p><strong>Рекомендация:</strong> Избегайте использования <code>var</code> в современном JavaScript из-за его особенностей с областью видимости и поднятием.</p>
</li>
<li>
<p><strong><code>let</code> (современный способ)</strong></p>
<ul>
<li>Объявляет переменную с блочной областью видимости (доступна только внутри блока, где она объявлена, например, внутри <code>if</code>, <code>for</code>, <code>{}</code>).</li>
<li>Переменные, объявленные с <code>let</code>, могут быть переназначены, но не могут быть переобъявлены в той же области видимости.</li>
</ul>
<p>```javascript
let message = "Hello";
console.log(message); // Hello</p>
<p>message = "Hi"; // Переназначение допустимо
console.log(message); // Hi</p>
<p>// let message = "New"; // Ошибка: Identifier 'message' has already been declared</p>
<p>function exampleLet() {
    if (true) {
        let y = 20;
        console.log(y); // 20
    }
    // console.log(y); // Ошибка: y is not defined (y недоступна вне блока if)
}
exampleLet();
```</p>
</li>
<li>
<p><strong><code>const</code> (современный способ для констант)</strong></p>
<ul>
<li>Объявляет константу с блочной областью видимости.</li>
<li>Значение константы <strong>не может быть переназначено</strong> после инициализации.</li>
<li>Должна быть инициализирована при объявлении.</li>
</ul>
<p>```javascript
const PI = 3.14159;
console.log(PI); // 3.14159</p>
<p>// PI = 3.14; // Ошибка: Assignment to constant variable.</p>
<p>const user = {
    name: "Alice",
    age: 30
};
console.log(user); // { name: 'Alice', age: 30 }</p>
<p>user.age = 31; // Допустимо: можно изменять свойства объекта, объявленного через const
console.log(user); // { name: 'Alice', age: 31 }</p>
<p>// user = {}; // Ошибка: Assignment to constant variable. (нельзя переназначить сам объект)
```</p>
</li>
</ol>
<p><strong>Рекомендация:</strong> В современном JavaScript предпочтительно использовать <code>const</code> по умолчанию. Если вам нужно переназначить переменную, используйте <code>let</code>. Избегайте <code>var</code>.</p>
<h3>Типы данных</h3>
<p>JavaScript является динамически типизированным языком, что означает, что вам не нужно явно указывать тип данных при объявлении переменной. Тип данных определяется автоматически во время выполнения программы на основе значения, которое присваивается переменной.</p>
<p>JavaScript имеет 8 основных типов данных:</p>
<p><strong>Примитивные типы данных (Primitive Data Types):</strong></p>
<ol>
<li>
<p><strong><code>string</code> (строка):</strong> Последовательность символов, заключенная в одинарные (<code>'</code>) или двойные (<code>"</code>) кавычки, или обратные кавычки (<code>`</code>) для шаблонных строк.</p>
<p><code>javascript
let name = "Иван";
let message = 'Привет, ' + name + '!';
let templateMessage = `Привет, ${name}!`; // Шаблонная строка (ES6)</code></p>
</li>
<li>
<p><strong><code>number</code> (число):</strong> Целые числа и числа с плавающей точкой.</p>
<p><code>javascript
let age = 30;
let price = 99.99;
let bigNumber = 1e6; // 1 000 000</code></p>
</li>
<li>
<p><strong><code>boolean</code> (логический):</strong> Представляет логическое значение: <code>true</code> (истина) или <code>false</code> (ложь).</p>
<p><code>javascript
let isActive = true;
let hasPermission = false;</code></p>
</li>
<li>
<p><strong><code>undefined</code> (неопределенный):</strong> Значение, которое автоматически присваивается переменной, которая была объявлена, но ей не было присвоено никакого значения.</p>
<p><code>javascript
let city;
console.log(city); // undefined</code></p>
</li>
<li>
<p><strong><code>null</code> (нулевой):</strong> Специальное значение, которое представляет отсутствие какого-либо объектного значения. <code>null</code> — это примитивное значение, но <code>typeof null</code> возвращает <code>"object"</code> (это известная историческая ошибка в JavaScript).</p>
<p><code>javascript
let user = null;
console.log(user); // null</code></p>
</li>
<li>
<p><strong><code>symbol</code> (символ):</strong> Уникальный и неизменяемый примитивный тип данных, введенный в ES6. Используется для создания уникальных идентификаторов объектов.</p>
<p><code>javascript
const id = Symbol('id');
const anotherId = Symbol('id');
console.log(id === anotherId); // false</code></p>
</li>
<li>
<p><strong><code>bigint</code> (большое целое):</strong> Представляет целые числа произвольной точности. Позволяет работать с числами, которые выходят за пределы безопасного диапазона для типа <code>number</code>.</p>
<p><code>javascript
const largeNumber = 9007199254740991n + 1n; // Добавляем 'n' в конце для BigInt</code></p>
</li>
</ol>
<p><strong>Непримитивный тип данных (Non-primitive Data Type):</strong></p>
<ol>
<li>
<p><strong><code>object</code> (объект):</strong> Сложный тип данных, который может хранить коллекции данных и более сложные сущности. Все, что не является примитивным типом, является объектом в JavaScript. Включает в себя:</p>
<ul>
<li><strong>Объекты:</strong> Неупорядоченные коллекции пар ключ-значение.</li>
<li><strong>Массивы:</strong> Упорядоченные коллекции значений.</li>
<li><strong>Функции:</strong> Объекты, которые можно вызывать.</li>
</ul>
<p>```javascript
// Объект
let person = {
    firstName: "John",
    lastName: "Doe",
    age: 30
};</p>
<p>// Массив
let colors = ["red", "green", "blue"];</p>
<p>// Функция
function greet() {
    console.log("Hello!");
}
```</p>
</li>
</ol>
<h3>Операторы</h3>
<p>Операторы — это специальные символы, которые выполняют операции над операндами (значениями или переменными).</p>
<ol>
<li>
<p><strong>Арифметические операторы:</strong> Выполняют математические операции.</p>
<ul>
<li><code>+</code> (сложение)</li>
<li><code>-</code> (вычитание)</li>
<li><code>*</code> (умножение)</li>
<li><code>/</code> (деление)</li>
<li><code>%</code> (остаток от деления)</li>
<li><code>**</code> (возведение в степень, ES6)</li>
<li><code>++</code> (инкремент: <code>a++</code> или <code>++a</code>)</li>
<li><code>--</code> (декремент: <code>a--</code> или <code>--a</code>)</li>
</ul>
<p><code>javascript
let a = 10;
let b = 3;
console.log(a + b); // 13
console.log(a / b); // 3.333...
console.log(a % b); // 1
console.log(a ** 2); // 100
a++; // a становится 11</code></p>
</li>
<li>
<p><strong>Операторы присваивания:</strong> Присваивают значение переменной.</p>
<ul>
<li><code>=</code> (присваивание)</li>
<li><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>**=</code> (сокращенные операторы присваивания)</li>
</ul>
<p><code>javascript
let x = 5;
x += 3; // x теперь 8 (эквивалентно x = x + 3)</code></p>
</li>
<li>
<p><strong>Операторы сравнения:</strong> Сравнивают два значения и возвращают <code>true</code> или <code>false</code>.</p>
<ul>
<li><code>==</code> (равно, с приведением типов)</li>
<li><code>===</code> (строго равно, без приведения типов)</li>
<li><code>!=</code> (не равно, с приведением типов)</li>
<li><code>!==</code> (строго не равно, без приведения типов)</li>
<li><code>&gt;</code> (больше)</li>
<li><code>&lt;</code> (меньше)</li>
<li><code>&gt;=</code> (больше или равно)</li>
<li><code>&lt;=</code> (меньше или равно)</li>
</ul>
<p><code>javascript
console.log(5 == '5');   // true (приведение типов)
console.log(5 === '5');  // false (разные типы)
console.log(10 &gt; 5);     // true</code></p>
</li>
<li>
<p><strong>Логические операторы:</strong> Используются для комбинирования или инвертирования логических значений.</p>
<ul>
<li><code>&amp;&amp;</code> (логическое И)</li>
<li><code>||</code> (логическое ИЛИ)</li>
<li><code>!</code> (логическое НЕ)</li>
</ul>
<p><code>javascript
let isAdult = true;
let hasLicense = false;
console.log(isAdult &amp;&amp; hasLicense); // false
console.log(isAdult || hasLicense); // true
console.log(!isAdult); // false</code></p>
</li>
<li>
<p><strong>Тернарный оператор (условный оператор):</strong> Сокращенная форма <code>if-else</code>.</p>
<ul>
<li><code>условие ? выражение_если_истина : выражение_если_ложь</code></li>
</ul>
<p><code>javascript
let age = 18;
let status = (age &gt;= 18) ? "Взрослый" : "Несовершеннолетний";
console.log(status); // Взрослый</code></p>
</li>
</ol>
<p>Понимание переменных, типов данных и операторов является фундаментальным для написания любого JavaScript-кода. Это базовые строительные блоки, на которых основывается вся логика программы.</p>
<hr />
<h2>5.4. Условные конструкции (if/else) и циклы (for)</h2>
<p>Условные конструкции и циклы являются фундаментальными концепциями в программировании, позволяющими управлять потоком выполнения программы. Они дают возможность выполнять определенный код только при соблюдении заданных условий или повторять выполнение кода несколько раз.</p>
<h3>Условные конструкции</h3>
<p>Условные конструкции позволяют выполнять различные блоки кода в зависимости от того, истинно или ложно определенное условие.</p>
<h4>1. <code>if</code></h4>
<p>Базовая условная конструкция. Код внутри блока <code>if</code> выполняется, если условие истинно.</p>
<p>```javascript
let age = 20;</p>
<p>if (age &gt;= 18) {
    console.log("Вы совершеннолетний.");
}
```</p>
<h4>2. <code>if...else</code></h4>
<p>Добавляет альтернативный блок кода, который выполняется, если условие <code>if</code> ложно.</p>
<p>```javascript
let temperature = 25;</p>
<p>if (temperature &gt; 30) {
    console.log("Очень жарко!");
} else {
    console.log("Температура комфортная.");
}
```</p>
<h4>3. <code>if...else if...else</code></h4>
<p>Позволяет проверять несколько условий последовательно. Код выполняется для первого условия, которое окажется истинным.</p>
<p>```javascript
let score = 85;</p>
<p>if (score &gt;= 90) {
    console.log("Отлично!");
} else if (score &gt;= 75) {
    console.log("Хорошо.");
} else if (score &gt;= 60) {
    console.log("Удовлетворительно.");
} else {
    console.log("Неудовлетворительно.");
}
```</p>
<h4>4. <code>switch</code></h4>
<p>Используется для выполнения различных действий на основе различных условий. Часто является более читабельной альтернативой длинной цепочке <code>if...else if</code> при проверке одного и того же значения на несколько возможных вариантов.</p>
<p>```javascript
let day = "Вторник";</p>
<p>switch (day) {
    case "Понедельник":
        console.log("Начало рабочей недели.");
        break;
    case "Вторник":
    case "Среда":
    case "Четверг":
        console.log("Рабочая неделя в разгаре.");
        break;
    case "Пятница":
        console.log("Конец рабочей недели!");
        break;
    default:
        console.log("Выходной день.");
}
```</p>
<ul>
<li><code>break</code>: Важен для выхода из блока <code>switch</code> после выполнения соответствующего <code>case</code>. Если <code>break</code> отсутствует, выполнение продолжится в следующем <code>case</code> (fall-through).</li>
<li><code>default</code>: Выполняется, если ни один из <code>case</code> не совпал.</li>
</ul>
<h3>Циклы</h3>
<p>Циклы используются для многократного выполнения блока кода, пока определенное условие остается истинным или пока не будет достигнуто определенное количество итераций.</p>
<h4>1. <code>for</code></h4>
<p>Наиболее распространенный тип цикла, используемый, когда известно количество итераций.</p>
<p><code>javascript
for (инициализация; условие; шаг) {
    // код, который будет выполняться на каждой итерации
}</code></p>
<ul>
<li><strong>Инициализация:</strong> Выполняется один раз в начале цикла (например, <code>let i = 0;</code>).</li>
<li><strong>Условие:</strong> Проверяется перед каждой итерацией. Если условие истинно, цикл продолжается; если ложно, цикл завершается.</li>
<li><strong>Шаг:</strong> Выполняется после каждой итерации (например, <code>i++</code>).</li>
</ul>
<p><code>javascript
for (let i = 0; i &lt; 5; i++) {
    console.log("Итерация номер: " + i);
}
// Вывод:
// Итерация номер: 0
// Итерация номер: 1
// Итерация номер: 2
// Итерация номер: 3
// Итерация номер: 4</code></p>
<h4>2. <code>while</code></h4>
<p>Цикл <code>while</code> повторяет блок кода, пока указанное условие истинно. Количество итераций заранее неизвестно.</p>
<p><code>javascript
let count = 0;
while (count &lt; 3) {
    console.log("Счетчик: " + count);
    count++;
}
// Вывод:
// Счетчик: 0
// Счетчик: 1
// Счетчик: 2</code></p>
<h4>3. <code>do...while</code></h4>
<p>Похож на <code>while</code>, но блок кода выполняется хотя бы один раз, прежде чем условие будет проверено.</p>
<p><code>javascript
let i = 0;
do {
    console.log("Значение i: " + i);
    i++;
} while (i &lt; 0);
// Вывод:
// Значение i: 0 (выполнится один раз, хотя условие i &lt; 0 ложно)</code></p>
<h4>4. <code>for...of</code> (для итерируемых объектов, ES6)</h4>
<p>Используется для итерации по значениям итерируемых объектов (например, массивов, строк, Map, Set).</p>
<p>```javascript
const colors = ["красный", "зеленый", "синий"];</p>
<p>for (const color of colors) {
    console.log(color);
}
// Вывод:
// красный
// зеленый
// синий</p>
<p>const text = "Hello";
for (const char of text) {
    console.log(char);
}
// Вывод:
// H
// e
// l
// l
// o
```</p>
<h4>5. <code>for...in</code> (для перечисления свойств объекта)</h4>
<p>Используется для итерации по перечисляемым свойствам объекта. <strong>Не рекомендуется для массивов</strong>, так как он может перечислять не только индексы, но и другие свойства, а порядок итерации не гарантируется.</p>
<p>```javascript
const person = {
    name: "Alice",
    age: 30,
    city: "New York"
};</p>
<p>for (const key in person) {
    console.log(<code>${key}: ${person[key]}</code>);
}
// Вывод:
// name: Alice
// age: 30
// city: New York
```</p>
<h3>Операторы <code>break</code> и <code>continue</code></h3>
<ul>
<li>
<p><strong><code>break</code>:</strong> Немедленно завершает выполнение текущего цикла (или <code>switch</code>).</p>
<p><code>javascript
for (let i = 0; i &lt; 10; i++) {
    if (i === 5) {
        break; // Выход из цикла, когда i равно 5
    }
    console.log(i);
}
// Вывод: 0, 1, 2, 3, 4</code></p>
</li>
<li>
<p><strong><code>continue</code>:</strong> Пропускает текущую итерацию цикла и переходит к следующей.</p>
<p><code>javascript
for (let i = 0; i &lt; 5; i++) {
    if (i === 2) {
        continue; // Пропустить итерацию, когда i равно 2
    }
    console.log(i);
}
// Вывод: 0, 1, 3, 4</code></p>
</li>
</ul>
<p>Условные конструкции и циклы являются основой для создания любой сложной логики в JavaScript. Их правильное использование позволяет писать эффективный и управляемый код.</p>
<hr />
<h2>5.5. Работа с событиями: клики, ввод</h2>
<p>События (Events) — это действия, которые происходят в браузере и на которые JavaScript может реагировать. Они являются основой для создания интерактивных веб-страниц. Когда пользователь взаимодействует со страницей (кликает, вводит текст, наводит мышь), или когда страница загружается, или когда происходит что-то еще, браузер генерирует событие. JavaScript позволяет «слушать» эти события и выполнять определенный код в ответ на них.</p>
<h3>Модель событий</h3>
<p>В DOM (Document Object Model) существует модель событий, которая описывает, как события распространяются (всплывают и погружаются) по дереву элементов и как на них можно реагировать.</p>
<h3>Обработчики событий (Event Handlers)</h3>
<p>Существует несколько способов назначить функцию-обработчик события элементу.</p>
<h4>1. HTML-атрибуты (не рекомендуется)</h4>
<p>Самый старый и наименее рекомендуемый способ. Обработчик события указывается прямо в HTML-теге.</p>
<p><code>html
&lt;button onclick="alert(\'Привет!\');"&gt;Нажми меня&lt;/button&gt;</code></p>
<p><strong>Недостатки:</strong>
*   Смешивает HTML и JavaScript.
*   Трудно поддерживать и отлаживать.
*   Проблемы с безопасностью.</p>
<h4>2. Свойства DOM-объектов</h4>
<p>Можно присвоить функцию свойству DOM-объекта, которое соответствует имени события (например, <code>onclick</code>, <code>onmouseover</code>).</p>
<p>```javascript
// В script.js или внутри тега <script> после загрузки элемента
const myButton = document.getElementById("myButton");
myButton.onclick = function() {
    alert("Кнопка нажата!");
};</p>
<p>// Или с использованием стрелочной функции (ES6)
myButton.onclick = () =&gt; {
    alert("Кнопка нажата!");
};
```</p>
<p><strong>Недостатки:</strong>
*   Можно назначить только один обработчик на одно событие. Если назначить второй, он перезапишет первый.</p>
<h4>3. <code>addEventListener()</code> (рекомендуемый способ)</h4>
<p>Метод <code>addEventListener()</code> является наиболее гибким и рекомендуемым способом для назначения обработчиков событий. Он позволяет назначить несколько обработчиков на одно и то же событие для одного элемента.</p>
<p><code>javascript
element.addEventListener(event, handler, [options]);</code></p>
<ul>
<li><code>event</code>: Строка, указывающая тип события (например, <code>'click'</code>, <code>'mouseover'</code>, <code>'keydown'</code>).</li>
<li><code>handler</code>: Функция, которая будет вызвана при наступлении события.</li>
<li><code>options</code> (необязательно): Объект с опциями, например <code>capture: true</code> для фазы перехвата.</li>
</ul>
<p><strong>Пример:</strong></p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Работа с событиями</title>
</head>
<body>
    <button id="myButton">Нажми меня</button>
    <input type="text" id="myInput" placeholder="Введите текст">
    <p id="output"></p>

    <script>
        const myButton = document.getElementById("myButton");
        const myInput = document.getElementById("myInput");
        const outputParagraph = document.getElementById("output");

        // Обработка события клика на кнопке
        myButton.addEventListener("click", function() {
            alert("Кнопка была нажата!");
        });

        // Добавление второго обработчика клика (допустимо с addEventListener)
        myButton.addEventListener("click", function() {
            console.log("Второй обработчик клика сработал.");
        });

        // Обработка события ввода текста в поле input
        myInput.addEventListener("input", function() {
            outputParagraph.textContent = "Вы ввели: " + myInput.value;
        });

        // Обработка события потери фокуса (blur) для input
        myInput.addEventListener("blur", function() {
            console.log("Поле ввода потеряло фокус.");
        });

        // Обработка события нажатия клавиши (keydown) для input
        myInput.addEventListener("keydown", function(event) {
            if (event.key === "Enter") {
                alert("Нажат Enter! Значение: " + myInput.value);
            }
        });
    </script>
</body>
</html>
<p>```</p>
<h3>Объект события (Event Object)</h3>
<p>Когда происходит событие, функция-обработчик получает специальный объект события (Event Object) в качестве аргумента. Этот объект содержит полезную информацию о произошедшем событии.</p>
<p><strong>Основные свойства объекта события:</strong></p>
<ul>
<li><code>event.target</code>: Элемент, на котором произошло событие.</li>
<li><code>event.type</code>: Тип произошедшего события (например, <code>'click'</code>, <code>'input'</code>).</li>
<li><code>event.preventDefault()</code>: Метод, который отменяет действие браузера по умолчанию для данного события (например, предотвращает отправку формы при клике на кнопку submit, или переход по ссылке).</li>
<li><code>event.stopPropagation()</code>: Метод, который останавливает всплытие события по DOM-дереву.</li>
<li><code>event.key</code> (для событий клавиатуры): Название нажатой клавиши.</li>
<li><code>event.keyCode</code> / <code>event.which</code> (устаревшие): Код нажатой клавиши.</li>
<li><code>event.clientX</code>, <code>event.clientY</code> (для событий мыши): Координаты курсора относительно видимой части окна браузера.</li>
</ul>
<p><strong>Пример использования объекта события:</strong></p>
<p>```javascript
const myLink = document.getElementById("myLink");
myLink.addEventListener("click", function(event) {
    event.preventDefault(); // Отменяем переход по ссылке
    console.log("Вы кликнули по ссылке, но переход отменен.");
    console.log("Целевой элемент: ", event.target);
});</p>
<p>const myForm = document.getElementById("myForm");
myForm.addEventListener("submit", function(event) {
    event.preventDefault(); // Отменяем стандартную отправку формы
    const username = document.getElementById("username").value;
    if (username === "") {
        alert("Пожалуйста, введите имя пользователя!");
    } else {
        alert("Форма отправлена! Имя: " + username);
        // Здесь можно отправить данные формы на сервер с помощью AJAX
    }
});
```</p>
<h3>Распространенные типы событий</h3>
<ul>
<li>
<p><strong>События мыши:</strong></p>
<ul>
<li><code>click</code>: Клик левой кнопкой мыши.</li>
<li><code>dblclick</code>: Двойной клик.</li>
<li><code>mousedown</code>, <code>mouseup</code>: Нажатие и отпускание кнопки мыши.</li>
<li><code>mouseover</code>, <code>mouseout</code>: Наведение и уход курсора мыши.</li>
<li><code>mousemove</code>: Движение курсора мыши.</li>
<li><code>contextmenu</code>: Клик правой кнопкой мыши (вызывает контекстное меню).</li>
</ul>
</li>
<li>
<p><strong>События клавиатуры:</strong></p>
<ul>
<li><code>keydown</code>: Нажатие клавиши (срабатывает при удержании).</li>
<li><code>keyup</code>: Отпускание клавиши.</li>
<li><code>keypress</code> (устаревший): Нажатие символьной клавиши.</li>
</ul>
</li>
<li>
<p><strong>События форм:</strong></p>
<ul>
<li><code>submit</code>: Отправка формы.</li>
<li><code>input</code>: Изменение значения поля ввода (срабатывает при каждом вводе).</li>
<li><code>change</code>: Изменение значения поля ввода и потеря фокуса.</li>
<li><code>focus</code>, <code>blur</code>: Получение и потеря фокуса элементом.</li>
</ul>
</li>
<li>
<p><strong>События документа/окна:</strong></p>
<ul>
<li><code>DOMContentLoaded</code>: HTML-документ полностью загружен и разобран (без ожидания стилей и изображений).</li>
<li><code>load</code>: Вся страница, включая все ресурсы (изображения, стили), полностью загружена.</li>
<li><code>resize</code>: Изменение размера окна браузера.</li>
<li><code>scroll</code>: Прокрутка страницы.</li>
</ul>
</li>
</ul>
<p>Работа с событиями является ключевым аспектом интерактивной веб-разработки. Понимание того, как назначать обработчики событий и использовать объект события, позволит вам создавать динамичные и отзывчивые пользовательские интерфейсы.</p>
<hr />
<h2>5.6. Манипуляции с DOM (Document Object Model) для изменения содержимого страницы</h2>
<p><strong>DOM (Document Object Model)</strong> — это программный интерфейс (API) для HTML и XML документов. Он представляет структуру документа в виде дерева объектов, где каждый узел (node) представляет часть документа (элемент, атрибут, текст). JavaScript может использовать DOM для доступа к элементам страницы, изменения их содержимого, стилей, атрибутов, а также для добавления или удаления элементов.</p>
<p>Представьте HTML-документ как дерево:</p>
<p><code>Document
  └─ html
       └─ head
       |    └─ meta
       |    └─ title
       └─ body
            └─ h1
            └─ p
            └─ div
                 └─ img
                 └─ a</code></p>
<p>Каждый элемент, текст, комментарий в HTML-документе становится узлом в этом дереве. JavaScript предоставляет методы для навигации по этому дереву и манипулирования им.</p>
<h3>Получение элементов DOM</h3>
<p>Прежде чем манипулировать элементом, его нужно получить (выбрать) из DOM.</p>
<ol>
<li>
<p><strong><code>document.getElementById(id)</code>:</strong>
    Возвращает ссылку на элемент с указанным <code>id</code>. <code>id</code> должен быть уникальным на странице.</p>
<p><code>javascript
const myDiv = document.getElementById("myDiv");
console.log(myDiv); // &lt;div id="myDiv"&gt;...&lt;/div&gt;</code></p>
</li>
<li>
<p><strong><code>document.getElementsByClassName(className)</code>:</strong>
    Возвращает живую коллекцию (HTMLCollection) всех элементов с указанным именем класса. Коллекция обновляется автоматически при изменении DOM.</p>
<p><code>javascript
const paragraphs = document.getElementsByClassName("my-paragraph");
// paragraphs[0] - первый элемент с классом "my-paragraph"
for (let i = 0; i &lt; paragraphs.length; i++) {
    console.log(paragraphs[i].textContent);
}</code></p>
</li>
<li>
<p><strong><code>document.getElementsByTagName(tagName)</code>:</strong>
    Возвращает живую коллекцию (HTMLCollection) всех элементов с указанным именем тега.</p>
<p><code>javascript
const allDivs = document.getElementsByTagName("div");</code></p>
</li>
<li>
<p><strong><code>document.querySelector(selector)</code>:</strong>
    Возвращает первый элемент, соответствующий указанному CSS-селектору. Это очень мощный метод, так как позволяет использовать любые CSS-селекторы.</p>
<p><code>javascript
const firstParagraph = document.querySelector("p"); // Первый параграф
const myButton = document.querySelector("#myButton"); // Элемент с id="myButton"
const firstItem = document.querySelector(".list-item"); // Первый элемент с классом "list-item"
const specificElement = document.querySelector("div.container &gt; p:first-child");</code></p>
</li>
<li>
<p><strong><code>document.querySelectorAll(selector)</code>:</strong>
    Возвращает статическую коллекцию (NodeList) всех элементов, соответствующих указанному CSS-селектору. В отличие от <code>getElementsByClassName</code> и <code>getElementsByTagName</code>, NodeList не обновляется автоматически.</p>
<p><code>javascript
const allListItems = document.querySelectorAll(".list-item");
allListItems.forEach(item =&gt; {
    console.log(item.textContent);
});</code></p>
</li>
</ol>
<h3>Манипуляции с содержимым элементов</h3>
<p>После получения элемента, можно изменять его содержимое.</p>
<ol>
<li>
<p><strong><code>element.textContent</code>:</strong>
    Позволяет получить или установить текстовое содержимое элемента, игнорируя HTML-теги внутри него.</p>
<p><code>javascript
const myParagraph = document.getElementById("myParagraph");
myParagraph.textContent = "Новый текст для параграфа.";
console.log(myParagraph.textContent); // "Новый текст для параграфа."</code></p>
</li>
<li>
<p><strong><code>element.innerHTML</code>:</strong>
    Позволяет получить или установить HTML-содержимое элемента. Можно вставлять полноценный HTML-код.</p>
<p><code>javascript
const myDiv = document.getElementById("myDiv");
myDiv.innerHTML = "&lt;p&gt;Это &lt;strong&gt;новый&lt;/strong&gt; параграф.&lt;/p&gt;";
console.log(myDiv.innerHTML); // "&lt;p&gt;Это &lt;strong&gt;новый&lt;/strong&gt; параграф.&lt;/p&gt;"</code>
<strong>Внимание:</strong> Использование <code>innerHTML</code> с данными, полученными от пользователя, может привести к XSS-уязвимостям. Используйте <code>textContent</code> для вставки чистого текста.</p>
</li>
</ol>
<h3>Манипуляции с атрибутами элементов</h3>
<ol>
<li><strong><code>element.getAttribute(name)</code>:</strong> Получить значение атрибута.</li>
<li><strong><code>element.setAttribute(name, value)</code>:</strong> Установить или изменить значение атрибута.</li>
<li><strong><code>element.removeAttribute(name)</code>:</strong> Удалить атрибут.</li>
<li>
<p><strong><code>element.hasAttribute(name)</code>:</strong> Проверить наличие атрибута.</p>
<p><code>javascript
const myImage = document.getElementById("myImage");
console.log(myImage.getAttribute("src")); // Получить src
myImage.setAttribute("alt", "Описание изображения"); // Установить alt
myImage.removeAttribute("width"); // Удалить width</code></p>
</li>
</ol>
<h3>Манипуляции со стилями элементов</h3>
<ol>
<li>
<p><strong><code>element.style.propertyName</code>:</strong>
    Прямое изменение inline-стилей элемента. Имена CSS-свойств, содержащие дефис (например, <code>font-size</code>), в JavaScript пишутся в camelCase (например, <code>fontSize</code>).</p>
<p><code>javascript
const myElement = document.getElementById("myElement");
myElement.style.backgroundColor = "blue";
myElement.style.color = "white";
myElement.style.fontSize = "20px";</code>
<strong>Недостаток:</strong> Этот метод добавляет стили непосредственно в HTML-атрибут <code>style</code>, что не является лучшей практикой для управления стилями. Предпочтительнее использовать классы CSS.</p>
</li>
<li>
<p><strong>Манипуляции с классами CSS:</strong>
    Лучший способ управлять стилями — это добавлять или удалять классы CSS с помощью <code>classList</code>.</p>
<ul>
<li><code>element.classList.add(className)</code>: Добавить класс.</li>
<li><code>element.classList.remove(className)</code>: Удалить класс.</li>
<li><code>element.classList.toggle(className)</code>: Переключить класс (добавить, если нет; удалить, если есть).</li>
<li><code>element.classList.contains(className)</code>: Проверить наличие класса.</li>
</ul>
<p><code>html
&lt;!-- В HTML --&gt;
&lt;style&gt;
    .highlight {
        background-color: yellow;
        border: 2px solid orange;
    }
    .hidden {
        display: none;
    }
&lt;/style&gt;
&lt;p id="myText"&gt;Некоторый текст.&lt;/p&gt;
&lt;button id="toggleHighlight"&gt;Подсветить&lt;/button&gt;
&lt;button id="toggleVisibility"&gt;Скрыть/Показать&lt;/button&gt;</code></p>
<p>```javascript
const myText = document.getElementById("myText");
const toggleHighlightBtn = document.getElementById("toggleHighlight");
const toggleVisibilityBtn = document.getElementById("toggleVisibility");</p>
<p>toggleHighlightBtn.addEventListener("click", () =&gt; {
    myText.classList.toggle("highlight");
});</p>
<p>toggleVisibilityBtn.addEventListener("click", () =&gt; {
    myText.classList.toggle("hidden");
});
```</p>
</li>
</ol>
<h3>Создание и удаление элементов</h3>
<p>JavaScript позволяет динамически создавать новые элементы и добавлять их на страницу, а также удалять существующие.</p>
<ol>
<li>
<p><strong><code>document.createElement(tagName)</code>:</strong> Создает новый HTML-элемент.</p>
<p><code>javascript
const newDiv = document.createElement("div");
newDiv.textContent = "Это новый div!";
newDiv.classList.add("new-element");</code></p>
</li>
<li>
<p><strong><code>element.appendChild(childElement)</code>:</strong> Добавляет дочерний элемент в конец родительского элемента.</p>
<p><code>javascript
const container = document.getElementById("container");
container.appendChild(newDiv);</code></p>
</li>
<li>
<p><strong><code>element.prepend(childElement)</code>:</strong> Добавляет дочерний элемент в начало родительского элемента.</p>
<p><code>javascript
container.prepend(newDiv);</code></p>
</li>
<li>
<p><strong><code>element.insertBefore(newElement, referenceElement)</code>:</strong> Вставляет <code>newElement</code> перед <code>referenceElement</code>.</p>
<p><code>javascript
const existingParagraph = document.getElementById("existingParagraph");
container.insertBefore(newDiv, existingParagraph);</code></p>
</li>
<li>
<p><strong><code>element.removeChild(childElement)</code>:</strong> Удаляет дочерний элемент из родительского.</p>
<p><code>javascript
const elementToRemove = document.getElementById("elementToRemove");
elementToRemove.parentNode.removeChild(elementToRemove); // Удаляем себя через родителя
// Или, если есть ссылка на родителя:
// container.removeChild(elementToRemove);</code></p>
</li>
<li>
<p><strong><code>element.remove()</code>:</strong> Удаляет сам элемент (более современный и простой способ).</p>
<p><code>javascript
const elementToRemove = document.getElementById("elementToRemove");
elementToRemove.remove();</code></p>
</li>
</ol>
<h3>Пример комплексной манипуляции DOM</h3>
<p>Создадим список задач (To-Do List) с возможностью добавления и удаления элементов.</p>
<p><strong>HTML:</strong></p>
<p>```html</p>
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do List</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
        }
        #todo-list {
            list-style: none;
            padding: 0;
        }
        #todo-list li {
            background-color: #f4f4f4;
            margin-bottom: 5px;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #todo-list li button {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        #todo-input {
            padding: 8px;
            width: 200px;
            margin-right: 10px;
        }
        #add-todo-btn {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Мой список задач</h1>
    <div>
        <input type="text" id="todo-input" placeholder="Добавить новую задачу">
        <button id="add-todo-btn">Добавить</button>
    </div>
    <ul id="todo-list"></ul>

    <script>
        const todoInput = document.getElementById("todo-input");
        const addTodoBtn = document.getElementById("add-todo-btn");
        const todoList = document.getElementById("todo-list");

        addTodoBtn.addEventListener("click", () => {
            const todoText = todoInput.value.trim(); // Получаем текст и удаляем пробелы по краям

            if (todoText !== "") {
                // 1. Создаем новый элемент списка (li)
                const listItem = document.createElement("li");

                // 2. Добавляем текст задачи в li
                listItem.textContent = todoText;

                // 3. Создаем кнопку "Удалить"
                const deleteButton = document.createElement("button");
                deleteButton.textContent = "Удалить";

                // 4. Добавляем обработчик события для кнопки "Удалить"
                deleteButton.addEventListener("click", () => {
                    listItem.remove(); // Удаляем родительский элемент (li)
                });

                // 5. Добавляем кнопку "Удалить" в элемент списка
                listItem.appendChild(deleteButton);

                // 6. Добавляем новый элемент списка в ul
                todoList.appendChild(listItem);

                // 7. Очищаем поле ввода
                todoInput.value = "";
            }
        });

        // Дополнительно: добавление задачи по нажатию Enter в поле ввода
        todoInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
                addTodoBtn.click(); // Имитируем клик по кнопке "Добавить"
            }
        });
    </script>
</body>
</html>
<p>```</p>
<p>Манипуляции с DOM являются одной из самых частых задач в веб-разработке на JavaScript. Понимание этих методов позволяет создавать динамические и интерактивные пользовательские интерфейсы, которые реагируют на действия пользователя и изменяют содержимое страницы в реальном времени.</p>
<hr />
<h1>Лекция: Модель DOM (Document Object Model)</h1>
<h2>Введение в DOM</h2>
<p>Document Object Model (DOM) представляет собой программный интерфейс для HTML и XML документов. DOM определяет логическую структуру документов и способы доступа к ним и их изменения. Понимание DOM является фундаментальным для любого веб-разработчика, поскольку именно через DOM JavaScript взаимодействует с веб-страницами.</p>
<p>DOM представляет документ как дерево объектов, где каждый элемент HTML становится узлом в этом дереве. Это позволяет программам и скриптам динамически получать доступ к содержимому, структуре и стилю документа, а также изменять их. DOM является платформо- и языково-независимым интерфейсом, который позволяет программам и скриптам динамически получать доступ к документу и обновлять его содержимое, структуру и стиль.</p>
<p>Важно понимать, что DOM не является частью языка JavaScript. Это отдельный API (Application Programming Interface), который предоставляется браузером. JavaScript использует DOM API для взаимодействия с веб-страницами. Когда браузер загружает HTML-документ, он создает DOM-представление этого документа в памяти, которое затем может быть изменено с помощью JavaScript.</p>
<h2>Структура DOM</h2>
<p>DOM представляет HTML-документ в виде иерархического дерева узлов. Каждый элемент HTML, атрибут, текстовое содержимое и даже комментарии становятся узлами в этом дереве. Понимание этой структуры критически важно для эффективной работы с DOM.</p>
<h3>Типы узлов</h3>
<p>В DOM существует несколько типов узлов, каждый из которых имеет свое назначение и свойства:</p>
<p><strong>Element Node (Узел элемента)</strong> - представляет HTML-элементы, такие как <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;img&gt;</code> и другие. Это наиболее часто используемый тип узлов при работе с DOM. Узлы элементов могут содержать другие узлы в качестве дочерних элементов.</p>
<p><strong>Text Node (Текстовый узел)</strong> - содержит текстовое содержимое элементов. Важно понимать, что текст внутри HTML-элементов представлен отдельными узлами. Например, в элементе <code>&lt;p&gt;Привет, мир!&lt;/p&gt;</code> текст "Привет, мир!" является отдельным текстовым узлом.</p>
<p><strong>Attribute Node (Узел атрибута)</strong> - представляет атрибуты HTML-элементов, такие как <code>id</code>, <code>class</code>, <code>src</code> и другие. Хотя атрибуты технически являются узлами, в современном DOM API они обычно обрабатываются как свойства элементов.</p>
<p><strong>Comment Node (Узел комментария)</strong> - представляет HTML-комментарии. Комментарии также являются частью DOM-дерева, хотя они не отображаются на странице.</p>
<p><strong>Document Node (Узел документа)</strong> - корневой узел всего документа. Это точка входа в DOM-дерево, через которую можно получить доступ ко всем остальным узлам.</p>
<h3>Иерархия узлов</h3>
<p>DOM-дерево имеет четкую иерархическую структуру с отношениями родитель-потомок между узлами. Каждый узел может иметь родительский узел (parent), дочерние узлы (children) и соседние узлы (siblings).</p>
<p>Корневым элементом HTML-документа является элемент <code>&lt;html&gt;</code>, который содержит два основных дочерних элемента: <code>&lt;head&gt;</code> и <code>&lt;body&gt;</code>. Элемент <code>&lt;head&gt;</code> содержит метаинформацию о документе, такую как заголовок, ссылки на стили и скрипты. Элемент <code>&lt;body&gt;</code> содержит видимое содержимое страницы.</p>
<p>Каждый элемент в DOM-дереве может содержать другие элементы, создавая вложенную структуру. Например, элемент <code>&lt;div&gt;</code> может содержать элементы <code>&lt;p&gt;</code>, которые, в свою очередь, могут содержать элементы <code>&lt;span&gt;</code> или <code>&lt;a&gt;</code>. Эта иерархическая структура позволяет организовать содержимое страницы логическим образом.</p>
<h2>Доступ к элементам DOM</h2>
<p>JavaScript предоставляет множество методов для поиска и получения доступа к элементам DOM. Выбор правильного метода зависит от конкретной задачи и структуры документа.</p>
<h3>Методы поиска элементов</h3>
<p><strong>getElementById()</strong> - один из самых быстрых и часто используемых методов. Он возвращает элемент с указанным значением атрибута <code>id</code>. Поскольку <code>id</code> должен быть уникальным в пределах документа, этот метод всегда возвращает либо один элемент, либо <code>null</code>, если элемент не найден.</p>
<p><code>javascript
const element = document.getElementById(\'myElement\');
if (element) {
    // Элемент найден, можно с ним работать
    console.log(element.textContent);
}</code></p>
<p><strong>getElementsByClassName()</strong> - возвращает живую коллекцию элементов с указанным классом. Важно понимать, что возвращается HTMLCollection, а не массив, хотя к элементам можно обращаться по индексу.</p>
<p><code>javascript
const elements = document.getElementsByClassName(\'myClass\');
for (let i = 0; i &lt; elements.length; i++) {
    console.log(elements[i].textContent);
}</code></p>
<p><strong>getElementsByTagName()</strong> - возвращает коллекцию всех элементов с указанным именем тега. Этот метод полезен, когда нужно получить все элементы определенного типа, например, все параграфы или все изображения.</p>
<p><code>javascript
const paragraphs = document.getElementsByTagName(\'p\');
Array.from(paragraphs).forEach(p =&gt; {
    p.style.color = \'blue\';
});</code></p>
<p><strong>querySelector()</strong> - современный и мощный метод, который принимает CSS-селектор и возвращает первый найденный элемент. Этот метод поддерживает сложные селекторы, включая комбинаторы и псевдоклассы.</p>
<p><code>javascript
const element = document.querySelector(\'.container &gt; .item:first-child\');
const button = document.querySelector(\'button[type="submit"]\');</code></p>
<p><strong>querySelectorAll()</strong> - возвращает статическую NodeList всех элементов, соответствующих указанному CSS-селектору. В отличие от HTMLCollection, NodeList является статической, то есть она не обновляется автоматически при изменении DOM.</p>
<p><code>javascript
const items = document.querySelectorAll(\'.item\');
items.forEach(item =&gt; {
    item.addEventListener(\'click\', handleClick);
});</code></p>
<h3>Навигация по DOM</h3>
<p>После получения ссылки на элемент можно перемещаться по DOM-дереву, используя свойства навигации. Эти свойства позволяют получить доступ к родительским, дочерним и соседним элементам.</p>
<p><strong>parentNode</strong> и <strong>parentElement</strong> - предоставляют доступ к родительскому узлу. Разница в том, что <code>parentNode</code> может вернуть любой тип узла, а <code>parentElement</code> возвращает только элементы.</p>
<p><strong>childNodes</strong> - возвращает NodeList всех дочерних узлов, включая текстовые узлы и комментарии. <strong>children</strong> - возвращает HTMLCollection только дочерних элементов, исключая текстовые узлы.</p>
<p><strong>firstChild</strong> и <strong>lastChild</strong> - возвращают первый и последний дочерние узлы соответственно. <strong>firstElementChild</strong> и <strong>lastElementChild</strong> - возвращают первый и последний дочерние элементы.</p>
<p><strong>nextSibling</strong> и <strong>previousSibling</strong> - предоставляют доступ к следующему и предыдущему соседним узлам. <strong>nextElementSibling</strong> и <strong>previousElementSibling</strong> - работают только с элементами.</p>
<p><code>javascript
const element = document.getElementById(\'myElement\');
const parent = element.parentElement;
const children = element.children;
const nextElement = element.nextElementSibling;</code></p>
<h2>Изменение содержимого элементов</h2>
<p>DOM API предоставляет несколько способов изменения содержимого элементов. Выбор метода зависит от типа содержимого и требований безопасности.</p>
<h3>Свойства для работы с содержимым</h3>
<p><strong>innerHTML</strong> - позволяет получать и устанавливать HTML-содержимое элемента. Это мощный инструмент, который может интерпретировать HTML-теги и создавать соответствующие элементы DOM.</p>
<p><code>javascript
const container = document.getElementById(\'container\');
container.innerHTML = \'&lt;p&gt;Новый &lt;strong&gt;параграф&lt;/strong&gt;&lt;/p&gt;\';</code></p>
<p>Однако использование <code>innerHTML</code> требует осторожности, особенно при работе с пользовательским вводом, поскольку это может привести к XSS-атакам. Всегда следует санитизировать данные перед вставкой их через <code>innerHTML</code>.</p>
<p><strong>textContent</strong> - устанавливает или возвращает текстовое содержимое элемента и всех его потомков. HTML-теги интерпретируются как обычный текст и не создают элементы DOM.</p>
<p><code>javascript
const element = document.getElementById(\'myElement\');
element.textContent = \'Простой текст без HTML\';</code></p>
<p><strong>innerText</strong> - похож на <code>textContent</code>, но учитывает стили CSS и не возвращает скрытый текст. Также <code>innerText</code> учитывает переносы строк и форматирование.</p>
<p><code>javascript
const element = document.getElementById(\'myElement\');
element.innerText = \'Текст с учетом стилей\';</code></p>
<h3>Работа с атрибутами</h3>
<p>Атрибуты HTML-элементов можно читать и изменять с помощью специальных методов DOM API.</p>
<p><strong>getAttribute()</strong> и <strong>setAttribute()</strong> - универсальные методы для работы с любыми атрибутами элементов.</p>
<p><code>javascript
const image = document.querySelector(\'img\');
const src = image.getAttribute(\'src\');
image.setAttribute(\'alt\', \'Новое описание изображения\');</code></p>
<p><strong>removeAttribute()</strong> - удаляет указанный атрибут из элемента.</p>
<p><code>javascript
const element = document.getElementById(\'myElement\');
element.removeAttribute(\'disabled\');</code></p>
<p><strong>hasAttribute()</strong> - проверяет наличие указанного атрибута.</p>
<p><code>javascript
if (element.hasAttribute(\'data-value\')) {
    const value = element.getAttribute(\'data-value\');
}</code></p>
<p>Многие стандартные HTML-атрибуты также доступны как свойства элементов:</p>
<p><code>javascript
const input = document.querySelector(\'input\');
input.value = \'Новое значение\';
input.disabled = true;
input.className = \'new-class\';</code></p>
<h2>Изменение стилей элементов</h2>
<p>DOM предоставляет несколько способов изменения внешнего вида элементов через CSS-стили.</p>
<h3>Свойство style</h3>
<p>Каждый элемент DOM имеет свойство <code>style</code>, которое представляет объект CSSStyleDeclaration. Через это свойство можно устанавливать inline-стили элемента.</p>
<p><code>javascript
const element = document.getElementById(\'myElement\');
element.style.backgroundColor = \'red\';
element.style.fontSize = \'20px\';
element.style.marginTop = \'10px\';</code></p>
<p>Важно отметить, что имена CSS-свойств в JavaScript записываются в camelCase формате. Например, <code>background-color</code> становится <code>backgroundColor</code>, а <code>font-size</code> становится <code>fontSize</code>.</p>
<p>Для CSS-свойств, которые содержат дефисы, можно также использовать метод <code>setProperty()</code>:</p>
<p><code>javascript
element.style.setProperty(\'background-color\', \'blue\');
element.style.setProperty(\'--custom-property\', \'value\');</code></p>
<h3>Работа с классами CSS</h3>
<p>Управление CSS-классами является предпочтительным способом изменения стилей, поскольку это разделяет логику и представление.</p>
<p><strong>className</strong> - свойство, которое содержит строку со всеми классами элемента.</p>
<p><code>javascript
const element = document.getElementById(\'myElement\');
element.className = \'new-class another-class\';</code></p>
<p><strong>classList</strong> - более удобный объект для работы с классами, предоставляющий методы для добавления, удаления и переключения классов.</p>
<p>```javascript
const element = document.getElementById(\'myElement\');</p>
<p>// Добавление класса
element.classList.add(\'active\');</p>
<p>// Удаление класса
element.classList.remove(\'hidden\');</p>
<p>// Переключение класса
element.classList.toggle(\'visible\');</p>
<p>// Проверка наличия класса
if (element.classList.contains(\'active\')) {
    console.log(\'Элемент активен\');
}</p>
<p>// Замена класса
element.classList.replace(\'old-class\', \'new-class\');
```</p>
<h2>Создание и удаление элементов</h2>
<p>DOM API позволяет динамически создавать новые элементы и удалять существующие, что открывает возможности для создания интерактивных веб-приложений.</p>
<h3>Создание элементов</h3>
<p><strong>createElement()</strong> - основной метод для создания новых элементов DOM.</p>
<p><code>javascript
const newDiv = document.createElement(\'div\');
newDiv.textContent = \'Новый элемент\';
newDiv.className = \'dynamic-element\';</code></p>
<p><strong>createTextNode()</strong> - создает новый текстовый узел.</p>
<p><code>javascript
const textNode = document.createTextNode(\'Простой текст\');</code></p>
<p><strong>cloneNode()</strong> - создает копию существующего элемента.</p>
<p><code>javascript
const original = document.getElementById(\'template\');
const copy = original.cloneNode(true); // true для глубокого копирования</code></p>
<h3>Добавление элементов в DOM</h3>
<p>После создания элемента его нужно добавить в DOM-дерево, чтобы он стал видимым на странице.</p>
<p><strong>appendChild()</strong> - добавляет элемент в конец списка дочерних элементов.</p>
<p><code>javascript
const container = document.getElementById(\'container\');
const newElement = document.createElement(\'p\');
newElement.textContent = \'Новый параграф\';
container.appendChild(newElement);</code></p>
<p><strong>insertBefore()</strong> - вставляет элемент перед указанным дочерним элементом.</p>
<p><code>javascript
const container = document.getElementById(\'container\');
const newElement = document.createElement(\'p\');
const referenceElement = container.firstElementChild;
container.insertBefore(newElement, referenceElement);</code></p>
<p><strong>insertAdjacentElement()</strong> - современный метод для вставки элементов в различные позиции.</p>
<p>```javascript
const element = document.getElementById(\'myElement\');
const newElement = document.createElement(\'div\');</p>
<p>// Вставка в различные позиции
element.insertAdjacentElement(\'beforebegin\', newElement); // Перед элементом
element.insertAdjacentElement(\'afterbegin\', newElement);  // В начало элемента
element.insertAdjacentElement(\'beforeend\', newElement);   // В конец элемента
element.insertAdjacentElement(\'afterend\', newElement);    // После элемента
```</p>
<h3>Удаление элементов</h3>
<p><strong>removeChild()</strong> - традиционный метод удаления дочернего элемента.</p>
<p><code>javascript
const container = document.getElementById(\'container\');
const elementToRemove = document.getElementById(\'removeMe\');
container.removeChild(elementToRemove);</code></p>
<p><strong>remove()</strong> - современный метод, который позволяет элементу удалить себя.</p>
<p><code>javascript
const element = document.getElementById(\'removeMe\');
element.remove();</code></p>
<p><strong>replaceChild()</strong> - заменяет один дочерний элемент другим.</p>
<p><code>javascript
const container = document.getElementById(\'container\');
const oldElement = document.getElementById(\'old\');
const newElement = document.createElement(\'div\');
container.replaceChild(newElement, oldElement);</code></p>
<h2>Обработка событий</h2>
<p>События являются основой интерактивности веб-страниц. DOM предоставляет мощную систему событий, которая позволяет реагировать на действия пользователя и изменения в документе.</p>
<h3>Типы событий</h3>
<p>Существует множество типов событий, каждый из которых соответствует определенному действию или изменению состояния:</p>
<p><strong>События мыши</strong> включают <code>click</code>, <code>dblclick</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mouseover</code>, <code>mouseout</code>, <code>mousemove</code>. Эти события позволяют реагировать на взаимодействие пользователя с элементами через мышь.</p>
<p><strong>События клавиатуры</strong> включают <code>keydown</code>, <code>keyup</code>, <code>keypress</code>. Они позволяют обрабатывать ввод с клавиатуры и создавать горячие клавиши.</p>
<p><strong>События формы</strong> включают <code>submit</code>, <code>change</code>, <code>input</code>, <code>focus</code>, <code>blur</code>. Эти события критически важны для работы с формами и валидации пользовательского ввода.</p>
<p><strong>События загрузки</strong> включают <code>load</code>, <code>DOMContentLoaded</code>, <code>unload</code>, <code>beforeunload</code>. Они позволяют выполнять код в определенные моменты жизненного цикла страницы.</p>
<h3>Добавление обработчиков событий</h3>
<p><strong>addEventListener()</strong> - рекомендуемый способ добавления обработчиков событий.</p>
<p>```javascript
const button = document.getElementById(\'myButton\');</p>
<p>button.addEventListener(\'click\', function(event) {
    console.log(\'Кнопка была нажата!\');
    console.log(\'Событие:\', event);
});</p>
<p>// Можно также использовать стрелочные функции
button.addEventListener(\'click\', (event) =&gt; {
    event.preventDefault(); // Предотвращение действия по умолчанию
    console.log(\'Обработчик события\');
});
```</p>
<p><strong>Объект события</strong> содержит информацию о произошедшем событии и предоставляет методы для управления его поведением:</p>
<p>```javascript
element.addEventListener(\'click\', function(event) {
    console.log(\'Тип события:\', event.type);
    console.log(\'Целевой элемент:\', event.target);
    console.log(\'Текущий элемент:\', event.currentTarget);
    console.log(\'Координаты мыши:\', event.clientX, event.clientY);</p>
<pre><code>// Предотвращение действия по умолчанию
event.preventDefault();

// Остановка всплытия события
event.stopPropagation();
</code></pre>
<p>});
```</p>
<h3>Всплытие и погружение событий</h3>
<p>События в DOM проходят через три фазы: погружение (capturing), достижение цели (target) и всплытие (bubbling). Понимание этого механизма важно для эффективной обработки событий.</p>
<p><strong>Фаза погружения</strong> - событие распространяется от корня документа к целевому элементу. <strong>Фаза цели</strong> - событие достигает элемента, на котором оно произошло. <strong>Фаза всплытия</strong> - событие поднимается от целевого элемента обратно к корню документа.</p>
<p>```javascript
// Обработчик на фазе всплытия (по умолчанию)
element.addEventListener(\'click\', handler);</p>
<p>// Обработчик на фазе погружения
element.addEventListener(\'click\', handler, true);</p>
<p>// Современный синтаксис с объектом опций
element.addEventListener(\'click\', handler, {
    capture: true,  // Фаза погружения
    once: true,     // Выполнить только один раз
    passive: true   // Пассивный обработчик
});
```</p>
<h3>Делегирование событий</h3>
<p>Делегирование событий - это техника, при которой обработчик события добавляется к родительскому элементу вместо добавления обработчиков к каждому дочернему элементу. Это особенно полезно для динамически создаваемых элементов.</p>
<p>```javascript
const container = document.getElementById(\'container\');</p>
<p>container.addEventListener(\'click\', function(event) {
    if (event.target.classList.contains(\'button\')) {
        console.log(\'Нажата кнопка:\', event.target.textContent);
    }</p>
<pre><code>if (event.target.tagName === \'LI\') {
    console.log(\'Выбран элемент списка:\', event.target.textContent);
}
</code></pre>
<p>});
```</p>
<h2>Практические примеры</h2>
<p>Рассмотрим несколько практических примеров, демонстрирующих применение изученных концепций DOM.</p>
<h3>Пример 1: Динамический список задач</h3>
<p>```javascript
class TodoList {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.tasks = [];
        this.init();
    }</p>
<pre><code>init() {
    this.createInterface();
    this.bindEvents();
}

createInterface() {
    this.container.innerHTML = `
        &lt;div class="todo-app"&gt;
            &lt;h2&gt;Список задач&lt;/h2&gt;
            &lt;div class="input-group"&gt;
                &lt;input type="text" id="taskInput" placeholder="Введите новую задачу"&gt;
                &lt;button id="addButton"&gt;Добавить&lt;/button&gt;
            &lt;/div&gt;
            &lt;ul id="taskList"&gt;&lt;/ul&gt;
        &lt;/div&gt;
    `;
}

bindEvents() {
    const addButton = this.container.querySelector(\'#addButton\');
    const taskInput = this.container.querySelector(\'#taskInput\');

    addButton.addEventListener(\'click\', () =&gt; this.addTask());
    taskInput.addEventListener(\'keypress\', (e) =&gt; {
        if (e.key === \'Enter\') this.addTask();
    });

    // Делегирование событий для кнопок задач
    const taskList = this.container.querySelector(\'#taskList\');
    taskList.addEventListener(\'click\', (e) =&gt; {
        if (e.target.classList.contains(\'delete-btn\')) {
            this.deleteTask(e.target.dataset.id);
        } else if (e.target.classList.contains(\'toggle-btn\')) {
            this.toggleTask(e.target.dataset.id);
        }
    });
}

addTask() {
    const input = this.container.querySelector(\'#taskInput\');
    const text = input.value.trim();

    if (text) {
        const task = {
            id: Date.now(),
            text: text,
            completed: false
        };

        this.tasks.push(task);
        this.renderTasks();
        input.value = \'\';
    }
}

deleteTask(id) {
    this.tasks = this.tasks.filter(task =&gt; task.id != id);
    this.renderTasks();
}

toggleTask(id) {
    const task = this.tasks.find(task =&gt; task.id == id);
    if (task) {
        task.completed = !task.completed;
        this.renderTasks();
    }
}

renderTasks() {
    const taskList = this.container.querySelector(\'#taskList\');

    taskList.innerHTML = this.tasks.map(task =&gt; `
        &lt;li class="task-item ${task.completed ? \'completed\' : \'\'}"&gt;
            &lt;span class="task-text"&gt;${task.text}&lt;/span&gt;
            &lt;div class="task-buttons"&gt;
                &lt;button class="toggle-btn" data-id="${task.id}"&gt;
                    ${task.completed ? \'Отменить\' : \'Выполнить\'}
                &lt;/button&gt;
                &lt;button class="delete-btn" data-id="${task.id}"&gt;Удалить&lt;/button&gt;
            &lt;/div&gt;
        &lt;/li&gt;
    `).join(\'\');
}
</code></pre>
<p>}</p>
<p>// Использование
const todoList = new TodoList(\'todoContainer\');
```</p>
<h3>Пример 2: Интерактивная галерея изображений</h3>
<p>```javascript
class ImageGallery {
    constructor(containerId, images) {
        this.container = document.getElementById(containerId);
        this.images = images;
        this.currentIndex = 0;
        this.init();
    }</p>
<pre><code>init() {
    this.createGallery();
    this.bindEvents();
    this.showImage(0);
}

createGallery() {
    this.container.innerHTML = `
        &lt;div class="gallery"&gt;
            &lt;div class="main-image"&gt;
                &lt;img id="currentImage" src="" alt=""&gt;
                &lt;div class="image-controls"&gt;
                    &lt;button id="prevBtn"&gt;‹ Предыдущая&lt;/button&gt;
                    &lt;span id="imageCounter"&gt;&lt;/span&gt;
                    &lt;button id="nextBtn"&gt;Следующая ›&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="thumbnails" id="thumbnails"&gt;&lt;/div&gt;
        &lt;/div&gt;
    `;

    this.createThumbnails();
}

createThumbnails() {
    const thumbnailsContainer = this.container.querySelector(\'#thumbnails\');

    this.images.forEach((image, index) =&gt; {
        const thumbnail = document.createElement(\'img\');
        thumbnail.src = image.thumbnail || image.src;
        thumbnail.alt = image.alt;
        thumbnail.className = \'thumbnail\';
        thumbnail.dataset.index = index;

        thumbnailsContainer.appendChild(thumbnail);
    });
}

bindEvents() {
    const prevBtn = this.container.querySelector(\'#prevBtn\');
    const nextBtn = this.container.querySelector(\'#nextBtn\');
    const thumbnails = this.container.querySelector(\'#thumbnails\');

    prevBtn.addEventListener(\'click\', () =&gt; this.previousImage());
    nextBtn.addEventListener(\'click\', () =&gt; this.nextImage());

    thumbnails.addEventListener(\'click\', (e) =&gt; {
        if (e.target.classList.contains(\'thumbnail\')) {
            this.showImage(parseInt(e.target.dataset.index));
        }
    });

    // Клавиатурная навигация
    document.addEventListener(\'keydown\', (e) =&gt; {
        if (e.key === \'ArrowLeft\') this.previousImage();
        if (e.key === \'ArrowRight\') this.nextImage();
    });
}

showImage(index) {
    if (index &gt;= 0 &amp;&amp; index &lt; this.images.length) {
        this.currentIndex = index;

        const currentImage = this.container.querySelector(\'#currentImage\');
        const imageCounter = this.container.querySelector(\'#imageCounter\');
        const thumbnails = this.container.querySelectorAll(\'.thumbnail\');

        currentImage.src = this.images[index].src;
        currentImage.alt = this.images[index].alt;

        imageCounter.textContent = `${index + 1} из ${this.images.length}`;

        // Обновление активной миниатюры
        thumbnails.forEach((thumb, i) =&gt; {
            thumb.classList.toggle(\'active\', i === index);
        });
    }
}

nextImage() {
    const nextIndex = (this.currentIndex + 1) % this.images.length;
    this.showImage(nextIndex);
}

previousImage() {
    const prevIndex = (this.currentIndex - 1 + this.images.length) % this.images.length;
    this.showImage(prevIndex);
}
</code></pre>
<p>}</p>
<p>// Использование
const images = [
    { src: \'image1.jpg\', alt: \'Описание 1\' },
    { src: \'image2.jpg\', alt: \'Описание 2\' },
    { src: \'image3.jpg\', alt: \'Описание 3\' }
];</p>
<p>const gallery = new ImageGallery(\'galleryContainer\', images);
```</p>
<h3>Пример 3: Форма с валидацией</h3>
<p>```javascript
class FormValidator {
    constructor(formId) {
        this.form = document.getElementById(formId);
        this.rules = {};
        this.init();
    }</p>
<pre><code>init() {
    this.bindEvents();
}

addRule(fieldName, validator, message) {
    if (!this.rules[fieldName]) {
        this.rules[fieldName] = [];
    }
    this.rules[fieldName].push({ validator, message });
}

bindEvents() {
    this.form.addEventListener(\'submit\', (e) =&gt; {
        e.preventDefault();
        this.validateForm();
    });

    // Валидация в реальном времени
    this.form.addEventListener(\'input\', (e) =&gt; {
        if (e.target.tagName === \'INPUT\' || e.target.tagName === \'TEXTAREA\') {
            this.validateField(e.target);
        }
    });

    this.form.addEventListener(\'blur\', (e) =&gt; {
        if (e.target.tagName === \'INPUT\' || e.target.tagName === \'TEXTAREA\') {
            this.validateField(e.target);
        }
    }, true);
}

validateField(field) {
    const fieldName = field.name;
    const value = field.value;
    const rules = this.rules[fieldName];

    if (!rules) return true;

    let isValid = true;
    let errorMessage = \'\';

    for (const rule of rules) {
        if (!rule.validator(value)) {
            isValid = false;
            errorMessage = rule.message;
            break;
        }
    }

    this.showFieldError(field, isValid ? \'\' : errorMessage);
    return isValid;
}

validateForm() {
    let isFormValid = true;
    const formData = new FormData(this.form);

    // Валидация всех полей
    for (const [fieldName] of formData) {
        const field = this.form.querySelector(`[name="${fieldName}"]`);
        if (field &amp;&amp; !this.validateField(field)) {
            isFormValid = false;
        }
    }

    if (isFormValid) {
        this.onSuccess(formData);
    } else {
        this.onError();
    }
}

showFieldError(field, message) {
    // Удаление предыдущих сообщений об ошибках
    const existingError = field.parentNode.querySelector(\'.error-message\');
    if (existingError) {
        existingError.remove();
    }

    field.classList.toggle(\'error\', !!message);
    field.classList.toggle(\'valid\', !message &amp;&amp; field.value);

    if (message) {
        const errorElement = document.createElement(\'div\');
        errorElement.className = \'error-message\';
        errorElement.textContent = message;
        field.parentNode.appendChild(errorElement);
    }
}

onSuccess(formData) {
    console.log(\'Форма валидна!\', Object.fromEntries(formData));
    // Здесь можно отправить данные на сервер
}

onError() {
    console.log(\'Форма содержит ошибки\');
}
</code></pre>
<p>}</p>
<p>// Использование
const validator = new FormValidator(\'myForm\');</p>
<p>// Добавление правил валидации
validator.addRule(\'email\', 
    value =&gt; /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
    \'Введите корректный email адрес\'
);</p>
<p>validator.addRule(\'password\',
    value =&gt; value.length &gt;= 8,
    \'Пароль должен содержать минимум 8 символов\'
);</p>
<p>validator.addRule(\'name\',
    value =&gt; value.trim().length &gt;= 2,
    \'Имя должно содержать минимум 2 символа\'
);
```</p>
<h2>Лучшие практики работы с DOM</h2>
<p>При работе с DOM важно следовать определенным принципам и лучшим практикам, которые обеспечивают производительность, безопасность и поддерживаемость кода.</p>
<h3>Производительность</h3>
<p><strong>Минимизация обращений к DOM</strong> - операции с DOM являются относительно медленными, поэтому следует минимизировать количество обращений к нему. Кэшируйте ссылки на часто используемые элементы.</p>
<p>```javascript
// Плохо - множественные обращения к DOM
for (let i = 0; i &lt; 100; i++) {
    document.getElementById(\'counter\').textContent = i;
}</p>
<p>// Хорошо - кэширование ссылки
const counter = document.getElementById(\'counter\');
for (let i = 0; i &lt; 100; i++) {
    counter.textContent = i;
}
```</p>
<p><strong>Пакетные изменения DOM</strong> - группируйте изменения DOM для минимизации перерисовки страницы.</p>
<p>```javascript
// Плохо - множественные изменения
element.style.width = \'100px\';
element.style.height = \'100px\';
element.style.backgroundColor = \'red\';</p>
<p>// Хорошо - одно изменение через класс
element.className = \'new-style\';</p>
<p>// Или через cssText
element.style.cssText = \'width: 100px; height: 100px; background-color: red;\';
```</p>
<p><strong>Использование DocumentFragment</strong> для создания множественных элементов.</p>
<p><code>javascript
const fragment = document.createDocumentFragment();
for (let i = 0; i &lt; 100; i++) {
    const li = document.createElement(\'li\');
    li.textContent = `Элемент ${i}`;
    fragment.appendChild(li);
}
document.getElementById(\'list\').appendChild(fragment);</code></p>
<h3>Безопасность</h3>
<p><strong>Избегайте innerHTML с пользовательскими данными</strong> - это может привести к XSS-атакам.</p>
<p>```javascript
// Опасно
element.innerHTML = userInput;</p>
<p>// Безопасно
element.textContent = userInput;</p>
<p>// Или с санитизацией
element.innerHTML = sanitizeHTML(userInput);
```</p>
<p><strong>Валидация данных</strong> - всегда проверяйте данные перед их использованием.</p>
<p><code>javascript
function safeGetElement(id) {
    const element = document.getElementById(id);
    if (!element) {
        throw new Error(`Элемент с ID "${id}" не найден`);
    }
    return element;
}</code></p>
<h3>Поддерживаемость кода</h3>
<p><strong>Разделение логики и представления</strong> - используйте CSS-классы вместо прямого изменения стилей.</p>
<p>```javascript
// Плохо
element.style.display = \'none\';</p>
<p>// Хорошо
element.classList.add(\'hidden\');
```</p>
<p><strong>Использование делегирования событий</strong> для динамических элементов.</p>
<p><strong>Создание переиспользуемых компонентов</strong> - инкапсулируйте логику в классы или функции.</p>
<h2>Современные возможности DOM API</h2>
<p>Современные браузеры предоставляют множество новых возможностей для работы с DOM, которые упрощают разработку и повышают производительность.</p>
<h3>Intersection Observer API</h3>
<p>Позволяет асинхронно отслеживать пересечения элементов с viewport или другими элементами.</p>
<p>```javascript
const observer = new IntersectionObserver((entries) =&gt; {
    entries.forEach(entry =&gt; {
        if (entry.isIntersecting) {
            entry.target.classList.add(\'visible\');
        }
    });
});</p>
<p>document.querySelectorAll(\'.animate-on-scroll\').forEach(el =&gt; {
    observer.observe(el);
});
```</p>
<h3>Mutation Observer API</h3>
<p>Позволяет отслеживать изменения в DOM-дереве.</p>
<p>```javascript
const observer = new MutationObserver((mutations) =&gt; {
    mutations.forEach(mutation =&gt; {
        if (mutation.type === \'childList\') {
            console.log(\'Добавлены или удалены дочерние элементы\');
        }
        if (mutation.type === \'attributes\') {
            console.log(\'Изменены атрибуты элемента\');
        }
    });
});</p>
<p>observer.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true
});
```</p>
<h3>Resize Observer API</h3>
<p>Отслеживает изменения размеров элементов.</p>
<p>```javascript
const resizeObserver = new ResizeObserver(entries =&gt; {
    entries.forEach(entry =&gt; {
        console.log(\'Размер элемента изменился:\', entry.contentRect);
    });
});</p>
<p>resizeObserver.observe(document.getElementById(\'resizable\'));
```</p>
<h3>Web Components</h3>
<p>Современный стандарт для создания переиспользуемых компонентов.</p>
<p>```javascript
class CustomButton extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: \'open\' });
    }</p>
<pre><code>connectedCallback() {
    this.shadowRoot.innerHTML = `
        &lt;style&gt;
            button {
                background: var(--button-bg, #007bff);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                cursor: pointer;
            }
            button:hover {
                opacity: 0.8;
            }
        &lt;/style&gt;
        &lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
    `;

    this.shadowRoot.querySelector(\'button\').addEventListener(\'click\', () =&gt; {
        this.dispatchEvent(new CustomEvent(\'custom-click\', {
            detail: { message: \'Кнопка нажата!\' }
        }));
    });
}
</code></pre>
<p>}</p>
<p>customElements.define(\'custom-button\', CustomButton);
```</p>
<h2>Заключение</h2>
<p>Document Object Model является фундаментальной технологией веб-разработки, которая обеспечивает мост между статическим HTML и динамическим JavaScript. Понимание DOM критически важно для создания интерактивных веб-приложений.</p>
<p>Основные принципы работы с DOM включают понимание его древовидной структуры, эффективные методы поиска и изменения элементов, правильную обработку событий и следование лучшим практикам производительности и безопасности.</p>
<p>Современные возможности DOM API, такие как Observer APIs и Web Components, открывают новые горизонты для создания сложных и производительных веб-приложений. Важно оставаться в курсе этих развивающихся технологий и применять их в соответствующих контекстах.</p>
<p>Практическое применение знаний DOM требует постоянной практики и экспериментирования. Создавайте небольшие проекты, изучайте исходный код существующих приложений и не бойтесь экспериментировать с новыми возможностями API.</p>
<p>Помните, что DOM - это живая технология, которая продолжает развиваться. Следите за новыми спецификациями и возможностями, которые появляются в современных браузерах, и адаптируйте свои знания соответственно.</p>
<h1>Лекция: Модель DOM (Document Object Model)</h1>
<h2>Введение в DOM</h2>
<p>Document Object Model (DOM) представляет собой программный интерфейс для HTML и XML документов. DOM определяет логическую структуру документов и способы доступа к ним и их изменения. Понимание DOM является фундаментальным для любого веб-разработчика, поскольку именно через DOM JavaScript взаимодействует с веб-страницами.</p>
<p>DOM представляет документ как дерево объектов, где каждый элемент HTML становится узлом в этом дереве. Это позволяет программам и скриптам динамически получать доступ к содержимому, структуре и стилю документа, а также изменять их. DOM является платформо- и языково-независимым интерфейсом, который позволяет программам и скриптам динамически получать доступ к документу и обновлять его содержимое, структуру и стиль.</p>
<p>Важно понимать, что DOM не является частью языка JavaScript. Это отдельный API (Application Programming Interface), который предоставляется браузером. JavaScript использует DOM API для взаимодействия с веб-страницами. Когда браузер загружает HTML-документ, он создает DOM-представление этого документа в памяти, которое затем может быть изменено с помощью JavaScript.</p>
<h2>Структура DOM</h2>
<p>DOM представляет HTML-документ в виде иерархического дерева узлов. Каждый элемент HTML, атрибут, текстовое содержимое и даже комментарии становятся узлами в этом дереве. Понимание этой структуры критически важно для эффективной работы с DOM.</p>
<h3>Типы узлов</h3>
<p>В DOM существует несколько типов узлов, каждый из которых имеет свое назначение и свойства:</p>
<p><strong>Element Node (Узел элемента)</strong> - представляет HTML-элементы, такие как <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;img&gt;</code> и другие. Это наиболее часто используемый тип узлов при работе с DOM. Узлы элементов могут содержать другие узлы в качестве дочерних элементов.</p>
<p><strong>Text Node (Текстовый узел)</strong> - содержит текстовое содержимое элементов. Важно понимать, что текст внутри HTML-элементов представлен отдельными узлами. Например, в элементе <code>&lt;p&gt;Привет, мир!&lt;/p&gt;</code> текст "Привет, мир!" является отдельным текстовым узлом.</p>
<p><strong>Attribute Node (Узел атрибута)</strong> - представляет атрибуты HTML-элементов, такие как <code>id</code>, <code>class</code>, <code>src</code> и другие. Хотя атрибуты технически являются узлами, в современном DOM API они обычно обрабатываются как свойства элементов.</p>
<p><strong>Comment Node (Узел комментария)</strong> - представляет HTML-комментарии. Комментарии также являются частью DOM-дерева, хотя они не отображаются на странице.</p>
<p><strong>Document Node (Узел документа)</strong> - корневой узел всего документа. Это точка входа в DOM-дерево, через которую можно получить доступ ко всем остальным узлам.</p>
<h3>Иерархия узлов</h3>
<p>DOM-дерево имеет четкую иерархическую структуру с отношениями родитель-потомок между узлами. Каждый узел может иметь родительский узел (parent), дочерние узлы (children) и соседние узлы (siblings).</p>
<p>Корневым элементом HTML-документа является элемент <code>&lt;html&gt;</code>, который содержит два основных дочерних элемента: <code>&lt;head&gt;</code> и <code>&lt;body&gt;</code>. Элемент <code>&lt;head&gt;</code> содержит метаинформацию о документе, такую как заголовок, ссылки на стили и скрипты. Элемент <code>&lt;body&gt;</code> содержит видимое содержимое страницы.</p>
<p>Каждый элемент в DOM-дереве может содержать другие элементы, создавая вложенную структуру. Например, элемент <code>&lt;div&gt;</code> может содержать элементы <code>&lt;p&gt;</code>, которые, в свою очередь, могут содержать элементы <code>&lt;span&gt;</code> или <code>&lt;a&gt;</code>. Эта иерархическая структура позволяет организовать содержимое страницы логическим образом.</p>
<h2>Доступ к элементам DOM</h2>
<p>JavaScript предоставляет множество методов для поиска и получения доступа к элементам DOM. Выбор правильного метода зависит от конкретной задачи и структуры документа.</p>
<h3>Методы поиска элементов</h3>
<p><strong>getElementById()</strong> - один из самых быстрых и часто используемых методов. Он возвращает элемент с указанным значением атрибута <code>id</code>. Поскольку <code>id</code> должен быть уникальным в пределах документа, этот метод всегда возвращает либо один элемент, либо <code>null</code>, если элемент не найден.</p>
<p><code>javascript
const element = document.getElementById('myElement');
if (element) {
    // Элемент найден, можно с ним работать
    console.log(element.textContent);
}</code></p>
<p><strong>getElementsByClassName()</strong> - возвращает живую коллекцию элементов с указанным классом. Важно понимать, что возвращается HTMLCollection, а не массив, хотя к элементам можно обращаться по индексу.</p>
<p><code>javascript
const elements = document.getElementsByClassName('myClass');
for (let i = 0; i &lt; elements.length; i++) {
    console.log(elements[i].textContent);
}</code></p>
<p><strong>getElementsByTagName()</strong> - возвращает коллекцию всех элементов с указанным именем тега. Этот метод полезен, когда нужно получить все элементы определенного типа, например, все параграфы или все изображения.</p>
<p><code>javascript
const paragraphs = document.getElementsByTagName('p');
Array.from(paragraphs).forEach(p =&gt; {
    p.style.color = 'blue';
});</code></p>
<p><strong>querySelector()</strong> - современный и мощный метод, который принимает CSS-селектор и возвращает первый найденный элемент. Этот метод поддерживает сложные селекторы, включая комбинаторы и псевдоклассы.</p>
<p><code>javascript
const element = document.querySelector('.container &gt; .item:first-child');
const button = document.querySelector('button[type="submit"]');</code></p>
<p><strong>querySelectorAll()</strong> - возвращает статическую NodeList всех элементов, соответствующих указанному CSS-селектору. В отличие от HTMLCollection, NodeList является статической, то есть она не обновляется автоматически при изменении DOM.</p>
<p><code>javascript
const items = document.querySelectorAll('.item');
items.forEach(item =&gt; {
    item.addEventListener('click', handleClick);
});</code></p>
<h3>Навигация по DOM</h3>
<p>После получения ссылки на элемент можно перемещаться по DOM-дереву, используя свойства навигации. Эти свойства позволяют получить доступ к родительским, дочерним и соседним элементам.</p>
<p><strong>parentNode</strong> и <strong>parentElement</strong> - предоставляют доступ к родительскому узлу. Разница в том, что <code>parentNode</code> может вернуть любой тип узла, а <code>parentElement</code> возвращает только элементы.</p>
<p><strong>childNodes</strong> - возвращает NodeList всех дочерних узлов, включая текстовые узлы и комментарии. <strong>children</strong> - возвращает HTMLCollection только дочерних элементов, исключая текстовые узлы.</p>
<p><strong>firstChild</strong> и <strong>lastChild</strong> - возвращают первый и последний дочерние узлы соответственно. <strong>firstElementChild</strong> и <strong>lastElementChild</strong> - возвращают первый и последний дочерние элементы.</p>
<p><strong>nextSibling</strong> и <strong>previousSibling</strong> - предоставляют доступ к следующему и предыдущему соседним узлам. <strong>nextElementSibling</strong> и <strong>previousElementSibling</strong> - работают только с элементами.</p>
<p><code>javascript
const element = document.getElementById('myElement');
const parent = element.parentElement;
const children = element.children;
const nextElement = element.nextElementSibling;</code></p>
<h2>Изменение содержимого элементов</h2>
<p>DOM API предоставляет несколько способов изменения содержимого элементов. Выбор метода зависит от типа содержимого и требований безопасности.</p>
<h3>Свойства для работы с содержимым</h3>
<p><strong>innerHTML</strong> - позволяет получать и устанавливать HTML-содержимое элемента. Это мощный инструмент, который может интерпретировать HTML-теги и создавать соответствующие элементы DOM.</p>
<p><code>javascript
const container = document.getElementById('container');
container.innerHTML = '&lt;p&gt;Новый &lt;strong&gt;параграф&lt;/strong&gt;&lt;/p&gt;';</code></p>
<p>Однако использование <code>innerHTML</code> требует осторожности, особенно при работе с пользовательским вводом, поскольку это может привести к XSS-атакам. Всегда следует санитизировать данные перед вставкой их через <code>innerHTML</code>.</p>
<p><strong>textContent</strong> - устанавливает или возвращает текстовое содержимое элемента и всех его потомков. HTML-теги интерпретируются как обычный текст и не создают элементы DOM.</p>
<p><code>javascript
const element = document.getElementById('myElement');
element.textContent = 'Простой текст без HTML';</code></p>
<p><strong>innerText</strong> - похож на <code>textContent</code>, но учитывает стили CSS и не возвращает скрытый текст. Также <code>innerText</code> учитывает переносы строк и форматирование.</p>
<p><code>javascript
const element = document.getElementById('myElement');
element.innerText = 'Текст с учетом стилей';</code></p>
<h3>Работа с атрибутами</h3>
<p>Атрибуты HTML-элементов можно читать и изменять с помощью специальных методов DOM API.</p>
<p><strong>getAttribute()</strong> и <strong>setAttribute()</strong> - универсальные методы для работы с любыми атрибутами элементов.</p>
<p><code>javascript
const image = document.querySelector('img');
const src = image.getAttribute('src');
image.setAttribute('alt', 'Новое описание изображения');</code></p>
<p><strong>removeAttribute()</strong> - удаляет указанный атрибут из элемента.</p>
<p><code>javascript
const element = document.getElementById('myElement');
element.removeAttribute('disabled');</code></p>
<p><strong>hasAttribute()</strong> - проверяет наличие указанного атрибута.</p>
<p><code>javascript
if (element.hasAttribute('data-value')) {
    const value = element.getAttribute('data-value');
}</code></p>
<p>Многие стандартные HTML-атрибуты также доступны как свойства элементов:</p>
<p><code>javascript
const input = document.querySelector('input');
input.value = 'Новое значение';
input.disabled = true;
input.className = 'new-class';</code></p>
<h2>Изменение стилей элементов</h2>
<p>DOM предоставляет несколько способов изменения внешнего вида элементов через CSS-стили.</p>
<h3>Свойство style</h3>
<p>Каждый элемент DOM имеет свойство <code>style</code>, которое представляет объект CSSStyleDeclaration. Через это свойство можно устанавливать inline-стили элемента.</p>
<p><code>javascript
const element = document.getElementById('myElement');
element.style.backgroundColor = 'red';
element.style.fontSize = '20px';
element.style.marginTop = '10px';</code></p>
<p>Важно отметить, что имена CSS-свойств в JavaScript записываются в camelCase формате. Например, <code>background-color</code> становится <code>backgroundColor</code>, а <code>font-size</code> становится <code>fontSize</code>.</p>
<p>Для CSS-свойств, которые содержат дефисы, можно также использовать метод <code>setProperty()</code>:</p>
<p><code>javascript
element.style.setProperty('background-color', 'blue');
element.style.setProperty('--custom-property', 'value');</code></p>
<h3>Работа с классами CSS</h3>
<p>Управление CSS-классами является предпочтительным способом изменения стилей, поскольку это разделяет логику и представление.</p>
<p><strong>className</strong> - свойство, которое содержит строку со всеми классами элемента.</p>
<p><code>javascript
const element = document.getElementById('myElement');
element.className = 'new-class another-class';</code></p>
<p><strong>classList</strong> - более удобный объект для работы с классами, предоставляющий методы для добавления, удаления и переключения классов.</p>
<p>```javascript
const element = document.getElementById('myElement');</p>
<p>// Добавление класса
element.classList.add('active');</p>
<p>// Удаление класса
element.classList.remove('hidden');</p>
<p>// Переключение класса
element.classList.toggle('visible');</p>
<p>// Проверка наличия класса
if (element.classList.contains('active')) {
    console.log('Элемент активен');
}</p>
<p>// Замена класса
element.classList.replace('old-class', 'new-class');
```</p>
<h2>Создание и удаление элементов</h2>
<p>DOM API позволяет динамически создавать новые элементы и удалять существующие, что открывает возможности для создания интерактивных веб-приложений.</p>
<h3>Создание элементов</h3>
<p><strong>createElement()</strong> - основной метод для создания новых элементов DOM.</p>
<p><code>javascript
const newDiv = document.createElement('div');
newDiv.textContent = 'Новый элемент';
newDiv.className = 'dynamic-element';</code></p>
<p><strong>createTextNode()</strong> - создает новый текстовый узел.</p>
<p><code>javascript
const textNode = document.createTextNode('Простой текст');</code></p>
<p><strong>cloneNode()</strong> - создает копию существующего элемента.</p>
<p><code>javascript
const original = document.getElementById('template');
const copy = original.cloneNode(true); // true для глубокого копирования</code></p>
<h3>Добавление элементов в DOM</h3>
<p>После создания элемента его нужно добавить в DOM-дерево, чтобы он стал видимым на странице.</p>
<p><strong>appendChild()</strong> - добавляет элемент в конец списка дочерних элементов.</p>
<p><code>javascript
const container = document.getElementById('container');
const newElement = document.createElement('p');
newElement.textContent = 'Новый параграф';
container.appendChild(newElement);</code></p>
<p><strong>insertBefore()</strong> - вставляет элемент перед указанным дочерним элементом.</p>
<p><code>javascript
const container = document.getElementById('container');
const newElement = document.createElement('p');
const referenceElement = container.firstElementChild;
container.insertBefore(newElement, referenceElement);</code></p>
<p><strong>insertAdjacentElement()</strong> - современный метод для вставки элементов в различные позиции.</p>
<p>```javascript
const element = document.getElementById('myElement');
const newElement = document.createElement('div');</p>
<p>// Вставка в различные позиции
element.insertAdjacentElement('beforebegin', newElement); // Перед элементом
element.insertAdjacentElement('afterbegin', newElement);  // В начало элемента
element.insertAdjacentElement('beforeend', newElement);   // В конец элемента
element.insertAdjacentElement('afterend', newElement);    // После элемента
```</p>
<h3>Удаление элементов</h3>
<p><strong>removeChild()</strong> - традиционный метод удаления дочернего элемента.</p>
<p><code>javascript
const container = document.getElementById('container');
const elementToRemove = document.getElementById('removeMe');
container.removeChild(elementToRemove);</code></p>
<p><strong>remove()</strong> - современный метод, который позволяет элементу удалить себя.</p>
<p><code>javascript
const element = document.getElementById('removeMe');
element.remove();</code></p>
<p><strong>replaceChild()</strong> - заменяет один дочерний элемент другим.</p>
<p><code>javascript
const container = document.getElementById('container');
const oldElement = document.getElementById('old');
const newElement = document.createElement('div');
container.replaceChild(newElement, oldElement);</code></p>
<h2>Обработка событий</h2>
<p>События являются основой интерактивности веб-страниц. DOM предоставляет мощную систему событий, которая позволяет реагировать на действия пользователя и изменения в документе.</p>
<h3>Типы событий</h3>
<p>Существует множество типов событий, каждый из которых соответствует определенному действию или изменению состояния:</p>
<p><strong>События мыши</strong> включают <code>click</code>, <code>dblclick</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mouseover</code>, <code>mouseout</code>, <code>mousemove</code>. Эти события позволяют реагировать на взаимодействие пользователя с элементами через мышь.</p>
<p><strong>События клавиатуры</strong> включают <code>keydown</code>, <code>keyup</code>, <code>keypress</code>. Они позволяют обрабатывать ввод с клавиатуры и создавать горячие клавиши.</p>
<p><strong>События формы</strong> включают <code>submit</code>, <code>change</code>, <code>input</code>, <code>focus</code>, <code>blur</code>. Эти события критически важны для работы с формами и валидации пользовательского ввода.</p>
<p><strong>События загрузки</strong> включают <code>load</code>, <code>DOMContentLoaded</code>, <code>unload</code>, <code>beforeunload</code>. Они позволяют выполнять код в определенные моменты жизненного цикла страницы.</p>
<h3>Добавление обработчиков событий</h3>
<p><strong>addEventListener()</strong> - рекомендуемый способ добавления обработчиков событий.</p>
<p>```javascript
const button = document.getElementById('myButton');</p>
<p>button.addEventListener('click', function(event) {
    console.log('Кнопка была нажата!');
    console.log('Событие:', event);
});</p>
<p>// Можно также использовать стрелочные функции
button.addEventListener('click', (event) =&gt; {
    event.preventDefault(); // Предотвращение действия по умолчанию
    console.log('Обработчик события');
});
```</p>
<p><strong>Объект события</strong> содержит информацию о произошедшем событии и предоставляет методы для управления его поведением:</p>
<p>```javascript
element.addEventListener('click', function(event) {
    console.log('Тип события:', event.type);
    console.log('Целевой элемент:', event.target);
    console.log('Текущий элемент:', event.currentTarget);
    console.log('Координаты мыши:', event.clientX, event.clientY);</p>
<pre><code>// Предотвращение действия по умолчанию
event.preventDefault();

// Остановка всплытия события
event.stopPropagation();
</code></pre>
<p>});
```</p>
<h3>Всплытие и погружение событий</h3>
<p>События в DOM проходят через три фазы: погружение (capturing), достижение цели (target) и всплытие (bubbling). Понимание этого механизма важно для эффективной обработки событий.</p>
<p><strong>Фаза погружения</strong> - событие распространяется от корня документа к целевому элементу. <strong>Фаза цели</strong> - событие достигает элемента, на котором оно произошло. <strong>Фаза всплытия</strong> - событие поднимается от целевого элемента обратно к корню документа.</p>
<p>```javascript
// Обработчик на фазе всплытия (по умолчанию)
element.addEventListener('click', handler);</p>
<p>// Обработчик на фазе погружения
element.addEventListener('click', handler, true);</p>
<p>// Современный синтаксис с объектом опций
element.addEventListener('click', handler, {
    capture: true,  // Фаза погружения
    once: true,     // Выполнить только один раз
    passive: true   // Пассивный обработчик
});
```</p>
<h3>Делегирование событий</h3>
<p>Делегирование событий - это техника, при которой обработчик события добавляется к родительскому элементу вместо добавления обработчиков к каждому дочернему элементу. Это особенно полезно для динамически создаваемых элементов.</p>
<p>```javascript
const container = document.getElementById('container');</p>
<p>container.addEventListener('click', function(event) {
    if (event.target.classList.contains('button')) {
        console.log('Нажата кнопка:', event.target.textContent);
    }</p>
<pre><code>if (event.target.tagName === 'LI') {
    console.log('Выбран элемент списка:', event.target.textContent);
}
</code></pre>
<p>});
```</p>
<h2>Практические примеры</h2>
<p>Рассмотрим несколько практических примеров, демонстрирующих применение изученных концепций DOM.</p>
<h3>Пример 1: Динамический список задач</h3>
<p>```javascript
class TodoList {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.tasks = [];
        this.init();
    }</p>
<pre><code>init() {
    this.createInterface();
    this.bindEvents();
}

createInterface() {
    this.container.innerHTML = `
        &lt;div class="todo-app"&gt;
            &lt;h2&gt;Список задач&lt;/h2&gt;
            &lt;div class="input-group"&gt;
                &lt;input type="text" id="taskInput" placeholder="Введите новую задачу"&gt;
                &lt;button id="addButton"&gt;Добавить&lt;/button&gt;
            &lt;/div&gt;
            &lt;ul id="taskList"&gt;&lt;/ul&gt;
        &lt;/div&gt;
    `;
}

bindEvents() {
    const addButton = this.container.querySelector('#addButton');
    const taskInput = this.container.querySelector('#taskInput');

    addButton.addEventListener('click', () =&gt; this.addTask());
    taskInput.addEventListener('keypress', (e) =&gt; {
        if (e.key === 'Enter') this.addTask();
    });

    // Делегирование событий для кнопок задач
    const taskList = this.container.querySelector('#taskList');
    taskList.addEventListener('click', (e) =&gt; {
        if (e.target.classList.contains('delete-btn')) {
            this.deleteTask(e.target.dataset.id);
        } else if (e.target.classList.contains('toggle-btn')) {
            this.toggleTask(e.target.dataset.id);
        }
    });
}

addTask() {
    const input = this.container.querySelector('#taskInput');
    const text = input.value.trim();

    if (text) {
        const task = {
            id: Date.now(),
            text: text,
            completed: false
        };

        this.tasks.push(task);
        this.renderTasks();
        input.value = '';
    }
}

deleteTask(id) {
    this.tasks = this.tasks.filter(task =&gt; task.id != id);
    this.renderTasks();
}

toggleTask(id) {
    const task = this.tasks.find(task =&gt; task.id == id);
    if (task) {
        task.completed = !task.completed;
        this.renderTasks();
    }
}

renderTasks() {
    const taskList = this.container.querySelector('#taskList');

    taskList.innerHTML = this.tasks.map(task =&gt; `
        &lt;li class="task-item ${task.completed ? 'completed' : ''}"&gt;
            &lt;span class="task-text"&gt;${task.text}&lt;/span&gt;
            &lt;div class="task-buttons"&gt;
                &lt;button class="toggle-btn" data-id="${task.id}"&gt;
                    ${task.completed ? 'Отменить' : 'Выполнить'}
                &lt;/button&gt;
                &lt;button class="delete-btn" data-id="${task.id}"&gt;Удалить&lt;/button&gt;
            &lt;/div&gt;
        &lt;/li&gt;
    `).join('');
}
</code></pre>
<p>}</p>
<p>// Использование
const todoList = new TodoList('todoContainer');
```</p>
<h3>Пример 2: Интерактивная галерея изображений</h3>
<p>```javascript
class ImageGallery {
    constructor(containerId, images) {
        this.container = document.getElementById(containerId);
        this.images = images;
        this.currentIndex = 0;
        this.init();
    }</p>
<pre><code>init() {
    this.createGallery();
    this.bindEvents();
    this.showImage(0);
}

createGallery() {
    this.container.innerHTML = `
        &lt;div class="gallery"&gt;
            &lt;div class="main-image"&gt;
                &lt;img id="currentImage" src="" alt=""&gt;
                &lt;div class="image-controls"&gt;
                    &lt;button id="prevBtn"&gt;‹ Предыдущая&lt;/button&gt;
                    &lt;span id="imageCounter"&gt;&lt;/span&gt;
                    &lt;button id="nextBtn"&gt;Следующая ›&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="thumbnails" id="thumbnails"&gt;&lt;/div&gt;
        &lt;/div&gt;
    `;

    this.createThumbnails();
}

createThumbnails() {
    const thumbnailsContainer = this.container.querySelector('#thumbnails');

    this.images.forEach((image, index) =&gt; {
        const thumbnail = document.createElement('img');
        thumbnail.src = image.thumbnail || image.src;
        thumbnail.alt = image.alt;
        thumbnail.className = 'thumbnail';
        thumbnail.dataset.index = index;

        thumbnailsContainer.appendChild(thumbnail);
    });
}

bindEvents() {
    const prevBtn = this.container.querySelector('#prevBtn');
    const nextBtn = this.container.querySelector('#nextBtn');
    const thumbnails = this.container.querySelector('#thumbnails');

    prevBtn.addEventListener('click', () =&gt; this.previousImage());
    nextBtn.addEventListener('click', () =&gt; this.nextImage());

    thumbnails.addEventListener('click', (e) =&gt; {
        if (e.target.classList.contains('thumbnail')) {
            this.showImage(parseInt(e.target.dataset.index));
        }
    });

    // Клавиатурная навигация
    document.addEventListener('keydown', (e) =&gt; {
        if (e.key === 'ArrowLeft') this.previousImage();
        if (e.key === 'ArrowRight') this.nextImage();
    });
}

showImage(index) {
    if (index &gt;= 0 &amp;&amp; index &lt; this.images.length) {
        this.currentIndex = index;

        const currentImage = this.container.querySelector('#currentImage');
        const imageCounter = this.container.querySelector('#imageCounter');
        const thumbnails = this.container.querySelectorAll('.thumbnail');

        currentImage.src = this.images[index].src;
        currentImage.alt = this.images[index].alt;

        imageCounter.textContent = `${index + 1} из ${this.images.length}`;

        // Обновление активной миниатюры
        thumbnails.forEach((thumb, i) =&gt; {
            thumb.classList.toggle('active', i === index);
        });
    }
}

nextImage() {
    const nextIndex = (this.currentIndex + 1) % this.images.length;
    this.showImage(nextIndex);
}

previousImage() {
    const prevIndex = (this.currentIndex - 1 + this.images.length) % this.images.length;
    this.showImage(prevIndex);
}
</code></pre>
<p>}</p>
<p>// Использование
const images = [
    { src: 'image1.jpg', alt: 'Описание 1' },
    { src: 'image2.jpg', alt: 'Описание 2' },
    { src: 'image3.jpg', alt: 'Описание 3' }
];</p>
<p>const gallery = new ImageGallery('galleryContainer', images);
```</p>
<h3>Пример 3: Форма с валидацией</h3>
<p>```javascript
class FormValidator {
    constructor(formId) {
        this.form = document.getElementById(formId);
        this.rules = {};
        this.init();
    }</p>
<pre><code>init() {
    this.bindEvents();
}

addRule(fieldName, validator, message) {
    if (!this.rules[fieldName]) {
        this.rules[fieldName] = [];
    }
    this.rules[fieldName].push({ validator, message });
}

bindEvents() {
    this.form.addEventListener('submit', (e) =&gt; {
        e.preventDefault();
        this.validateForm();
    });

    // Валидация в реальном времени
    this.form.addEventListener('input', (e) =&gt; {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            this.validateField(e.target);
        }
    });

    this.form.addEventListener('blur', (e) =&gt; {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            this.validateField(e.target);
        }
    }, true);
}

validateField(field) {
    const fieldName = field.name;
    const value = field.value;
    const rules = this.rules[fieldName];

    if (!rules) return true;

    let isValid = true;
    let errorMessage = '';

    for (const rule of rules) {
        if (!rule.validator(value)) {
            isValid = false;
            errorMessage = rule.message;
            break;
        }
    }

    this.showFieldError(field, isValid ? '' : errorMessage);
    return isValid;
}

validateForm() {
    let isFormValid = true;
    const formData = new FormData(this.form);

    // Валидация всех полей
    for (const [fieldName] of formData) {
        const field = this.form.querySelector(`[name="${fieldName}"]`);
        if (field &amp;&amp; !this.validateField(field)) {
            isFormValid = false;
        }
    }

    if (isFormValid) {
        this.onSuccess(formData);
    } else {
        this.onError();
    }
}

showFieldError(field, message) {
    // Удаление предыдущих сообщений об ошибках
    const existingError = field.parentNode.querySelector('.error-message');
    if (existingError) {
        existingError.remove();
    }

    field.classList.toggle('error', !!message);
    field.classList.toggle('valid', !message &amp;&amp; field.value);

    if (message) {
        const errorElement = document.createElement('div');
        errorElement.className = 'error-message';
        errorElement.textContent = message;
        field.parentNode.appendChild(errorElement);
    }
}

onSuccess(formData) {
    console.log('Форма валидна!', Object.fromEntries(formData));
    // Здесь можно отправить данные на сервер
}

onError() {
    console.log('Форма содержит ошибки');
}
</code></pre>
<p>}</p>
<p>// Использование
const validator = new FormValidator('myForm');</p>
<p>// Добавление правил валидации
validator.addRule('email', 
    value =&gt; /^[^\s@]+@[^\s@]+.[^\s@]+$/.test(value),
    'Введите корректный email адрес'
);</p>
<p>validator.addRule('password',
    value =&gt; value.length &gt;= 8,
    'Пароль должен содержать минимум 8 символов'
);</p>
<p>validator.addRule('name',
    value =&gt; value.trim().length &gt;= 2,
    'Имя должно содержать минимум 2 символа'
);
```</p>
<h2>Лучшие практики работы с DOM</h2>
<p>При работе с DOM важно следовать определенным принципам и лучшим практикам, которые обеспечивают производительность, безопасность и поддерживаемость кода.</p>
<h3>Производительность</h3>
<p><strong>Минимизация обращений к DOM</strong> - операции с DOM являются относительно медленными, поэтому следует минимизировать количество обращений к нему. Кэшируйте ссылки на часто используемые элементы.</p>
<p>```javascript
// Плохо - множественные обращения к DOM
for (let i = 0; i &lt; 100; i++) {
    document.getElementById('counter').textContent = i;
}</p>
<p>// Хорошо - кэширование ссылки
const counter = document.getElementById('counter');
for (let i = 0; i &lt; 100; i++) {
    counter.textContent = i;
}
```</p>
<p><strong>Пакетные изменения DOM</strong> - группируйте изменения DOM для минимизации перерисовки страницы.</p>
<p>```javascript
// Плохо - множественные изменения
element.style.width = '100px';
element.style.height = '100px';
element.style.backgroundColor = 'red';</p>
<p>// Хорошо - одно изменение через класс
element.className = 'new-style';</p>
<p>// Или через cssText
element.style.cssText = 'width: 100px; height: 100px; background-color: red;';
```</p>
<p><strong>Использование DocumentFragment</strong> для создания множественных элементов.</p>
<p><code>javascript
const fragment = document.createDocumentFragment();
for (let i = 0; i &lt; 100; i++) {
    const li = document.createElement('li');
    li.textContent = `Элемент ${i}`;
    fragment.appendChild(li);
}
document.getElementById('list').appendChild(fragment);</code></p>
<h3>Безопасность</h3>
<p><strong>Избегайте innerHTML с пользовательскими данными</strong> - это может привести к XSS-атакам.</p>
<p>```javascript
// Опасно
element.innerHTML = userInput;</p>
<p>// Безопасно
element.textContent = userInput;</p>
<p>// Или с санитизацией
element.innerHTML = sanitizeHTML(userInput);
```</p>
<p><strong>Валидация данных</strong> - всегда проверяйте данные перед их использованием.</p>
<p><code>javascript
function safeGetElement(id) {
    const element = document.getElementById(id);
    if (!element) {
        throw new Error(`Элемент с ID "${id}" не найден`);
    }
    return element;
}</code></p>
<h3>Поддерживаемость кода</h3>
<p><strong>Разделение логики и представления</strong> - используйте CSS-классы вместо прямого изменения стилей.</p>
<p>```javascript
// Плохо
element.style.display = 'none';</p>
<p>// Хорошо
element.classList.add('hidden');
```</p>
<p><strong>Использование делегирования событий</strong> для динамических элементов.</p>
<p><strong>Создание переиспользуемых компонентов</strong> - инкапсулируйте логику в классы или функции.</p>
<h2>Современные возможности DOM API</h2>
<p>Современные браузеры предоставляют множество новых возможностей для работы с DOM, которые упрощают разработку и повышают производительность.</p>
<h3>Intersection Observer API</h3>
<p>Позволяет асинхронно отслеживать пересечения элементов с viewport или другими элементами.</p>
<p>```javascript
const observer = new IntersectionObserver((entries) =&gt; {
    entries.forEach(entry =&gt; {
        if (entry.isIntersecting) {
            entry.target.classList.add('visible');
        }
    });
});</p>
<p>document.querySelectorAll('.animate-on-scroll').forEach(el =&gt; {
    observer.observe(el);
});
```</p>
<h3>Mutation Observer API</h3>
<p>Позволяет отслеживать изменения в DOM-дереве.</p>
<p>```javascript
const observer = new MutationObserver((mutations) =&gt; {
    mutations.forEach(mutation =&gt; {
        if (mutation.type === 'childList') {
            console.log('Добавлены или удалены дочерние элементы');
        }
        if (mutation.type === 'attributes') {
            console.log('Изменены атрибуты элемента');
        }
    });
});</p>
<p>observer.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true
});
```</p>
<h3>Resize Observer API</h3>
<p>Отслеживает изменения размеров элементов.</p>
<p>```javascript
const resizeObserver = new ResizeObserver(entries =&gt; {
    entries.forEach(entry =&gt; {
        console.log('Размер элемента изменился:', entry.contentRect);
    });
});</p>
<p>resizeObserver.observe(document.getElementById('resizable'));
```</p>
<h3>Web Components</h3>
<p>Современный стандарт для создания переиспользуемых компонентов.</p>
<p>```javascript
class CustomButton extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
    }</p>
<pre><code>connectedCallback() {
    this.shadowRoot.innerHTML = `
        &lt;style&gt;
            button {
                background: var(--button-bg, #007bff);
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                cursor: pointer;
            }
            button:hover {
                opacity: 0.8;
            }
        &lt;/style&gt;
        &lt;button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/button&gt;
    `;

    this.shadowRoot.querySelector('button').addEventListener('click', () =&gt; {
        this.dispatchEvent(new CustomEvent('custom-click', {
            detail: { message: 'Кнопка нажата!' }
        }));
    });
}
</code></pre>
<p>}</p>
<p>customElements.define('custom-button', CustomButton);
```</p>
<h2>Заключение</h2>
<p>Document Object Model является фундаментальной технологией веб-разработки, которая обеспечивает мост между статическим HTML и динамическим JavaScript. Понимание DOM критически важно для создания интерактивных веб-приложений.</p>
<p>Основные принципы работы с DOM включают понимание его древовидной структуры, эффективные методы поиска и изменения элементов, правильную обработку событий и следование лучшим практикам производительности и безопасности.</p>
<p>Современные возможности DOM API, такие как Observer APIs и Web Components, открывают новые горизонты для создания сложных и производительных веб-приложений. Важно оставаться в курсе этих развивающихся технологий и применять их в соответствующих контекстах.</p>
<p>Практическое применение знаний DOM требует постоянной практики и экспериментирования. Создавайте небольшие проекты, изучайте исходный код существующих приложений и не бойтесь экспериментировать с новыми возможностями API.</p>
<p>Помните, что DOM - это живая технология, которая продолжает развиваться. Следите за новыми спецификациями и возможностями, которые появляются в современных браузерах, и адаптируйте свои знания соответственно.</p>
        </section>

        <section id="practical-works">
            <h2>Практические работы</h2>
            <h1>Практические работы по веб-разработке</h1>
<p>Данный раздел содержит подробные практические работы, разработанные для закрепления теоретических знаний и развития практических навыков в области веб-разработки. Каждая работа включает в себя четкие цели, пошаговые инструкции и критерии оценки, что позволяет студентам самостоятельно выполнять задания и отслеживать свой прогресс.</p>
<hr />
<h2>Практическая работа 1: Введение в веб-разработку</h2>
<h3>Цель работы:</h3>
<p>Освоить базовые принципы работы веб-технологий, настроить рабочую среду для веб-разработки и научиться использовать основные инструменты для создания и отладки веб-страниц.</p>
<h3>Задачи работы:</h3>
<ol>
<li>Установить и настроить интегрированную среду разработки (IDE) VS Code.</li>
<li>Создать первую HTML-страницу и запустить ее в браузере.</li>
<li>Изучить и использовать инструменты разработчика браузера для инспектирования элементов и отладки.</li>
<li>Проанализировать структуру существующих веб-сайтов.</li>
</ol>
<h3>Необходимые инструменты:</h3>
<ul>
<li>Компьютер с доступом в Интернет.</li>
<li>Веб-браузер (Google Chrome, Mozilla Firefox или другой современный браузер).</li>
<li>Текстовый редактор или IDE (Visual Studio Code).</li>
</ul>
<h3>Время выполнения: 2 академических часа (90 минут)</h3>
<h3>Пошаговый алгоритм выполнения:</h3>
<h4>Шаг 1: Установка и базовая настройка Visual Studio Code</h4>
<ol>
<li><strong>Скачайте VS Code:</strong> Перейдите на официальный сайт Visual Studio Code: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> и скачайте установочный файл, соответствующий вашей операционной системе (Windows, macOS, Linux).</li>
<li><strong>Установите VS Code:</strong> Запустите скачанный файл и следуйте инструкциям установщика. Рекомендуется оставить все настройки по умолчанию, включая добавление VS Code в PATH для удобного запуска из командной строки.</li>
<li><strong>Запустите VS Code:</strong> После установки запустите программу. Вы увидите стартовый экран.</li>
<li><strong>Установите рекомендуемые расширения:</strong> Расширения значительно упрощают процесс разработки. Откройте вкладку "Extensions" (значок квадрата в левой боковой панели или <code>Ctrl+Shift+X</code>). В строке поиска введите и установите следующие расширения:<ul>
<li><strong>Live Server:</strong> Позволяет запускать локальный сервер для автоматического обновления страницы в браузере при сохранении изменений в коде. (Автор: Ritwick Dey)</li>
<li><strong>Prettier - Code formatter:</strong> Автоматически форматирует ваш код, делая его чистым и читаемым. (Автор: Prettier)</li>
<li><strong>Auto Rename Tag:</strong> Автоматически переименовывает парный HTML/XML тег при изменении одного из них. (Автор: Jun Han)</li>
<li><strong>HTML CSS Support:</strong> Обеспечивает автодополнение и подсказки для HTML и CSS. (Автор: EMM)</li>
</ul>
</li>
</ol>
<h4>Шаг 2: Создание первой HTML-страницы</h4>
<ol>
<li><strong>Создайте рабочую папку:</strong> На вашем компьютере создайте новую папку, например, на рабочем столе, и назовите ее <code>web-development-course</code>. Эта папка будет корневой для всех ваших проектов в рамках курса.</li>
<li><strong>Откройте папку в VS Code:</strong> В VS Code выберите <code>File</code> -&gt; <code>Open Folder...</code> (или <code>Файл</code> -&gt; <code>Открыть папку...</code>) и выберите только что созданную папку <code>web-development-course</code>.</li>
<li><strong>Создайте новый файл:</strong> В VS Code в левой панели (Explorer) нажмите на значок "New File" (или <code>Ctrl+N</code>) и сохраните его как <code>index.html</code> внутри папки <code>web-development-course</code>.</li>
<li><strong>Введите базовую структуру HTML:</strong> В файле <code>index.html</code> наберите следующий код. Вы можете использовать сокращение <code>!</code> (восклицательный знак) и нажать <code>Tab</code> для автоматической генерации базовой структуры HTML5 в VS Code.
    <code>html
    &lt;!DOCTYPE html&gt;
    &lt;html lang="ru"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;Моя первая веб-страница&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Добро пожаловать в мир веб-разработки!&lt;/h1&gt;
        &lt;p&gt;Это моя первая HTML-страница, созданная в рамках курса.&lt;/p&gt;
        &lt;p&gt;Мы будем изучать HTML, CSS и JavaScript.&lt;/p&gt;
    &lt;/body&gt;
    &lt;/html&gt;</code></li>
<li><strong>Сохраните файл:</strong> Сохраните изменения (<code>Ctrl+S</code>).</li>
</ol>
<h4>Шаг 3: Запуск страницы в браузере с помощью Live Server</h4>
<ol>
<li><strong>Запустите Live Server:</strong> В VS Code, находясь в файле <code>index.html</code>, щелкните правой кнопкой мыши в любом месте редактора и выберите <code>Open with Live Server</code>. Или нажмите на значок "Go Live" в правом нижнем углу строки состояния VS Code.</li>
<li><strong>Проверьте страницу:</strong> Ваш веб-браузер автоматически откроется, и вы увидите вашу первую веб-страницу по адресу, похожему на <code>http://127.0.0.1:5500/index.html</code>. Это локальный сервер, который автоматически обновляет страницу при каждом сохранении изменений в вашем коде.</li>
<li><strong>Протестируйте автообновление:</strong> Измените текст в заголовке <code>&lt;h1&gt;</code> или параграфе <code>&lt;p&gt;</code> в <code>index.html</code> и сохраните файл. Убедитесь, что страница в браузере обновилась автоматически, отображая ваши изменения.</li>
</ol>
<h4>Шаг 4: Изучение инструментов разработчика браузера</h4>
<p>Инструменты разработчика (DevTools) — это мощный набор инструментов, встроенных в современные браузеры, которые позволяют инспектировать и отлаживать веб-страницы.</p>
<ol>
<li><strong>Откройте DevTools:</strong> На открытой странице <code>index.html</code> в браузере нажмите клавишу <code>F12</code> (или <code>Ctrl+Shift+I</code> / <code>Cmd+Option+I</code> на macOS), либо щелкните правой кнопкой мыши в любом месте страницы и выберите <code>Inspect</code> (или <code>Исследовать элемент</code>).</li>
<li><strong>Вкладка Elements (Элементы):</strong><ul>
<li>Изучите HTML-структуру вашей страницы. Вы увидите дерево DOM (Document Object Model), которое является представлением вашей HTML-страницы.</li>
<li>Наведите курсор на различные элементы в дереве DOM. Вы увидите, как браузер подсвечивает соответствующие части страницы.</li>
<li>Попробуйте изменить текст заголовка <code>&lt;h1&gt;</code> или параграфа <code>&lt;p&gt;</code> прямо во вкладке <code>Elements</code>. Дважды щелкните на тексте элемента и введите новый. Обратите внимание, что эти изменения временные и не сохраняются в вашем исходном файле.</li>
<li>Попробуйте изменить стили элемента во вкладке <code>Styles</code> (обычно находится справа от вкладки <code>Elements</code>). Например, измените <code>color</code> или <code>font-size</code> для <code>&lt;h1&gt;</code>.</li>
</ul>
</li>
<li><strong>Вкладка Console (Консоль):</strong><ul>
<li>Эта вкладка используется для вывода сообщений JavaScript, ошибок и для выполнения JavaScript-кода в реальном времени.</li>
<li>Введите <code>console.log("Привет из консоли!");</code> и нажмите <code>Enter</code>. Вы увидите сообщение в консоли.</li>
<li>Попробуйте ввести <code>document.getElementById("myHeading").textContent = "Новый заголовок из консоли!";</code> и нажмите <code>Enter</code>. Увидите, как изменится заголовок на странице.</li>
</ul>
</li>
<li><strong>Вкладка Network (Сеть):</strong><ul>
<li>Эта вкладка показывает все сетевые запросы, которые делает страница (загрузка HTML, CSS, JavaScript, изображений и т.д.).</li>
<li>Обновите страницу (<code>Ctrl+R</code> или <code>Cmd+R</code>). Вы увидите список всех загруженных ресурсов, их размер и время загрузки.</li>
</ul>
</li>
</ol>
<h4>Шаг 5: Анализ структуры существующих веб-сайтов</h4>
<ol>
<li><strong>Выберите сайты для анализа:</strong> Откройте в браузере 3-4 популярных веб-сайта, например: <code>yandex.ru</code>, <code>vk.com</code>, <code>github.com</code>, <code>google.com</code>.</li>
<li><strong>Используйте DevTools для анализа:</strong> Для каждого сайта откройте инструменты разработчика (<code>F12</code>) и внимательно изучите вкладку <code>Elements</code>.</li>
<li><strong>Определите основные блоки:</strong> Постарайтесь определить, какие HTML-теги используются для создания основных структурных блоков страницы: шапка (<code>&lt;header&gt;</code>), навигация (<code>&lt;nav&gt;</code>), основной контент (<code>&lt;main&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>), боковая панель (<code>&lt;aside&gt;</code>), подвал (<code>&lt;footer&gt;</code>). Обратите внимание на использование семантических тегов HTML5.</li>
<li>
<p><strong>Создайте отчет:</strong> В вашей рабочей папке <code>web-development-course</code> создайте новый файл <code>website-analysis.md</code> (Markdown-файл). В этом файле опишите результаты вашего анализа для каждого сайта:</p>
<ul>
<li>Название сайта и его URL.</li>
<li>Основные структурные блоки, которые вы определили (например, <code>header</code>, <code>nav</code>, <code>main</code>, <code>footer</code>).</li>
<li>Примеры HTML-тегов, используемых для этих блоков.</li>
<li>Как организована навигация (списки, ссылки).</li>
<li>Ваши наблюдения о том, как контент разделен на секции.</li>
</ul>
<p>Пример структуры отчета:
```markdown</p>
<h1>Анализ структуры веб-сайтов</h1>
<h2>Сайт: Yandex.ru</h2>
<ul>
<li><strong>URL:</strong> https://yandex.ru/</li>
<li><strong>Основные блоки:</strong><ul>
<li>Шапка (<code>&lt;header&gt;</code>): содержит логотип, поиск, ссылки на сервисы.</li>
<li>Основной контент (<code>&lt;main&gt;</code>): новостные блоки, виджеты.</li>
<li>Подвал (<code>&lt;footer&gt;</code>): ссылки на информацию о компании.</li>
</ul>
</li>
<li><strong>Навигация:</strong> В основном через ссылки внутри <code>&lt;nav&gt;</code> элементов или прямые ссылки.</li>
<li><strong>Наблюдения:</strong> Активное использование <code>div</code> для группировки, но также присутствуют семантические тепы.</li>
</ul>
<h2>Сайт: VK.com</h2>
<ul>
<li><strong>URL:</strong> https://vk.com/</li>
<li><strong>Основные блоки:</strong><ul>
<li>Боковая панель (<code>&lt;aside&gt;</code> или <code>div</code> с ролью <code>navigation</code>): основное меню.</li>
<li>Центральный контент (<code>&lt;main&gt;</code> или <code>div</code>): лента новостей, профиль.</li>
</ul>
</li>
<li><strong>Навигация:</strong> Преимущественно через списки <code>&lt;ul&gt;</code> с элементами <code>&lt;li&gt;</code> и ссылками <code>&lt;a&gt;</code>.</li>
<li><strong>Наблюдения:</strong> Сложная структура с большим количеством вложенных элементов, активное использование классов для стилизации.
```</li>
</ul>
</li>
<li>
<p><strong>Сохраните отчет:</strong> Сохраните файл <code>website-analysis.md</code>.</p>
</li>
</ol>
<h3>Критерии оценки Практической работы 1:</h3>
<ul>
<li>VS Code установлен и настроен, включая необходимые расширения.</li>
<li>Создана корректная HTML-страница <code>index.html</code>.</li>
<li>Страница успешно запущена через Live Server и отображается в браузере.</li>
<li>Студент продемонстрировал умение использовать вкладки <code>Elements</code> и <code>Console</code> в инструментах разработчика.</li>
<li>Выполнен анализ 3-4 веб-сайтов, и результаты зафиксированы в файле <code>website-analysis.md</code> с описанием основных структурных блоков и используемых тегов.</li>
</ul>
<hr />
<h2>Практическая работа 2: Основы HTML</h2>
<h3>Цель работы:</h3>
<p>Освоить базовые принципы структурирования веб-контента с использованием HTML, научиться применять различные HTML-теги для создания текстовых блоков, изображений, ссылок, форм и таблиц, а также использовать семантические элементы HTML5.</p>
<h3>Задачи работы:</h3>
<ol>
<li>Создать базовую HTML-структуру для многостраничного веб-сайта.</li>
<li>Использовать основные HTML-теги для разметки текста, списков и ссылок.</li>
<li>Вставлять изображения и настраивать их атрибуты.</li>
<li>Разрабатывать интерактивные формы с различными типами полей ввода.</li>
<li>Применять семантические элементы HTML5 для улучшения структуры и доступности.</li>
</ol>
<h3>Необходимые инструменты:</h3>
<ul>
<li>VS Code с установленными расширениями (Live Server, Prettier, Auto Rename Tag, HTML CSS Support).</li>
<li>Веб-браузер.</li>
</ul>
<h3>Время выполнения: 4 академических часа (180 минут)</h3>
<h3>Пошаговый алгоритм выполнения:</h3>
<h4>Шаг 1: Создание структуры личного сайта-портфолио</h4>
<ol>
<li><strong>Создайте новую папку проекта:</strong> В вашей основной рабочей папке <code>web-development-course</code> создайте новую папку с названием <code>my-portfolio-website</code>.</li>
<li><strong>Создайте основные HTML-файлы:</strong> Внутри папки <code>my-portfolio-website</code> создайте следующие файлы:<ul>
<li><code>index.html</code> (Главная страница)</li>
<li><code>about.html</code> (Страница "Обо мне")</li>
<li><code>portfolio.html</code> (Страница "Портфолио")</li>
<li><code>contact.html</code> (Страница "Контакты")</li>
</ul>
</li>
<li><strong>Базовая структура <code>index.html</code>:</strong> Откройте <code>index.html</code> в VS Code и создайте базовую HTML5 структуру (используйте <code>!</code> + <code>Tab</code>). Заполните ее следующим образом, используя семантические теги:
    ```html
    &lt;!DOCTYPE html&gt;
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Иван Иванов - Веб-разработчик</title>
    </head>
    <body>
        <header>
            <h1>Иван Иванов</h1>
            <p>Начинающий веб-разработчик</p>
            <nav>
                <ul>
                    <li><a href="index.html">Главная</a></li>
                    <li><a href="about.html">Обо мне</a></li>
                    <li><a href="portfolio.html">Портфолио</a></li>
                    <li><a href="contact.html">Контакты</a></li>
                </ul>
            </nav>
        </header><pre><code>&lt;main&gt;
    &lt;section&gt;
        &lt;h2&gt;Добро пожаловать!&lt;/h2&gt;
        &lt;p&gt;Меня зовут Иван, и я изучаю веб-разработку. На этом сайте вы можете узнать больше обо мне и моих проектах.&lt;/p&gt;
        &lt;img src="https://via.placeholder.com/400x300" alt="Фото автора" width="400" height="300"&gt;
    &lt;/section&gt;

    &lt;section&gt;
        &lt;h2&gt;Мои навыки&lt;/h2&gt;
        &lt;ul&gt;
            &lt;li&gt;HTML5&lt;/li&gt;
            &lt;li&gt;CSS3&lt;/li&gt;
            &lt;li&gt;JavaScript (изучаю)&lt;/li&gt;
            &lt;li&gt;Адаптивный дизайн&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/section&gt;
&lt;/main&gt;

&lt;footer&gt;
    &lt;p&gt;&amp;copy; 2024 Иван Иванов. Все права защищены.&lt;/p&gt;
&lt;/footer&gt;
</code></pre>
<p></body>
</html>
<code>``
4.  **Скопируйте структуру на другие страницы:** Скопируйте содержимое</code>index.html<code>в</code>about.html<code>,</code>portfolio.html<code>и</code>contact.html<code>. Затем измените заголовок</code><title><code>и содержимое</code><main><code>для каждой страницы, чтобы оно соответствовало ее назначению.
*   **</code>about.html<code>:** Добавьте информацию о себе (образование, хобби, цели). Используйте теги</code><h2><code>,</code><h3><code>,</code><p><code>,</code><ul><code>,</code><ol><code>,</code><strong><code>,</code><em><code>.
*   **</code>portfolio.html<code>:** Создайте раздел для будущих проектов. Добавьте 3-4 "карточки" проектов. Каждая карточка должна содержать: название проекта (</code><h3><code>), краткое описание (</code><p><code>), изображение (</code><img><code>с</code>src<code>на placeholder-изображение и</code>alt<code>), и ссылку на проект (</code><a><code>).
*   **</code>contact.html<code>:** Добавьте контактную информацию (email, телефон, адрес). Создайте простую форму обратной связи (см. Шаг 2).
5.  **Проверьте навигацию:** Откройте</code>index.html<code>с помощью Live Server. Убедитесь, что все ссылки в навигационном меню (</code><nav>`) работают корректно и позволяют переходить между страницами.</p>
</li>
</ol>
<h4>Шаг 2: Создание интерактивной формы регистрации</h4>
<ol>
<li><strong>Откройте <code>contact.html</code>:</strong> Добавьте в него следующую форму. Убедитесь, что она находится внутри тега <code>&lt;main&gt;</code>.
    ```html
    <section>
        <h2>Свяжитесь со мной</h2>
        <form action="#" method="post">
            <fieldset>
                <legend>Личная информация</legend>
                <label for="firstName">Имя:</label>
                <input type="text" id="firstName" name="firstName" required><pre><code>        &lt;label for="lastName"&gt;Фамилия:&lt;/label&gt;
        &lt;input type="text" id="lastName" name="lastName" required&gt;

        &lt;label for="email"&gt;Email:&lt;/label&gt;
        &lt;input type="email" id="email" name="email" required&gt;

        &lt;label for="phone"&gt;Телефон:&lt;/label&gt;
        &lt;input type="tel" id="phone" name="phone" pattern="[0-9]{3}-[0-9]{3}-[0-9]{4}" placeholder="Формат: 123-456-7890"&gt;

        &lt;label for="birthDate"&gt;Дата рождения:&lt;/label&gt;
        &lt;input type="date" id="birthDate" name="birthDate"&gt;
    &lt;/fieldset&gt;

    &lt;fieldset&gt;
        &lt;legend&gt;Дополнительная информация&lt;/legend&gt;
        &lt;label for="gender"&gt;Пол:&lt;/label&gt;
        &lt;select id="gender" name="gender"&gt;
            &lt;option value=""&gt;Выберите пол&lt;/option&gt;
            &lt;option value="male"&gt;Мужской&lt;/option&gt;
            &lt;option value="female"&gt;Женский&lt;/option&gt;
            &lt;option value="other"&gt;Другой&lt;/option&gt;
        &lt;/select&gt;

        &lt;p&gt;Интересы:&lt;/p&gt;
        &lt;input type="checkbox" id="web" name="interests" value="web"&gt;
        &lt;label for="web"&gt;Веб-разработка&lt;/label&gt;&lt;br&gt;

        &lt;input type="checkbox" id="design" name="interests" value="design"&gt;
        &lt;label for="design"&gt;Дизайн&lt;/label&gt;&lt;br&gt;

        &lt;input type="checkbox" id="programming" name="interests" value="programming"&gt;
        &lt;label for="programming"&gt;Программирование&lt;/label&gt;&lt;br&gt;

        &lt;p&gt;Опыт работы:&lt;/p&gt;
        &lt;input type="radio" id="beginner" name="experience" value="beginner"&gt;
        &lt;label for="beginner"&gt;Начинающий&lt;/label&gt;&lt;br&gt;

        &lt;input type="radio" id="intermediate" name="experience" value="intermediate"&gt;
        &lt;label for="intermediate"&gt;Средний уровень&lt;/label&gt;&lt;br&gt;

        &lt;input type="radio" id="advanced" name="experience" value="advanced"&gt;
        &lt;label for="advanced"&gt;Продвинутый&lt;/label&gt;&lt;br&gt;

        &lt;label for="bio"&gt;О себе:&lt;/label&gt;
        &lt;textarea id="bio" name="bio" rows="4" cols="50" placeholder="Расскажите немного о себе..."&gt;&lt;/textarea&gt;
    &lt;/fieldset&gt;

    &lt;input type="checkbox" id="agree" name="agree" required&gt;
    &lt;label for="agree"&gt;Я согласен с условиями использования&lt;/label&gt;

    &lt;button type="submit"&gt;Отправить&lt;/button&gt;
    &lt;button type="reset"&gt;Очистить форму&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p></section>
<code>``
2.  **Проверьте форму:** Откройте</code>contact.html<code>в браузере. Попробуйте заполнить форму. Обратите внимание на атрибут</code>required<code>для обязательных полей и</code>pattern` для поля телефона. Посмотрите, как браузер обрабатывает эти атрибуты.</p>
</li>
</ol>
<h4>Шаг 3: Создание галереи изображений и добавление мультимедиа</h4>
<ol>
<li><strong>Создайте файл <code>gallery.html</code>:</strong> В папке <code>my-portfolio-website</code> создайте новый файл <code>gallery.html</code>. Добавьте базовую HTML-структуру и навигацию, аналогичную другим страницам.</li>
<li><strong>Добавьте галерею изображений:</strong> Внутри тега <code>&lt;main&gt;</code> в <code>gallery.html</code> создайте секцию для галереи. Используйте теги <code>&lt;img&gt;</code> с placeholder-изображениями (например, с <code>https://via.placeholder.com/</code>). Добавьте к каждому изображению подпись, используя теги <code>&lt;figure&gt;</code> и <code>&lt;figcaption&gt;</code>.
    <code>html
    &lt;section&gt;
        &lt;h2&gt;Моя Галерея&lt;/h2&gt;
        &lt;div class="image-gallery"&gt;
            &lt;figure&gt;
                &lt;img src="https://via.placeholder.com/300x200?text=Изображение+1" alt="Описание изображения 1"&gt;
                &lt;figcaption&gt;Красивый пейзаж&lt;/figcaption&gt;
            &lt;/figure&gt;
            &lt;figure&gt;
                &lt;img src="https://via.placeholder.com/300x200?text=Изображение+2" alt="Описание изображения 2"&gt;
                &lt;figcaption&gt;Городской вид&lt;/figcaption&gt;
            &lt;/figure&gt;
            &lt;figure&gt;
                &lt;img src="https://via.placeholder.com/300x200?text=Изображение+3" alt="Описание изображения 3"&gt;
                &lt;figcaption&gt;Абстрактное искусство&lt;/figcaption&gt;
            &lt;/figure&gt;
            &lt;!-- Добавьте еще 3-5 изображений --&gt;
        &lt;/div&gt;
    &lt;/section&gt;</code></li>
<li><strong>Добавьте видео:</strong> В ту же секцию или в новую секцию добавьте видео. Вы можете использовать видео с YouTube, встроив его с помощью тега <code>&lt;iframe&gt;</code>.
    <code>html
    &lt;section&gt;
        &lt;h2&gt;Видео&lt;/h2&gt;
        &lt;iframe width="560" height="315" src="https://www.youtube.com/embed/dQw4w9WgXcQ" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
    &lt;/section&gt;</code>
    <em>(Примечание: <code>dQw4w9WgXcQ</code> - это ID известного видео, замените его на ID любого другого видео с YouTube, если хотите.)</em></li>
<li><strong>Добавьте аудио:</strong> Добавьте аудиофайл, используя тег <code>&lt;audio&gt;</code>. Вы можете использовать любой доступный аудиофайл или найти бесплатный на сайтах с Royalty-Free музыкой.
    <code>html
    &lt;section&gt;
        &lt;h2&gt;Аудио&lt;/h2&gt;
        &lt;audio controls&gt;
            &lt;source src="your-audio-file.mp3" type="audio/mpeg"&gt;
            Ваш браузер не поддерживает элемент audio.
        &lt;/audio&gt;
    &lt;/section&gt;</code>
    <em>(Примечание: Замените <code>your-audio-file.mp3</code> на реальный путь к вашему аудиофайлу.)</em></li>
</ol>
<h3>Критерии оценки Практической работы 2:</h3>
<ul>
<li>Создана многостраничная структура сайта с корректной навигацией.</li>
<li>Использованы семантические теги HTML5 (<code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;aside&gt;</code>, <code>&lt;figure&gt;</code>, <code>&lt;figcaption&gt;</code>).</li>
<li>Форма регистрации содержит различные типы полей ввода (<code>text</code>, <code>email</code>, <code>tel</code>, <code>date</code>, <code>select</code>, <code>checkbox</code>, <code>radio</code>, <code>textarea</code>) и атрибут <code>required</code>.</li>
<li>Галерея изображений содержит не менее 6 изображений с подписями.</li>
<li>На странице присутствуют встроенные видео и аудио элементы.</li>
<li>Код HTML валиден и хорошо структурирован. </li>
</ul>
<hr />
<h2>Практическая работа 3: Основы CSS</h2>
<h3>Цель работы:</h3>
<p>Освоить различные способы подключения CSS, научиться использовать селекторы для стилизации элементов, применять блочную модель CSS для контроля над размерами и расположением элементов, а также создавать гибкие макеты с использованием Flexbox и Grid.</p>
<h3>Задачи работы:</h3>
<ol>
<li>Подключить внешние CSS-файлы к HTML-документам.</li>
<li>Использовать различные типы CSS-селекторов (по тегу, классу, ID, атрибуту, псевдоклассы, псевдоэлементы).</li>
<li>Применять основные CSS-свойства для стилизации текста, фона, границ, отступов.</li>
<li>Понимать и использовать блочную модель CSS (<code>display</code>, <code>box-sizing</code>, <code>margin</code>, <code>padding</code>, <code>border</code>).</li>
<li>Создавать одномерные макеты с помощью Flexbox.</li>
<li>Создавать двумерные макеты с помощью CSS Grid.</li>
</ol>
<h3>Необходимые инструменты:</h3>
<ul>
<li>VS Code с установленными расширениями.</li>
<li>Веб-браузер.</li>
<li>Проект <code>my-portfolio-website</code> из Практической работы 2.</li>
</ul>
<h3>Время выполнения: 4 академических часа (180 минут)</h3>
<h3>Пошаговый алгоритм выполнения:</h3>
<h4>Шаг 1: Подключение CSS и базовые стили для портфолио</h4>
<ol>
<li><strong>Создайте CSS-файл:</strong> В папке <code>my-portfolio-website</code> (созданной в Практической работе 2) создайте новый файл с названием <code>styles.css</code>.</li>
<li><strong>Подключите <code>styles.css</code> ко всем HTML-файлам:</strong> Откройте каждый HTML-файл (<code>index.html</code>, <code>about.html</code>, <code>portfolio.html</code>, <code>contact.html</code>, <code>gallery.html</code>) и добавьте следующую строку в секцию <code>&lt;head&gt;</code>:
    <code>html
    &lt;link rel="stylesheet" href="styles.css"&gt;</code>
    Убедитесь, что путь к файлу <code>styles.css</code> указан корректно относительно каждого HTML-файла.</li>
<li>
<p><strong>Добавьте базовые стили в <code>styles.css</code>:</strong>
    ```css
    /<em> Общие стили и сброс </em>/</p>
<ul>
<li>{
    margin: 0;
    padding: 0;
    box-sizing: border-box; /<em> Важно для блочной модели </em>/
}</li>
</ul>
<p>body {
    font-family: 'Arial', sans-serif; /<em> Пример шрифта </em>/
    line-height: 1.6; /<em> Межстрочный интервал </em>/
    color: #333; /<em> Цвет текста </em>/
    background-color: #f4f4f4; /<em> Цвет фона страницы </em>/
}</p>
<p>/<em> Стили для заголовков </em>/
h1, h2, h3, h4, h5, h6 {
    margin-bottom: 1rem;
    color: #2c3e50;
}</p>
<p>h1 {
    font-size: 2.5rem;
}</p>
<p>h2 {
    font-size: 2rem;
    border-bottom: 2px solid #3498db;
    padding-bottom: 0.5rem;
    margin-top: 2rem;
}</p>
<p>p {
    margin-bottom: 1rem;
}</p>
<p>/<em> Стили для ссылок </em>/
a {
    color: #3498db;
    text-decoration: none;
}</p>
<p>a:hover {
    text-decoration: underline;
}</p>
<p>/<em> Стили для списков </em>/
ul, ol {
    margin-left: 20px;
    margin-bottom: 1rem;
}</p>
<p>li {
    margin-bottom: 0.5rem;
}</p>
<p>/<em> Стили для изображений </em>/
img {
    max-width: 100%;
    height: auto;
    display: block; /<em> Убирает лишний отступ под изображением </em>/
    margin-bottom: 1rem;
}
```
4.  <strong>Проверьте изменения:</strong> Откройте любую страницу вашего портфолио через Live Server. Убедитесь, что базовые стили применились.</p>
</li>
</ol>
<h4>Шаг 2: Стилизация шапки, навигации и подвала</h4>
<ol>
<li>
<p><strong>Стилизуйте <code>&lt;header&gt;</code>:</strong> Добавьте следующие стили в <code>styles.css</code>:
    ```css
    header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /<em> Градиентный фон </em>/
        color: white;
        text-align: center;
        padding: 2rem 0;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }</p>
<p>header h1 {
    color: white;
    margin-bottom: 0.5rem;
}</p>
<p>header p {
    font-size: 1.2rem;
    margin-bottom: 1.5rem;
}
<code>2.  **Стилизуйте `&lt;nav&gt;` (навигацию):**</code>css
nav ul {
    list-style: none;
    display: flex; /<em> Используем Flexbox для горизонтального меню </em>/
    justify-content: center; /<em> Выравнивание по центру </em>/
    padding: 0;
}</p>
<p>nav li {
    margin: 0 15px;
}</p>
<p>nav a {
    color: white;
    text-decoration: none;
    font-weight: bold;
    padding: 5px 10px;
    transition: background-color 0.3s ease, color 0.3s ease;
    border-radius: 5px;
}</p>
<p>nav a:hover {
    background-color: rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}</p>
<p>nav a.active {
    background-color: #3498db; /<em> Пример стиля для активной ссылки </em>/
}
<code>*Дополнительно:* Вы можете добавить класс `active` к текущей странице в HTML, чтобы выделить ее в навигации. Например, для `index.html`: `&lt;a href="index.html" class="active"&gt;Главная&lt;/a&gt;`.
3.  **Стилизуйте `&lt;footer&gt;`:**</code>css
footer {
    background-color: #2c3e50;
    color: white;
    text-align: center;
    padding: 1.5rem 0;
    margin-top: 3rem;
}
```
4.  <strong>Проверьте изменения:</strong> Обновите страницы в браузере. Убедитесь, что шапка, навигация и подвал выглядят стилизованными.</p>
</li>
</ol>
<h4>Шаг 3: Стилизация основного контента и блочная модель</h4>
<ol>
<li>
<p><strong>Стилизуйте <code>&lt;main&gt;</code> и <code>&lt;section&gt;</code>:</strong>
    ```css
    main {
        max-width: 1200px; /<em> Максимальная ширина контента </em>/
        margin: 2rem auto; /<em> Центрирование блока и отступы сверху/снизу </em>/
        padding: 0 20px; /<em> Внутренние отступы по бокам </em>/
    }</p>
<p>section {
    background-color: white;
    padding: 2rem;
    margin-bottom: 2rem;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}
<code>2.  **Примените блочную модель к элементам формы:** В `contact.html` добавьте стили для формы, чтобы поля ввода располагались более аккуратно. Добавьте в `styles.css`:</code>css
form {
    display: flex;
    flex-direction: column;
    gap: 1rem; /<em> Отступ между элементами формы </em>/
}</p>
<p>form label {
    font-weight: bold;
    margin-top: 0.5rem;
}</p>
<p>form input[type="text"],
form input[type="email"],
form input[type="tel"],
form input[type="date"],
form select,
form textarea {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    font-size: 1em;
    box-sizing: border-box; /<em> Важно для корректной ширины </em>/
}</p>
<p>form fieldset {
    border: 1px solid #eee;
    padding: 1.5rem;
    border-radius: 8px;
    margin-bottom: 1.5rem;
}</p>
<p>form legend {
    font-size: 1.3em;
    font-weight: bold;
    color: #34495e;
    padding: 0 10px;
}</p>
<p>form button {
    background-color: #3498db;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1.1em;
    transition: background-color 0.3s ease;
}</p>
<p>form button:hover {
    background-color: #2980b9;
}</p>
<p>form input[type="checkbox"],
form input[type="radio"] {
    margin-right: 5px;
}
<code>3.  **Стилизуйте галерею изображений:** В `gallery.html` добавьте стили для класса `image-gallery`.</code>css
.image-gallery {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /<em> Адаптивная сетка </em>/
    gap: 20px; /<em> Отступ между элементами сетки </em>/
}</p>
<p>.image-gallery figure {
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    text-align: center;
    padding-bottom: 15px;
}</p>
<p>.image-gallery img {
    width: 100%;
    height: 200px; /<em> Фиксированная высота для изображений </em>/
    object-fit: cover; /<em> Обрезка изображения для заполнения </em>/
    border-bottom: 1px solid #eee;
    margin-bottom: 10px;
}</p>
<p>.image-gallery figcaption {
    font-size: 0.9em;
    color: #555;
    padding: 0 10px;
}
<code>``
4.  **Проверьте изменения:** Обновите страницы</code>contact.html<code>и</code>gallery.html`. Убедитесь, что формы и галерея выглядят стилизованными и аккуратными.</p>
</li>
</ol>
<h4>Шаг 4: Создание адаптивной карточки товара с Flexbox и Grid</h4>
<ol>
<li><strong>Создайте новый HTML-файл <code>product-card.html</code>:</strong> В папке <code>my-portfolio-website</code> создайте файл <code>product-card.html</code>.</li>
<li><strong>Добавьте HTML-структуру карточки товара:</strong>
    <code>html
    &lt;!DOCTYPE html&gt;
    &lt;html lang="ru"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;Карточка товара&lt;/title&gt;
        &lt;link rel="stylesheet" href="product-card-styles.css"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="container"&gt;
            &lt;div class="product-card"&gt;
                &lt;div class="product-image"&gt;
                    &lt;img src="https://via.placeholder.com/300x200?text=Смартфон" alt="Смартфон"&gt;
                    &lt;div class="discount-badge"&gt;-20%&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="product-info"&gt;
                    &lt;h2 class="product-title"&gt;Смартфон X100&lt;/h2&gt;
                    &lt;p class="product-description"&gt;Мощный смартфон с передовыми функциями и стильным дизайном. Идеально подходит для работы и развлечений.&lt;/p&gt;
                    &lt;div class="product-rating"&gt;
                        &lt;span class="stars"&gt;★★★★☆&lt;/span&gt;
                        &lt;span class="rating-text"&gt;(4.0 из 5)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class="product-price"&gt;
                        &lt;span class="old-price"&gt;50 000 ₽&lt;/span&gt;
                        &lt;span class="current-price"&gt;40 000 ₽&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class="product-actions"&gt;
                        &lt;button class="btn btn-primary"&gt;Купить&lt;/button&gt;
                        &lt;button class="btn btn-secondary"&gt;В корзину&lt;/button&gt;
                        &lt;button class="btn btn-icon"&gt;♡&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;</code></li>
<li><strong>Создайте новый CSS-файл <code>product-card-styles.css</code>:</strong> В той же папке <code>my-portfolio-website</code> создайте этот файл.</li>
<li>
<p><strong>Добавьте стили для карточки товара в <code>product-card-styles.css</code>:</strong>
    ```css
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f0f2f5;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
    }</p>
<p>.product-card {
    display: flex; /<em> Используем Flexbox для расположения изображения и информации </em>/
    background-color: white;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    overflow: hidden;
    max-width: 800px;
    width: 90%;
    margin: 20px;
}</p>
<p>.product-image {
    flex: 1; /<em> Изображение занимает доступное пространство </em>/
    position: relative;
}</p>
<p>.product-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}</p>
<p>.discount-badge {
    position: absolute;
    top: 15px;
    left: 15px;
    background-color: #e74c3c;
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-weight: bold;
    font-size: 0.9em;
}</p>
<p>.product-info {
    flex: 1.5; /<em> Информация занимает больше пространства </em>/
    padding: 25px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}</p>
<p>.product-title {
    font-size: 1.8em;
    color: #333;
    margin-bottom: 10px;
}</p>
<p>.product-description {
    font-size: 0.95em;
    color: #666;
    margin-bottom: 15px;
    line-height: 1.5;
}</p>
<p>.product-rating .stars {
    color: #f39c12;
    font-size: 1.2em;
}</p>
<p>.product-rating .rating-text {
    font-size: 0.9em;
    color: #888;
    margin-left: 5px;
}</p>
<p>.product-price {
    margin-top: 15px;
    margin-bottom: 20px;
}</p>
<p>.product-price .old-price {
    color: #888;
    text-decoration: line-through;
    margin-right: 10px;
}</p>
<p>.product-price .current-price {
    color: #27ae60;
    font-size: 1.5em;
    font-weight: bold;
}</p>
<p>.product-actions {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}</p>
<p>.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    transition: background-color 0.3s ease;
}</p>
<p>.btn-primary {
    background-color: #3498db;
    color: white;
}</p>
<p>.btn-primary:hover {
    background-color: #2980b9;
}</p>
<p>.btn-secondary {
    background-color: #ecf0f1;
    color: #333;
    border: 1px solid #ddd;
}</p>
<p>.btn-secondary:hover {
    background-color: #dbe4e6;
}</p>
<p>.btn-icon {
    background-color: #f1c40f;
    color: white;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 50%;
    font-size: 1.2em;
}</p>
<p>.btn-icon:hover {
    background-color: #f39c12;
}</p>
<p>/<em> Адаптивность для мобильных устройств </em>/
@media (max-width: 768px) {
    .product-card {
        flex-direction: column; /<em> На мобильных устройствах элементы располагаются вертикально </em>/
    }</p>
<pre><code>.product-image {
    height: 250px; /* Фиксированная высота для изображения на мобильных */
}

.product-info {
    padding: 15px;
}

.product-actions {
    flex-direction: column;
}

.btn {
    width: 100%;
}
</code></pre>
<p>}
<code>``
5.  **Проверьте адаптивность:** Откройте</code>product-card.html` в браузере. Изменяйте размер окна браузера, чтобы увидеть, как карточка товара адаптируется под разные размеры экрана. Используйте инструменты разработчика (Device Toolbar) для эмуляции мобильных устройств.</p>
</li>
</ol>
<h3>Критерии оценки Практической работы 3:</h3>
<ul>
<li>Все HTML-файлы портфолио корректно подключены к <code>styles.css</code>.</li>
<li>Применены базовые стили для <code>body</code>, заголовков, параграфов, ссылок, списков и изображений.</li>
<li>Шапка, навигация и подвал сайта стилизованы с использованием CSS.</li>
<li>Основной контент (<code>main</code>, <code>section</code>) стилизован, демонстрируя понимание блочной модели.</li>
<li>Форма в <code>contact.html</code> и галерея в <code>gallery.html</code> аккуратно стилизованы.</li>
<li>Создана адаптивная карточка товара с использованием Flexbox и медиа-запросов.</li>
<li>Код CSS организован, читаем и соответствует лучшим практикам.</li>
</ul>
<hr />
<h2>Практическая работа 4: Адаптивный дизайн</h2>
<h3>Цель работы:</h3>
<p>Освоить принципы адаптивного дизайна, научиться использовать медиа-запросы для создания отзывчивых макетов, которые корректно отображаются на различных устройствах (десктопы, планшеты, мобильные телефоны), и применять подход Mobile First.</p>
<h3>Задачи работы:</h3>
<ol>
<li>Понять концепцию адаптивного дизайна и его важность.</li>
<li>Использовать медиа-запросы для изменения стилей в зависимости от размера экрана.</li>
<li>Применить принцип Mobile First при разработке или адаптации макетов.</li>
<li>Обеспечить гибкость изображений и видео на веб-странице.</li>
<li>Настроить мета-тег <code>viewport</code>.</li>
</ol>
<h3>Необходимые инструменты:</h3>
<ul>
<li>VS Code с установленными расширениями.</li>
<li>Веб-браузер с инструментами разработчика (режим эмуляции мобильных устройств).</li>
<li>Проект <code>my-portfolio-website</code> из Практической работы 2 и 3.</li>
</ul>
<h3>Время выполнения: 3 академических часа (135 минут)</h3>
<h3>Пошаговый алгоритм выполнения:</h3>
<h4>Шаг 1: Настройка мета-тега Viewport и базовые принципы адаптивности</h4>
<ol>
<li><strong>Откройте все HTML-файлы портфолио:</strong> Убедитесь, что в секции <code>&lt;head&gt;</code> каждого HTML-файла (<code>index.html</code>, <code>about.html</code>, <code>portfolio.html</code>, <code>contact.html</code>, <code>gallery.html</code>, <code>product-card.html</code>) присутствует следующий мета-тег:
    <code>html
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code>
    Этот тег указывает браузеру, что ширина области просмотра должна соответствовать ширине устройства, а начальный масштаб должен быть 1.0. Это критически важно для корректного отображения на мобильных устройствах.</li>
<li><strong>Проверьте гибкость изображений:</strong> В <code>styles.css</code> (для портфолио) и <code>product-card-styles.css</code> (для карточки товара) убедитесь, что для изображений установлен стиль <code>max-width: 100%;</code> и <code>height: auto;</code>. Это гарантирует, что изображения не будут выходить за пределы своих контейнеров и будут масштабироваться пропорционально.
    <code>css
    img {
        max-width: 100%;
        height: auto;
        display: block;
    }</code></li>
<li><strong>Используйте относительные единицы измерения:</strong> В CSS старайтесь использовать относительные единицы измерения, такие как <code>em</code>, <code>rem</code>, <code>%</code>, <code>vw</code>, <code>vh</code> вместо фиксированных <code>px</code> для размеров шрифтов, отступов и ширины элементов. Это сделает ваш дизайн более гибким.<ul>
<li><code>rem</code> (root em): Относительно размера шрифта корневого элемента (<code>&lt;html&gt;</code>). Удобно для типографики.</li>
<li><code>%</code>: Относительно размера родительского элемента.</li>
<li><code>vw</code> (viewport width): Относительно ширины области просмотра (1vw = 1% ширины области просмотра).</li>
<li><code>vh</code> (viewport height): Относительно высоты области просмотра (1vh = 1% высоты области просмотра).</li>
</ul>
</li>
</ol>
<h4>Шаг 2: Применение медиа-запросов для адаптации навигации</h4>
<ol>
<li><strong>Определите точки останова (breakpoints):</strong> Решите, при каких ширинах экрана ваш макет должен меняться. Типичные точки останова:<ul>
<li>Мобильные устройства: до <code>768px</code></li>
<li>Планшеты: от <code>768px</code> до <code>1024px</code></li>
<li>Десктопы: от <code>1024px</code> и выше</li>
</ul>
</li>
<li><strong>Адаптируйте навигацию для мобильных устройств:</strong> В <code>styles.css</code> добавьте медиа-запрос, чтобы навигация стала вертикальной на маленьких экранах.
    ```css
    /<em> Стили для мобильных устройств (ширина экрана до 768px) </em>/
    @media (max-width: 768px) {
        nav ul {
            flex-direction: column; /<em> Элементы меню располагаются вертикально </em>/
            align-items: center; /<em> Выравнивание по центру </em>/
            padding: 10px 0;
        }<pre><code>nav li {
    margin: 10px 0; /* Отступы между элементами меню */
}

header h1 {
    font-size: 2rem;
}

header p {
    font-size: 1rem;
}

main {
    margin: 1rem auto;
    padding: 0 10px;
}

section {
    padding: 1rem;
}

/* Адаптация формы */
form fieldset {
    padding: 1rem;
}

form legend {
    font-size: 1.1em;
}

form button {
    width: 100%;
    margin-bottom: 10px;
}

/* Адаптация галереи */
.image-gallery {
    grid-template-columns: 1fr; /* Одна колонка на мобильных */
}

.image-gallery img {
    height: auto;
}
</code></pre>
<p>}
<code>``
3.  **Проверьте адаптивность навигации:** Откройте</code>index.html<code>в браузере. Откройте инструменты разработчика (</code>F12`) и используйте "Device Toolbar" (значок мобильного телефона/планшета) для эмуляции различных размеров экрана. Уменьшайте ширину окна браузера и наблюдайте, как навигация меняет свою ориентацию.</p>
</li>
</ol>
<h4>Шаг 3: Адаптация основного контента и форм</h4>
<ol>
<li><strong>Адаптируйте основной контент:</strong> В том же медиа-запросе <code>@media (max-width: 768px)</code> (или создайте новый для планшетов <code>@media (max-width: 1024px)</code>) измените отступы и размеры шрифтов для <code>main</code> и <code>section</code>, чтобы они лучше смотрелись на маленьких экранах.</li>
<li><strong>Адаптируйте формы:</strong> Убедитесь, что поля ввода в формах (<code>contact.html</code>) занимают 100% ширины контейнера на мобильных устройствах. Это уже должно быть реализовано с помощью <code>width: 100%;</code> и <code>box-sizing: border-box;</code>.</li>
<li><strong>Адаптируйте галерею изображений:</strong> В <code>styles.css</code> внутри медиа-запроса для мобильных устройств измените <code>grid-template-columns</code> для <code>.image-gallery</code>, чтобы изображения располагались в одну колонку.
    <code>css
    @media (max-width: 768px) {
        /* ... другие стили ... */
        .image-gallery {
            grid-template-columns: 1fr; /* Одна колонка на мобильных */
        }
    }</code></li>
</ol>
<h4>Шаг 4: Принцип Mobile First</h4>
<p>Принцип Mobile First означает, что вы сначала разрабатываете дизайн и стили для самых маленьких экранов (мобильных устройств), а затем постепенно добавляете стили для больших экранов с помощью медиа-запросов <code>min-width</code>.</p>
<ol>
<li>
<p><strong>Перестройте стили (опционально, для понимания):</strong> Чтобы полностью следовать принципу Mobile First, вы бы сначала написали все базовые стили для мобильных устройств без медиа-запросов. Затем, для больших экранов, вы бы использовали <code>min-width</code>.
    <em>Пример структуры CSS с Mobile First:</em>
    ```css
    /<em> Базовые стили для мобильных устройств </em>/
    body {
        font-size: 16px;
        /<em> ... </em>/
    }</p>
<p>nav ul {
    flex-direction: column;
    /<em> ... </em>/
}</p>
<p>/<em> Стили для планшетов и больше </em>/
@media (min-width: 768px) {
    nav ul {
        flex-direction: row;
        /<em> ... </em>/
    }
    /<em> ... другие стили для планшетов ... </em>/
}</p>
<p>/<em> Стили для десктопов и больше </em>/
@media (min-width: 1024px) {
    /<em> ... стили для десктопов ... </em>/
}
```
<em>В рамках этой практической работы достаточно адаптировать существующий код, но важно понимать концепцию Mobile First для будущих проектов.</em></p>
</li>
</ol>
<h4>Шаг 5: Тестирование адаптивности</h4>
<ol>
<li><strong>Используйте инструменты разработчика:</strong> Откройте <code>index.html</code> (или любую другую страницу портфолио) в браузере. Включите "Device Toolbar" (<code>Ctrl+Shift+M</code> в Chrome/Firefox) и выберите различные предустановленные устройства (iPhone, iPad, Pixel и т.д.).</li>
<li><strong>Проверьте поведение элементов:</strong> Убедитесь, что текст читаем, изображения не выходят за границы, навигация удобна, а формы корректно отображаются на всех размерах экрана.</li>
<li><strong>Ручное изменение размера окна:</strong> Попробуйте вручную изменять размер окна браузера, чтобы увидеть плавность переходов между точками останова.</li>
</ol>
<h3>Критерии оценки Практической работы 4:</h3>
<ul>
<li>Все HTML-файлы содержат корректный мета-тег <code>viewport</code>.</li>
<li>Изображения и видео являются гибкими (<code>max-width: 100%; height: auto;</code>).</li>
<li>Навигация адаптируется для мобильных устройств (например, становится вертикальной).</li>
<li>Основной контент и формы корректно отображаются на разных размерах экрана.</li>
<li>Студент продемонстрировал понимание и применение медиа-запросов.</li>
<li>Студент умеет использовать инструменты разработчика для тестирования адаптивности.</li>
</ul>
<hr />
<h2>Практическая работа 5: Введение в JavaScript</h2>
<h3>Цель работы:</h3>
<p>Освоить базовые концепции языка JavaScript, научиться работать с переменными, типами данных, операторами, условными конструкциями и циклами, а также взаимодействовать с HTML-элементами через DOM (Document Object Model) и обрабатывать события.</p>
<h3>Задачи работы:</h3>
<ol>
<li>Понять роль JavaScript в веб-разработке.</li>
<li>Использовать переменные, типы данных и операторы.</li>
<li>Применять условные конструкции (<code>if/else</code>, <code>switch</code>) и циклы (<code>for</code>, <code>while</code>).</li>
<li>Взаимодействовать с DOM: получать доступ к элементам, изменять их содержимое и стили.</li>
<li>Обрабатывать пользовательские события (клики, ввод с клавиатуры, отправка форм).</li>
</ol>
<h3>Необходимые инструменты:</h3>
<ul>
<li>VS Code с установленными расширениями.</li>
<li>Веб-браузер с инструментами разработчика (вкладка Console).</li>
<li>Проект <code>my-portfolio-website</code> из предыдущих практических работ.</li>
</ul>
<h3>Время выполнения: 4 академических часа (180 минут)</h3>
<h3>Пошаговый алгоритм выполнения:</h3>
<h4>Шаг 1: Подключение JavaScript и основы синтаксиса</h4>
<ol>
<li><strong>Создайте JavaScript-файл:</strong> В папке <code>my-portfolio-website</code> создайте новую папку <code>js</code> и внутри нее файл <code>script.js</code>.</li>
<li><strong>Подключите <code>script.js</code> к <code>index.html</code>:</strong> Откройте <code>index.html</code> и добавьте следующую строку перед закрывающим тегом <code>&lt;/body&gt;</code>:
    <code>html
    &lt;script src="js/script.js"&gt;&lt;/script&gt;</code>
    <em>Важно:</em> Размещайте тег <code>&lt;script&gt;</code> в конце <code>&lt;body&gt;</code>, чтобы HTML-документ был полностью загружен и доступен для манипуляций JavaScript.</li>
<li><strong>Первая строка кода:</strong> В <code>script.js</code> напишите:
    <code>javascript
    console.log("Привет из JavaScript!");</code>
    Откройте <code>index.html</code> через Live Server, откройте инструменты разработчика (F12) и перейдите на вкладку <code>Console</code>. Вы должны увидеть сообщение "Привет из JavaScript!".</li>
<li>
<p><strong>Переменные и типы данных:</strong> В <code>script.js</code> добавьте:
    ```javascript
    // Объявление переменных
    let userName = "Иван"; // Строка
    const userAge = 30; // Число (константа)
    let isStudent = true; // Булево значение
    let hobbies = ["чтение", "программирование", "спорт"]; // Массив
    let userProfile = { // Объект
        name: userName,
        age: userAge,
        city: "Москва"
    };</p>
<p>console.log("Имя пользователя:", userName);
console.log("Возраст пользователя:", userAge);
console.log("Студент:", isStudent);
console.log("Хобби:", hobbies);
console.log("Профиль пользователя:", userProfile);</p>
<p>// Изменение переменной
userName = "Алексей";
console.log("Новое имя пользователя:", userName);</p>
<p>// Попытка изменить константу (вызовет ошибку)
// userAge = 31;
<code>5.  **Операторы:**</code>javascript
let a = 10;
let b = 5;</p>
<p>console.log("Сложение:", a + b); // 15
console.log("Вычитание:", a - b); // 5
console.log("Умножение:", a * b); // 50
console.log("Деление:", a / b); // 2
console.log("Остаток от деления:", a % b); // 0</p>
<p>let greeting = "Привет, " + userName + "!";
console.log(greeting);</p>
<p>console.log("Равно ли a b?", a == b); // false
console.log("Строго равно ли a b?", a === b); // false
console.log("a больше b?", a &gt; b); // true
```</p>
</li>
</ol>
<h4>Шаг 2: Условные конструкции и циклы</h4>
<ol>
<li>
<p><strong>Условные конструкции (<code>if/else</code>):</strong>
    ```javascript
    let temperature = 25;</p>
<p>if (temperature &gt; 30) {
    console.log("Очень жарко!");
} else if (temperature &gt; 20) {
    console.log("Тепло и комфортно.");
} else {
    console.log("Прохладно.");
}</p>
<p>// Тернарный оператор
let message = (userAge &gt;= 18) ? "Совершеннолетний" : "Несовершеннолетний";
console.log(message);
<code>2.  **Конструкция `switch`:**</code>javascript
let dayOfWeek = "среда";</p>
<p>switch (dayOfWeek) {
    case "понедельник":
        console.log("Начало рабочей недели.");
        break;
    case "среда":
        console.log("Середина недели.");
        break;
    case "пятница":
        console.log("Конец рабочей недели!");
        break;
    default:
        console.log("Обычный день.");
}
<code>3.  **Циклы (`for`, `while`):**</code>javascript
// Цикл for
for (let i = 0; i &lt; 5; i++) {
    console.log("Итерация for: " + i);
}</p>
<p>// Цикл while
let count = 0;
while (count &lt; 3) {
    console.log("Итерация while: " + count);
    count++;
}</p>
<p>// Цикл for...of для массивов
for (let hobby of hobbies) {
    console.log("Мое хобби: " + hobby);
}</p>
<p>// Цикл for...in для объектов (для перебора ключей)
for (let key in userProfile) {
    console.log(key + ": " + userProfile[key]);
}
```</p>
</li>
</ol>
<h4>Шаг 3: Манипуляции с DOM (Document Object Model)</h4>
<p>DOM представляет собой программный интерфейс для HTML и XML документов. Он позволяет JavaScript получать доступ к содержимому документа, изменять его структуру, стили и реагировать на события.</p>
<ol>
<li>
<p><strong>Получение элементов:</strong> В <code>index.html</code> добавьте <code>id</code> к заголовку <code>&lt;h1&gt;</code> и параграфу <code>&lt;p&gt;</code>:
    <code>html
    &lt;h1 id="main-title"&gt;Добро пожаловать в мир веб-разработки!&lt;/h1&gt;
    &lt;p id="intro-paragraph"&gt;Это моя первая HTML-страница, созданная в рамках курса.&lt;/p&gt;</code>
    В <code>script.js</code>:
    ```javascript
    // Получение элемента по ID
    const mainTitle = document.getElementById("main-title");
    console.log("Элемент заголовка:", mainTitle);</p>
<p>// Получение элементов по классу (возвращает HTMLCollection)
const sections = document.getElementsByClassName("section"); // Если у вас есть классы section
console.log("Секции:", sections);</p>
<p>// Получение элементов по тегу (возвращает HTMLCollection)
const paragraphs = document.getElementsByTagName("p");
console.log("Параграфы:", paragraphs);</p>
<p>// Современные методы: querySelector и querySelectorAll
const firstParagraph = document.querySelector("#intro-paragraph"); // По ID
console.log("Первый параграф (querySelector):", firstParagraph);</p>
<p>const allListItems = document.querySelectorAll("ul li"); // Все элементы списка внутри ul
console.log("Все элементы списка:", allListItems);
<code>2.  **Изменение содержимого и атрибутов:**</code>javascript
// Изменение текстового содержимого
mainTitle.textContent = "Изучаем DOM с JavaScript!";</p>
<p>// Изменение HTML-содержимого
firstParagraph.innerHTML = "Это <strong>обновленный</strong> параграф с <em>HTML</em>.";</p>
<p>// Изменение атрибутов (например, src для изображения)
const authorImage = document.querySelector("img");
if (authorImage) {
    authorImage.src = "https://via.placeholder.com/400x300?text=Новое+изображение";
    authorImage.alt = "Новое описание изображения";
}
<code>3.  **Изменение стилей:**</code>javascript
// Изменение стиля напрямую (не рекомендуется для больших объемов)
mainTitle.style.color = "#e74c3c";
mainTitle.style.fontSize = "3rem";</p>
<p>// Добавление/удаление классов (предпочтительный способ)
mainTitle.classList.add("highlight");
// В styles.css добавьте:
// .highlight { border: 2px solid blue; padding: 10px; }</p>
<p>// Удаление класса
// mainTitle.classList.remove("highlight");</p>
<p>// Переключение класса
// mainTitle.classList.toggle("active");
<code>4.  **Создание и удаление элементов:**</code>javascript
// Создание нового элемента
const newParagraph = document.createElement("p");
newParagraph.textContent = "Этот параграф был создан JavaScript.";
newParagraph.style.color = "green";</p>
<p>// Добавление элемента в DOM (например, в main)
const mainSection = document.querySelector("main section");
if (mainSection) {
    mainSection.appendChild(newParagraph);
}</p>
<p>// Удаление элемента
// mainSection.removeChild(newParagraph);
```</p>
</li>
</ol>
<h4>Шаг 4: Обработка событий</h4>
<p>События позволяют JavaScript реагировать на действия пользователя (клики, ввод, наведение мыши) или изменения в браузере.</p>
<ol>
<li><strong>Добавьте кнопку в <code>index.html</code>:</strong>
    <code>html
    &lt;button id="my-button"&gt;Нажми меня!&lt;/button&gt;</code></li>
<li>
<p><strong>Обработка события клика:</strong> В <code>script.js</code>:
    ```javascript
    const myButton = document.getElementById("my-button");</p>
<p>// Способ 1: Использование addEventListener (предпочтительный)
myButton.addEventListener("click", function() {
    alert("Кнопка была нажата!");
    mainTitle.style.color = "purple";
});</p>
<p>// Способ 2: Через свойство (не рекомендуется, так как можно назначить только один обработчик)
// myButton.onclick = function() {
//     console.log("Кнопка нажата через onclick!");
// };
<code>3.  **Обработка события ввода:** Добавьте поле ввода в `index.html`:</code>html
<input type="text" id="my-input" placeholder="Введите что-нибудь">
<p id="input-display"></p>
<code>В `script.js`:</code>javascript
const myInput = document.getElementById("my-input");
const inputDisplay = document.getElementById("input-display");</p>
<p>myInput.addEventListener("input", function() {
    inputDisplay.textContent = "Вы ввели: " + myInput.value;
});
<code>4.  **Обработка события отправки формы:** В `contact.html` найдите тег `&lt;form&gt;` и добавьте ему `id="contact-form"`.</code>html
<form id="contact-form" action="#" method="post">
<code>В `script.js`:</code>javascript
const contactForm = document.getElementById("contact-form");</p>
<p>contactForm.addEventListener("submit", function(event) {
    event.preventDefault(); // Отменяем стандартное поведение отправки формы (перезагрузку страницы)
    alert("Форма отправлена! (На самом деле нет, это только демонстрация)");</p>
<pre><code>// Получение данных формы
const firstName = document.getElementById("firstName").value;
const email = document.getElementById("email").value;
const message = document.getElementById("bio").value;

console.log("Имя:", firstName);
console.log("Email:", email);
console.log("Сообщение:", message);

// Здесь можно было бы отправить данные на сервер (AJAX)
</code></pre>
<p>});
```</p>
</li>
</ol>
<h3>Критерии оценки Практической работы 5:</h3>
<ul>
<li>JavaScript-файл корректно подключен к HTML-документу.</li>
<li>Студент продемонстрировал понимание и использование переменных, типов данных и операторов.</li>
<li>Применены условные конструкции (<code>if/else</code>, <code>switch</code>) и циклы (<code>for</code>, <code>while</code>, <code>for...of</code>, <code>for...in</code>).</li>
<li>Выполнены манипуляции с DOM: получение элементов, изменение их содержимого, атрибутов и стилей.</li>
<li>Реализована обработка различных пользовательских событий (клик, ввод, отправка формы).</li>
<li>Код JavaScript читаем, логичен и соответствует базовым стандартам.</li>
</ul>
<hr />
<h2>Практическая работа 6: Практика и развертывание</h2>
<h3>Цель работы:</h3>
<p>Применить полученные знания и навыки для создания полноценного веб-сайта-портфолио, объединив HTML, CSS и JavaScript, а также освоить базовые методы развертывания статических веб-сайтов на GitHub Pages.</p>
<h3>Задачи работы:</h3>
<ol>
<li>Разработать структуру и контент для сайта-портфолио.</li>
<li>Применить CSS для стилизации и адаптации макета.</li>
<li>Использовать JavaScript для добавления интерактивности.</li>
<li>Подготовить проект к развертыванию.</li>
<li>Опубликовать сайт на GitHub Pages.</li>
</ol>
<h3>Необходимые инструменты:</h3>
<ul>
<li>VS Code с установленными расширениями.</li>
<li>Веб-браузер.</li>
<li>Аккаунт на GitHub.</li>
<li>Проект <code>my-portfolio-website</code> из предыдущих практических работ.</li>
</ul>
<h3>Время выполнения: 2 академических часа (90 минут)</h3>
<h3>Пошаговый алгоритм выполнения:</h3>
<h4>Шаг 1: Доработка сайта-портфолио</h4>
<ol>
<li><strong>Объедините все страницы:</strong> Убедитесь, что ваш проект <code>my-portfolio-website</code> содержит все страницы, разработанные в предыдущих практических работах (<code>index.html</code>, <code>about.html</code>, <code>portfolio.html</code>, <code>contact.html</code>, <code>gallery.html</code>).</li>
<li><strong>Добавьте уникальный контент:</strong> Заполните страницы реальным или вымышленным, но осмысленным контентом. Например:<ul>
<li>На странице "Обо мне" напишите краткую биографию, свои интересы и цели.</li>
<li>На странице "Портфолио" опишите 2-3 вымышленных или реальных проекта, которые вы могли бы сделать. Для каждого проекта:<ul>
<li>Заголовок проекта.</li>
<li>Краткое описание.</li>
<li>Изображение-превью (можно использовать placeholder).</li>
<li>Ссылка на "демо" (пока может быть заглушкой <code>#</code>).</li>
<li>Список использованных технологий (HTML, CSS, JS, Flexbox, Grid и т.д.).</li>
</ul>
</li>
<li>На странице "Контакты" убедитесь, что форма выглядит аккуратно и все поля имеют соответствующие типы и атрибуты.</li>
</ul>
</li>
<li><strong>Улучшите стилизацию:</strong><ul>
<li>Просмотрите <code>styles.css</code> и убедитесь, что все элементы сайта выглядят гармонично.</li>
<li>Добавьте эффекты наведения (<code>:hover</code>) для кнопок, ссылок, карточек проектов.</li>
<li>Убедитесь, что сайт хорошо выглядит на мобильных устройствах (проверьте с помощью инструментов разработчика).</li>
</ul>
</li>
<li><strong>Добавьте интерактивность с JavaScript:</strong><ul>
<li><strong>Динамическое изменение текста:</strong> На главной странице добавьте кнопку, по клику на которую меняется текст приветствия.</li>
<li><strong>Скрытие/показ элементов:</strong> На странице "Обо мне" добавьте секцию "Мои достижения", которая изначально скрыта, и кнопку "Показать достижения", которая ее отображает.</li>
<li><strong>Валидация формы (простая):</strong> В <code>contact.html</code> добавьте JavaScript-код, который проверяет, что поля "Имя" и "Email" не пустые перед отправкой формы. Если они пустые, выведите <code>alert()</code> сообщение.</li>
</ul>
</li>
</ol>
<h4>Шаг 2: Подготовка проекта к развертыванию</h4>
<ol>
<li><strong>Создайте репозиторий на GitHub:</strong><ul>
<li>Перейдите на <a href="https://github.com/">GitHub</a> и войдите в свой аккаунт.</li>
<li>Нажмите на кнопку "New" (или "+ New repository") для создания нового репозитория.</li>
<li>Назовите репозиторий <code>my-portfolio</code> (или любое другое подходящее имя).</li>
<li>Установите его как "Public".</li>
<li><strong>НЕ</strong> ставьте галочку "Add a README file" на этом этапе.</li>
<li>Нажмите "Create repository".</li>
</ul>
</li>
<li><strong>Инициализируйте Git в локальной папке:</strong> Откройте терминал (или встроенный терминал VS Code: <code>Ctrl+</code>~<code>`) и перейдите в папку</code>my-portfolio-website`.
    <code>bash
    cd my-portfolio-website
    git init</code></li>
<li><strong>Добавьте все файлы в Git:</strong>
    <code>bash
    git add .</code></li>
<li><strong>Сделайте первый коммит:</strong>
    <code>bash
    git commit -m "Initial commit: My portfolio website"</code></li>
<li><strong>Свяжите локальный репозиторий с удаленным на GitHub:</strong> Скопируйте команды, которые GitHub предлагает после создания репозитория. Они будут выглядеть примерно так:
    <code>bash
    git branch -M main
    git remote add origin https://github.com/ВАШ_НИКНЕЙМ/my-portfolio.git
    git push -u origin main</code>
    Замените <code>ВАШ_НИКНЕЙМ</code> на ваш реальный никнейм на GitHub.</li>
</ol>
<h4>Шаг 3: Развертывание на GitHub Pages</h4>
<ol>
<li><strong>Настройте GitHub Pages:</strong><ul>
<li>На GitHub, в вашем репозитории <code>my-portfolio</code>, перейдите на вкладку <code>Settings</code>.</li>
<li>В левом меню выберите <code>Pages</code>.</li>
<li>В разделе "Build and deployment" -&gt; "Source" выберите <code>Deploy from a branch</code>.</li>
<li>В разделе "Branch" выберите <code>main</code> (или <code>master</code>, если вы использовали его) и папку <code>/ (root)</code>.</li>
<li>Нажмите <code>Save</code>.</li>
</ul>
</li>
<li><strong>Дождитесь публикации:</strong> GitHub Pages начнет процесс сборки и публикации вашего сайта. Это может занять несколько минут. После завершения вы увидите ссылку на ваш опубликованный сайт (обычно <code>https://ВАШ_НИКНЕЙМ.github.io/my-portfolio/</code>).</li>
<li><strong>Проверьте опубликованный сайт:</strong> Откройте ссылку в браузере и убедитесь, что ваш сайт корректно отображается.</li>
</ol>
<h3>Критерии оценки Практической работы 6:</h3>
<ul>
<li>Сайт-портфолио содержит все необходимые страницы с осмысленным контентом.</li>
<li>Дизайн сайта является адаптивным и выглядит хорошо на разных устройствах.</li>
<li>Присутствует интерактивность, реализованная с помощью JavaScript (минимум 3 примера).</li>
<li>Проект успешно инициализирован в Git и загружен на GitHub.</li>
<li>Сайт корректно опубликован на GitHub Pages и доступен по публичной ссылке.</li>
</ul>
<hr />
<h2>Практическая работа 7: Интерактивная галерея изображений</h2>
<h3>Цель работы:</h3>
<p>Создать интерактивную галерею изображений с использованием JavaScript, которая позволяет пользователям просматривать изображения в полноэкранном режиме, переключаться между ними и добавлять новые изображения динамически.</p>
<h3>Задачи работы:</h3>
<ol>
<li>Создать HTML-структуру для галереи изображений.</li>
<li>Стилизовать галерею с помощью CSS, используя Grid Layout.</li>
<li>Реализовать функциональность просмотра изображений в модальном окне.</li>
<li>Добавить навигацию между изображениями (предыдущее/следующее).</li>
<li>Создать возможность добавления новых изображений через форму.</li>
<li>Реализовать фильтрацию изображений по категориям.</li>
</ol>
<h3>Необходимые инструменты:</h3>
<ul>
<li>VS Code с установленными расширениями.</li>
<li>Веб-браузер с инструментами разработчика.</li>
<li>Базовые знания HTML, CSS и JavaScript из предыдущих практических работ.</li>
</ul>
<h3>Время выполнения: 3 академических часа (135 минут)</h3>
<h3>Пошаговый алгоритм выполнения:</h3>
<h4>Шаг 1: Создание HTML-структуры галереи</h4>
<ol>
<li><strong>Создайте новый проект:</strong> В вашей рабочей папке <code>web-development-course</code> создайте новую папку <code>interactive-gallery</code>.</li>
<li><strong>Создайте основные файлы:</strong> Внутри папки <code>interactive-gallery</code> создайте:<ul>
<li><code>index.html</code></li>
<li><code>styles.css</code></li>
<li><code>script.js</code></li>
</ul>
</li>
<li><strong>Создайте HTML-структуру в <code>index.html</code>:</strong>
    ```html
    &lt;!DOCTYPE html&gt;
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Интерактивная галерея изображений</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <header>
            <h1>Моя интерактивная галерея</h1>
            <div class="filter-buttons">
                <button class="filter-btn active" data-filter="all">Все</button>
                <button class="filter-btn" data-filter="nature">Природа</button>
                <button class="filter-btn" data-filter="city">Город</button>
                <button class="filter-btn" data-filter="people">Люди</button>
            </div>
        </header><pre><code>&lt;main&gt;
    &lt;section class="add-image-section"&gt;
        &lt;h2&gt;Добавить новое изображение&lt;/h2&gt;
        &lt;form id="add-image-form"&gt;
            &lt;input type="url" id="image-url" placeholder="URL изображения" required&gt;
            &lt;input type="text" id="image-title" placeholder="Название изображения" required&gt;
            &lt;select id="image-category" required&gt;
                &lt;option value=""&gt;Выберите категорию&lt;/option&gt;
                &lt;option value="nature"&gt;Природа&lt;/option&gt;
                &lt;option value="city"&gt;Город&lt;/option&gt;
                &lt;option value="people"&gt;Люди&lt;/option&gt;
            &lt;/select&gt;
            &lt;button type="submit"&gt;Добавить изображение&lt;/button&gt;
        &lt;/form&gt;
    &lt;/section&gt;

    &lt;section class="gallery-section"&gt;
        &lt;div class="gallery-grid" id="gallery-grid"&gt;
            &lt;!-- Изображения будут добавляться динамически через JavaScript --&gt;
        &lt;/div&gt;
    &lt;/section&gt;
&lt;/main&gt;

&lt;!-- Модальное окно для просмотра изображений --&gt;
&lt;div class="modal" id="image-modal"&gt;
    &lt;div class="modal-content"&gt;
        &lt;span class="close-btn" id="close-modal"&gt;&amp;times;&lt;/span&gt;
        &lt;button class="nav-btn prev-btn" id="prev-btn"&gt;&amp;#8249;&lt;/button&gt;
        &lt;img class="modal-image" id="modal-image" src="" alt=""&gt;
        &lt;button class="nav-btn next-btn" id="next-btn"&gt;&amp;#8250;&lt;/button&gt;
        &lt;div class="modal-info"&gt;
            &lt;h3 id="modal-title"&gt;&lt;/h3&gt;
            &lt;p id="modal-category"&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script src="script.js"&gt;&lt;/script&gt;
</code></pre>
<p></body>
</html>
```</p>
</li>
</ol>
<h4>Шаг 2: Стилизация галереи с помощью CSS</h4>
<ol>
<li>
<p><strong>Добавьте базовые стили в <code>styles.css</code>:</strong>
    ```css</p>
<ul>
<li>{
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}</li>
</ul>
<p>body {
    font-family: 'Arial', sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f8f9fa;
}</p>
<p>header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    text-align: center;
    padding: 2rem 0;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}</p>
<p>header h1 {
    margin-bottom: 1rem;
    font-size: 2.5rem;
}</p>
<p>.filter-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
}</p>
<p>.filter-btn {
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
}</p>
<p>.filter-btn:hover,
.filter-btn.active {
    background-color: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
}</p>
<p>main {
    max-width: 1200px;
    margin: 2rem auto;
    padding: 0 20px;
}</p>
<p>.add-image-section {
    background-color: white;
    padding: 2rem;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    margin-bottom: 2rem;
}</p>
<p>.add-image-section h2 {
    margin-bottom: 1rem;
    color: #2c3e50;
}</p>
<h1>add-image-form {</h1>
<pre><code>display: grid;
grid-template-columns: 1fr 1fr 1fr auto;
gap: 15px;
align-items: end;
</code></pre>
<p>}</p>
<h1>add-image-form input,</h1>
<h1>add-image-form select {</h1>
<pre><code>padding: 10px;
border: 2px solid #e1e8ed;
border-radius: 5px;
font-size: 1rem;
transition: border-color 0.3s ease;
</code></pre>
<p>}</p>
<h1>add-image-form input:focus,</h1>
<h1>add-image-form select:focus {</h1>
<pre><code>outline: none;
border-color: #667eea;
</code></pre>
<p>}</p>
<h1>add-image-form button {</h1>
<pre><code>background-color: #667eea;
color: white;
border: none;
padding: 10px 20px;
border-radius: 5px;
cursor: pointer;
font-size: 1rem;
transition: background-color 0.3s ease;
</code></pre>
<p>}</p>
<h1>add-image-form button:hover {</h1>
<pre><code>background-color: #5a6fd8;
</code></pre>
<p>}</p>
<p>.gallery-section {
    background-color: white;
    padding: 2rem;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}</p>
<p>.gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 20px;
    margin-top: 1rem;
}</p>
<p>.gallery-item {
    position: relative;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    cursor: pointer;
    background-color: #f8f9fa;
}</p>
<p>.gallery-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}</p>
<p>.gallery-item img {
    width: 100%;
    height: 200px;
    object-fit: cover;
    display: block;
}</p>
<p>.gallery-item-info {
    padding: 15px;
}</p>
<p>.gallery-item-title {
    font-size: 1.1rem;
    font-weight: bold;
    margin-bottom: 5px;
    color: #2c3e50;
}</p>
<p>.gallery-item-category {
    font-size: 0.9rem;
    color: #7f8c8d;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}</p>
<p>/<em> Стили для модального окна </em>/
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    animation: fadeIn 0.3s ease;
}</p>
<p>.modal-content {
    position: relative;
    margin: auto;
    padding: 20px;
    width: 90%;
    max-width: 800px;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}</p>
<p>.close-btn {
    position: absolute;
    top: 20px;
    right: 30px;
    color: white;
    font-size: 40px;
    font-weight: bold;
    cursor: pointer;
    z-index: 1001;
    transition: color 0.3s ease;
}</p>
<p>.close-btn:hover {
    color: #ccc;
}</p>
<p>.modal-image {
    max-width: 100%;
    max-height: 70vh;
    object-fit: contain;
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}</p>
<p>.nav-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    font-size: 30px;
    padding: 10px 15px;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s ease;
}</p>
<p>.nav-btn:hover {
    background-color: rgba(255, 255, 255, 0.3);
}</p>
<p>.prev-btn {
    left: 20px;
}</p>
<p>.next-btn {
    right: 20px;
}</p>
<p>.modal-info {
    text-align: center;
    color: white;
    margin-top: 20px;
}</p>
<p>.modal-info h3 {
    font-size: 1.5rem;
    margin-bottom: 5px;
}</p>
<p>.modal-info p {
    font-size: 1rem;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 1px;
}</p>
<p>@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}</p>
<p>/<em> Адаптивность </em>/
@media (max-width: 768px) {
    #add-image-form {
        grid-template-columns: 1fr;
    }</p>
<pre><code>.gallery-grid {
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 15px;
}

header h1 {
    font-size: 2rem;
}

.nav-btn {
    font-size: 24px;
    padding: 8px 12px;
}

.prev-btn {
    left: 10px;
}

.next-btn {
    right: 10px;
}
</code></pre>
<p>}
```</p>
</li>
</ol>
<h4>Шаг 3: Реализация JavaScript функциональности</h4>
<ol>
<li>
<p><strong>Добавьте базовую структуру JavaScript в <code>script.js</code>:</strong>
    ```javascript
    // Массив для хранения изображений
    let images = [
        {
            id: 1,
            url: "https://via.placeholder.com/400x300?text=Природа+1",
            title: "Горный пейзаж",
            category: "nature"
        },
        {
            id: 2,
            url: "https://via.placeholder.com/400x300?text=Город+1",
            title: "Городская архитектура",
            category: "city"
        },
        {
            id: 3,
            url: "https://via.placeholder.com/400x300?text=Люди+1",
            title: "Портрет",
            category: "people"
        },
        {
            id: 4,
            url: "https://via.placeholder.com/400x300?text=Природа+2",
            title: "Лесной водопад",
            category: "nature"
        },
        {
            id: 5,
            url: "https://via.placeholder.com/400x300?text=Город+2",
            title: "Ночной город",
            category: "city"
        },
        {
            id: 6,
            url: "https://via.placeholder.com/400x300?text=Люди+2",
            title: "Семейное фото",
            category: "people"
        }
    ];</p>
<p>// Переменные для модального окна
let currentImageIndex = 0;
let filteredImages = [...images];</p>
<p>// Получение элементов DOM
const galleryGrid = document.getElementById('gallery-grid');
const modal = document.getElementById('image-modal');
const modalImage = document.getElementById('modal-image');
const modalTitle = document.getElementById('modal-title');
const modalCategory = document.getElementById('modal-category');
const closeBtn = document.getElementById('close-modal');
const prevBtn = document.getElementById('prev-btn');
const nextBtn = document.getElementById('next-btn');
const addImageForm = document.getElementById('add-image-form');
const filterButtons = document.querySelectorAll('.filter-btn');</p>
<p>// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', function() {
    renderGallery();
    setupEventListeners();
});
```</p>
</li>
<li>
<p><strong>Добавьте функцию для отображения галереи:</strong>
    ```javascript
    // Функция для отображения галереи
    function renderGallery(imagesToShow = images) {
        galleryGrid.innerHTML = '';</p>
<pre><code>imagesToShow.forEach((image, index) =&gt; {
    const galleryItem = document.createElement('div');
    galleryItem.className = 'gallery-item';
    galleryItem.dataset.category = image.category;
    galleryItem.dataset.index = index;

    galleryItem.innerHTML = `
        &lt;img src="${image.url}" alt="${image.title}" loading="lazy"&gt;
        &lt;div class="gallery-item-info"&gt;
            &lt;div class="gallery-item-title"&gt;${image.title}&lt;/div&gt;
            &lt;div class="gallery-item-category"&gt;${getCategoryName(image.category)}&lt;/div&gt;
        &lt;/div&gt;
    `;

    // Добавляем обработчик клика для открытия модального окна
    galleryItem.addEventListener('click', () =&gt; {
        openModal(index, imagesToShow);
    });

    galleryGrid.appendChild(galleryItem);
});
</code></pre>
<p>}</p>
<p>// Функция для получения названия категории на русском языке
function getCategoryName(category) {
    const categoryNames = {
        'nature': 'Природа',
        'city': 'Город',
        'people': 'Люди'
    };
    return categoryNames[category] || category;
}
```</p>
</li>
<li>
<p><strong>Добавьте функции для работы с модальным окном:</strong>
    ```javascript
    // Функция для открытия модального окна
    function openModal(index, imagesToShow) {
        currentImageIndex = index;
        filteredImages = imagesToShow;</p>
<pre><code>const image = filteredImages[currentImageIndex];
modalImage.src = image.url;
modalImage.alt = image.title;
modalTitle.textContent = image.title;
modalCategory.textContent = getCategoryName(image.category);

modal.style.display = 'block';
document.body.style.overflow = 'hidden'; // Предотвращаем прокрутку фона
</code></pre>
<p>}</p>
<p>// Функция для закрытия модального окна
function closeModal() {
    modal.style.display = 'none';
    document.body.style.overflow = 'auto'; // Восстанавливаем прокрутку
}</p>
<p>// Функция для показа предыдущего изображения
function showPreviousImage() {
    currentImageIndex = (currentImageIndex - 1 + filteredImages.length) % filteredImages.length;
    updateModalImage();
}</p>
<p>// Функция для показа следующего изображения
function showNextImage() {
    currentImageIndex = (currentImageIndex + 1) % filteredImages.length;
    updateModalImage();
}</p>
<p>// Функция для обновления изображения в модальном окне
function updateModalImage() {
    const image = filteredImages[currentImageIndex];
    modalImage.src = image.url;
    modalImage.alt = image.title;
    modalTitle.textContent = image.title;
    modalCategory.textContent = getCategoryName(image.category);
}
```</p>
</li>
<li>
<p><strong>Добавьте функции для фильтрации и добавления изображений:</strong>
    ```javascript
    // Функция для фильтрации изображений
    function filterImages(category) {
        const imagesToShow = category === 'all' ? images : images.filter(img =&gt; img.category === category);
        renderGallery(imagesToShow);</p>
<pre><code>// Обновляем активную кнопку фильтра
filterButtons.forEach(btn =&gt; {
    btn.classList.remove('active');
    if (btn.dataset.filter === category) {
        btn.classList.add('active');
    }
});
</code></pre>
<p>}</p>
<p>// Функция для добавления нового изображения
function addNewImage(url, title, category) {
    const newImage = {
        id: Date.now(), // Простой способ генерации уникального ID
        url: url,
        title: title,
        category: category
    };</p>
<pre><code>images.push(newImage);

// Если текущий фильтр показывает все изображения или соответствует категории нового изображения
const activeFilter = document.querySelector('.filter-btn.active').dataset.filter;
if (activeFilter === 'all' || activeFilter === category) {
    renderGallery(activeFilter === 'all' ? images : images.filter(img =&gt; img.category === activeFilter));
}

// Показываем уведомление
showNotification('Изображение успешно добавлено!');
</code></pre>
<p>}</p>
<p>// Функция для показа уведомлений
function showNotification(message) {
    const notification = document.createElement('div');
    notification.style.cssText = <code>position: fixed;
        top: 20px;
        right: 20px;
        background-color: #27ae60;
        color: white;
        padding: 15px 20px;
        border-radius: 5px;
        z-index: 1002;
        animation: slideIn 0.3s ease;</code>;
    notification.textContent = message;</p>
<pre><code>document.body.appendChild(notification);

setTimeout(() =&gt; {
    notification.remove();
}, 3000);
</code></pre>
<p>}
```</p>
</li>
<li>
<p><strong>Добавьте обработчики событий:</strong>
    ```javascript
    // Функция для настройки всех обработчиков событий
    function setupEventListeners() {
        // Обработчики для модального окна
        closeBtn.addEventListener('click', closeModal);
        prevBtn.addEventListener('click', showPreviousImage);
        nextBtn.addEventListener('click', showNextImage);</p>
<pre><code>// Закрытие модального окна при клике вне изображения
modal.addEventListener('click', function(e) {
    if (e.target === modal) {
        closeModal();
    }
});

// Обработчики клавиатуры для модального окна
document.addEventListener('keydown', function(e) {
    if (modal.style.display === 'block') {
        switch(e.key) {
            case 'Escape':
                closeModal();
                break;
            case 'ArrowLeft':
                showPreviousImage();
                break;
            case 'ArrowRight':
                showNextImage();
                break;
        }
    }
});

// Обработчики для кнопок фильтрации
filterButtons.forEach(button =&gt; {
    button.addEventListener('click', function() {
        const filter = this.dataset.filter;
        filterImages(filter);
    });
});

// Обработчик для формы добавления изображения
addImageForm.addEventListener('submit', function(e) {
    e.preventDefault();

    const url = document.getElementById('image-url').value.trim();
    const title = document.getElementById('image-title').value.trim();
    const category = document.getElementById('image-category').value;

    if (url &amp;&amp; title &amp;&amp; category) {
        addNewImage(url, title, category);

        // Очищаем форму
        this.reset();
    } else {
        alert('Пожалуйста, заполните все поля формы.');
    }
});
</code></pre>
<p>}
```</p>
</li>
<li>
<p><strong>Добавьте CSS-анимацию для уведомлений:</strong>
    <code>css
    /* Добавьте это в styles.css */
    @keyframes slideIn {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }</code></p>
</li>
</ol>
<h4>Шаг 4: Тестирование и отладка</h4>
<ol>
<li><strong>Откройте <code>index.html</code> через Live Server:</strong> Убедитесь, что галерея отображается корректно.</li>
<li><strong>Протестируйте функциональность:</strong><ul>
<li>Кликните на любое изображение - должно открыться модальное окно.</li>
<li>Используйте кнопки "предыдущее/следующее" для навигации.</li>
<li>Попробуйте клавиши стрелок и Escape для управления модальным окном.</li>
<li>Протестируйте фильтрацию по категориям.</li>
<li>Добавьте новое изображение через форму.</li>
</ul>
</li>
<li><strong>Проверьте адаптивность:</strong> Используйте инструменты разработчика для эмуляции мобильных устройств.</li>
</ol>
<h3>Критерии оценки Практической работы 7:</h3>
<ul>
<li>Создана полнофункциональная интерактивная галерея изображений.</li>
<li>Реализовано модальное окно для просмотра изображений в полноэкранном режиме.</li>
<li>Работает навигация между изображениями (кнопки и клавиатура).</li>
<li>Функционирует фильтрация изображений по категориям.</li>
<li>Реализована возможность добавления новых изображений через форму.</li>
<li>Галерея адаптивна и корректно отображается на мобильных устройствах.</li>
<li>Код JavaScript организован, читаем и использует современные практики.</li>
</ul>
<hr />
<h2>Практическая работа 8: Счетчик пользователей сайта</h2>
<h3>Цель работы:</h3>
<p>Создать интерактивный счетчик посещений сайта с использованием JavaScript и Local Storage, который отслеживает количество посещений пользователя, время последнего визита и общую статистику использования сайта.</p>
<h3>Задачи работы:</h3>
<ol>
<li>Реализовать счетчик посещений с сохранением данных в Local Storage.</li>
<li>Отображать статистику посещений пользователя.</li>
<li>Создать систему приветствий для новых и возвращающихся пользователей.</li>
<li>Добавить функциональность отслеживания времени, проведенного на сайте.</li>
<li>Реализовать возможность сброса статистики.</li>
<li>Создать визуальное представление статистики с помощью графиков.</li>
</ol>
<h3>Необходимые инструменты:</h3>
<ul>
<li>VS Code с установленными расширениями.</li>
<li>Веб-браузер с поддержкой Local Storage.</li>
<li>Базовые знания HTML, CSS и JavaScript из предыдущих практических работ.</li>
</ul>
<h3>Время выполнения: 3 академических часа (135 минут)</h3>
<h3>Пошаговый алгоритм выполнения:</h3>
<h4>Шаг 1: Создание HTML-структуры для счетчика</h4>
<ol>
<li><strong>Создайте новый проект:</strong> В вашей рабочей папке <code>web-development-course</code> создайте новую папку <code>user-counter</code>.</li>
<li><strong>Создайте основные файлы:</strong> Внутри папки <code>user-counter</code> создайте:<ul>
<li><code>index.html</code></li>
<li><code>styles.css</code></li>
<li><code>counter.js</code></li>
</ul>
</li>
<li><strong>Создайте HTML-структуру в <code>index.html</code>:</strong>
    ```html
    &lt;!DOCTYPE html&gt;
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Счетчик пользователей сайта</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <header>
            <h1>Добро пожаловать на наш сайт!</h1>
            <div id="welcome-message" class="welcome-message"></div>
        </header><pre><code>&lt;main&gt;
    &lt;section class="stats-section"&gt;
        &lt;h2&gt;Статистика посещений&lt;/h2&gt;
        &lt;div class="stats-grid"&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-number" id="visit-count"&gt;0&lt;/div&gt;
                &lt;div class="stat-label"&gt;Всего посещений&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-number" id="session-count"&gt;0&lt;/div&gt;
                &lt;div class="stat-label"&gt;Сессий&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-number" id="time-spent"&gt;0&lt;/div&gt;
                &lt;div class="stat-label"&gt;Минут на сайте&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-card"&gt;
                &lt;div class="stat-number" id="last-visit"&gt;Никогда&lt;/div&gt;
                &lt;div class="stat-label"&gt;Последний визит&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/section&gt;

    &lt;section class="activity-section"&gt;
        &lt;h2&gt;Активность по дням&lt;/h2&gt;
        &lt;div class="chart-container"&gt;
            &lt;canvas id="activity-chart" width="400" height="200"&gt;&lt;/canvas&gt;
        &lt;/div&gt;
    &lt;/section&gt;

    &lt;section class="user-info-section"&gt;
        &lt;h2&gt;Информация о пользователе&lt;/h2&gt;
        &lt;div class="user-info-grid"&gt;
            &lt;div class="info-item"&gt;
                &lt;label&gt;Ваше имя:&lt;/label&gt;
                &lt;input type="text" id="user-name" placeholder="Введите ваше имя"&gt;
                &lt;button id="save-name"&gt;Сохранить&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="info-item"&gt;
                &lt;label&gt;Время на сайте в этой сессии:&lt;/label&gt;
                &lt;span id="session-time"&gt;00:00:00&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="info-item"&gt;
                &lt;label&gt;Браузер:&lt;/label&gt;
                &lt;span id="browser-info"&gt;&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="info-item"&gt;
                &lt;label&gt;Разрешение экрана:&lt;/label&gt;
                &lt;span id="screen-resolution"&gt;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/section&gt;

    &lt;section class="actions-section"&gt;
        &lt;h2&gt;Действия&lt;/h2&gt;
        &lt;div class="action-buttons"&gt;
            &lt;button id="reset-stats" class="danger-btn"&gt;Сбросить статистику&lt;/button&gt;
            &lt;button id="export-data"&gt;Экспортировать данные&lt;/button&gt;
            &lt;button id="simulate-visits"&gt;Симулировать посещения&lt;/button&gt;
        &lt;/div&gt;
    &lt;/section&gt;

    &lt;section class="content-section"&gt;
        &lt;h2&gt;Содержимое сайта&lt;/h2&gt;
        &lt;p&gt;Это демонстрационный сайт для изучения работы со счетчиком пользователей. Здесь вы можете увидеть, как JavaScript отслеживает ваши посещения и сохраняет информацию в Local Storage браузера.&lt;/p&gt;

        &lt;div class="features-list"&gt;
            &lt;h3&gt;Возможности счетчика:&lt;/h3&gt;
            &lt;ul&gt;
                &lt;li&gt;Подсчет общего количества посещений&lt;/li&gt;
                &lt;li&gt;Отслеживание количества сессий&lt;/li&gt;
                &lt;li&gt;Измерение времени, проведенного на сайте&lt;/li&gt;
                &lt;li&gt;Сохранение даты последнего визита&lt;/li&gt;
                &lt;li&gt;Персонализированные приветствия&lt;/li&gt;
                &lt;li&gt;Визуализация активности по дням&lt;/li&gt;
                &lt;li&gt;Информация о браузере и устройстве&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/section&gt;
&lt;/main&gt;

&lt;footer&gt;
    &lt;p&gt;&amp;copy; 2024 Демонстрационный сайт. Создано для изучения веб-разработки.&lt;/p&gt;
&lt;/footer&gt;

&lt;script src="counter.js"&gt;&lt;/script&gt;
</code></pre>
<p></body>
</html>
```</p>
</li>
</ol>
<h4>Шаг 2: Стилизация интерфейса счетчика</h4>
<ol>
<li>
<p><strong>Добавьте стили в <code>styles.css</code>:</strong>
    ```css</p>
<ul>
<li>{
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}</li>
</ul>
<p>body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    color: #333;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
}</p>
<p>header {
    background-color: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    color: white;
    text-align: center;
    padding: 2rem 0;
    box-shadow: 0 2px 20px rgba(0,0,0,0.1);
}</p>
<p>header h1 {
    font-size: 2.5rem;
    margin-bottom: 1rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}</p>
<p>.welcome-message {
    font-size: 1.2rem;
    background-color: rgba(255, 255, 255, 0.2);
    padding: 10px 20px;
    border-radius: 25px;
    display: inline-block;
    margin-top: 10px;
    animation: fadeIn 1s ease-in;
}</p>
<p>main {
    max-width: 1200px;
    margin: 2rem auto;
    padding: 0 20px;
}</p>
<p>section {
    background-color: rgba(255, 255, 255, 0.95);
    margin-bottom: 2rem;
    padding: 2rem;
    border-radius: 15px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    backdrop-filter: blur(10px);
}</p>
<p>section h2 {
    color: #2c3e50;
    margin-bottom: 1.5rem;
    font-size: 1.8rem;
    border-bottom: 3px solid #667eea;
    padding-bottom: 0.5rem;
}</p>
<p>.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-top: 1rem;
}</p>
<p>.stat-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 2rem;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}</p>
<p>.stat-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
}</p>
<p>.stat-number {
    font-size: 2.5rem;
    font-weight: bold;
    margin-bottom: 0.5rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}</p>
<p>.stat-label {
    font-size: 0.9rem;
    opacity: 0.9;
    text-transform: uppercase;
    letter-spacing: 1px;
}</p>
<p>.chart-container {
    background-color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    text-align: center;
}</p>
<h1>activity-chart {</h1>
<pre><code>max-width: 100%;
height: auto;
</code></pre>
<p>}</p>
<p>.user-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}</p>
<p>.info-item {
    display: flex;
    flex-direction: column;
    gap: 10px;
}</p>
<p>.info-item label {
    font-weight: bold;
    color: #2c3e50;
}</p>
<p>.info-item input {
    padding: 10px;
    border: 2px solid #e1e8ed;
    border-radius: 5px;
    font-size: 1rem;
    transition: border-color 0.3s ease;
}</p>
<p>.info-item input:focus {
    outline: none;
    border-color: #667eea;
}</p>
<p>.info-item span {
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 5px;
    border: 1px solid #e1e8ed;
}</p>
<p>.action-buttons {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}</p>
<p>button {
    padding: 12px 24px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: bold;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}</p>
<p>button:not(.danger-btn) {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}</p>
<p>button:not(.danger-btn):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}</p>
<p>.danger-btn {
    background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    color: white;
}</p>
<p>.danger-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
}</p>
<h1>save-name {</h1>
<pre><code>align-self: flex-start;
margin-top: 5px;
</code></pre>
<p>}</p>
<p>.features-list {
    margin-top: 2rem;
}</p>
<p>.features-list h3 {
    color: #2c3e50;
    margin-bottom: 1rem;
}</p>
<p>.features-list ul {
    list-style: none;
    padding-left: 0;
}</p>
<p>.features-list li {
    padding: 8px 0;
    padding-left: 25px;
    position: relative;
}</p>
<p>.features-list li::before {
    content: "✓";
    position: absolute;
    left: 0;
    color: #27ae60;
    font-weight: bold;
}</p>
<p>footer {
    background-color: rgba(0, 0, 0, 0.2);
    color: white;
    text-align: center;
    padding: 1rem;
    margin-top: 2rem;
}</p>
<p>@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}</p>
<p>@keyframes countUp {
    from { transform: scale(0.5); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}</p>
<p>.stat-number.animate {
    animation: countUp 0.6s ease-out;
}</p>
<p>/<em> Адаптивность </em>/
@media (max-width: 768px) {
    header h1 {
        font-size: 2rem;
    }</p>
<pre><code>.stats-grid {
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.stat-card {
    padding: 1.5rem;
}

.stat-number {
    font-size: 2rem;
}

.action-buttons {
    flex-direction: column;
}

button {
    width: 100%;
}

.user-info-grid {
    grid-template-columns: 1fr;
}
</code></pre>
<p>}
```</p>
</li>
</ol>
<h4>Шаг 3: Реализация JavaScript функциональности</h4>
<ol>
<li>
<p><strong>Создайте основную структуру в <code>counter.js</code>:</strong>
    ```javascript
    // Класс для управления счетчиком пользователей
    class UserCounter {
        constructor() {
            this.storageKey = 'userCounterData';
            this.sessionStartTime = Date.now();
            this.sessionTimer = null;
            this.data = this.loadData();</p>
<pre><code>    this.init();
}

// Инициализация счетчика
init() {
    this.updateVisitCount();
    this.updateSessionCount();
    this.displayWelcomeMessage();
    this.updateDisplay();
    this.startSessionTimer();
    this.displayBrowserInfo();
    this.displayScreenResolution();
    this.loadUserName();
    this.setupEventListeners();
    this.drawActivityChart();
}

// Загрузка данных из Local Storage
loadData() {
    const savedData = localStorage.getItem(this.storageKey);
    if (savedData) {
        return JSON.parse(savedData);
    } else {
        // Данные по умолчанию для нового пользователя
        return {
            totalVisits: 0,
            totalSessions: 0,
            totalTimeSpent: 0,
            lastVisit: null,
            firstVisit: Date.now(),
            userName: '',
            dailyActivity: {},
            sessionStartTime: Date.now()
        };
    }
}

// Сохранение данных в Local Storage
saveData() {
    localStorage.setItem(this.storageKey, JSON.stringify(this.data));
}

// Обновление счетчика посещений
updateVisitCount() {
    this.data.totalVisits++;

    // Обновляем активность по дням
    const today = new Date().toDateString();
    if (!this.data.dailyActivity[today]) {
        this.data.dailyActivity[today] = 0;
    }
    this.data.dailyActivity[today]++;

    this.saveData();
}

// Обновление счетчика сессий
updateSessionCount() {
    const now = Date.now();
    const lastVisit = this.data.lastVisit;

    // Если прошло больше 30 минут с последнего визита, считаем новой сессией
    if (!lastVisit || (now - lastVisit) &gt; 30 * 60 * 1000) {
        this.data.totalSessions++;
    }

    this.data.lastVisit = now;
    this.data.sessionStartTime = now;
    this.saveData();
}

// Отображение приветственного сообщения
displayWelcomeMessage() {
    const welcomeElement = document.getElementById('welcome-message');
    const userName = this.data.userName || 'Гость';
    const isFirstVisit = this.data.totalVisits === 1;

    let message;
    if (isFirstVisit) {
        message = `Добро пожаловать на наш сайт, ${userName}! Это ваш первый визит.`;
    } else {
        const lastVisitDate = new Date(this.data.lastVisit);
        const timeSinceLastVisit = this.getTimeSinceLastVisit();
        message = `С возвращением, ${userName}! Вы были здесь ${timeSinceLastVisit} назад.`;
    }

    welcomeElement.textContent = message;
}

// Получение времени с последнего визита
getTimeSinceLastVisit() {
    if (!this.data.lastVisit) return 'никогда';

    const now = Date.now();
    const diff = now - this.data.lastVisit;

    const minutes = Math.floor(diff / (1000 * 60));
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));

    if (days &gt; 0) return `${days} дн.`;
    if (hours &gt; 0) return `${hours} ч.`;
    if (minutes &gt; 0) return `${minutes} мин.`;
    return 'только что';
}

// Обновление отображения статистики
updateDisplay() {
    document.getElementById('visit-count').textContent = this.data.totalVisits;
    document.getElementById('session-count').textContent = this.data.totalSessions;
    document.getElementById('time-spent').textContent = Math.floor(this.data.totalTimeSpent / 60000);

    const lastVisitElement = document.getElementById('last-visit');
    if (this.data.lastVisit &amp;&amp; this.data.totalVisits &gt; 1) {
        const lastVisitDate = new Date(this.data.lastVisit);
        lastVisitElement.textContent = lastVisitDate.toLocaleString('ru-RU');
    } else {
        lastVisitElement.textContent = 'Первый визит';
    }

    // Добавляем анимацию к числам
    document.querySelectorAll('.stat-number').forEach(el =&gt; {
        el.classList.add('animate');
        setTimeout(() =&gt; el.classList.remove('animate'), 600);
    });
}

// Запуск таймера сессии
startSessionTimer() {
    this.sessionTimer = setInterval(() =&gt; {
        const sessionTime = Date.now() - this.sessionStartTime;
        const totalTime = this.data.totalTimeSpent + sessionTime;

        // Обновляем отображение времени сессии
        const sessionTimeElement = document.getElementById('session-time');
        sessionTimeElement.textContent = this.formatTime(sessionTime);

        // Обновляем общее время каждую минуту
        if (sessionTime % 60000 &lt; 1000) {
            this.data.totalTimeSpent = totalTime;
            this.saveData();
            this.updateDisplay();
        }
    }, 1000);
}

// Форматирование времени
formatTime(milliseconds) {
    const seconds = Math.floor(milliseconds / 1000) % 60;
    const minutes = Math.floor(milliseconds / (1000 * 60)) % 60;
    const hours = Math.floor(milliseconds / (1000 * 60 * 60));

    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Отображение информации о браузере
displayBrowserInfo() {
    const browserInfo = this.getBrowserInfo();
    document.getElementById('browser-info').textContent = browserInfo;
}

// Получение информации о браузере
getBrowserInfo() {
    const userAgent = navigator.userAgent;
    let browser = 'Неизвестный';

    if (userAgent.includes('Chrome')) browser = 'Google Chrome';
    else if (userAgent.includes('Firefox')) browser = 'Mozilla Firefox';
    else if (userAgent.includes('Safari')) browser = 'Safari';
    else if (userAgent.includes('Edge')) browser = 'Microsoft Edge';
    else if (userAgent.includes('Opera')) browser = 'Opera';

    return browser;
}

// Отображение разрешения экрана
displayScreenResolution() {
    const resolution = `${screen.width} x ${screen.height}`;
    document.getElementById('screen-resolution').textContent = resolution;
}

// Загрузка имени пользователя
loadUserName() {
    const userNameInput = document.getElementById('user-name');
    if (this.data.userName) {
        userNameInput.value = this.data.userName;
    }
}

// Сохранение имени пользователя
saveUserName() {
    const userNameInput = document.getElementById('user-name');
    const userName = userNameInput.value.trim();

    if (userName) {
        this.data.userName = userName;
        this.saveData();
        this.displayWelcomeMessage();
        this.showNotification('Имя сохранено!');
    } else {
        this.showNotification('Пожалуйста, введите имя.', 'error');
    }
}

// Показ уведомлений
showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        border-radius: 5px;
        color: white;
        font-weight: bold;
        z-index: 1000;
        animation: slideIn 0.3s ease;
        background-color: ${type === 'error' ? '#e74c3c' : '#27ae60'};
    `;
    notification.textContent = message;

    document.body.appendChild(notification);

    setTimeout(() =&gt; {
        notification.remove();
    }, 3000);
}

// Рисование графика активности
drawActivityChart() {
    const canvas = document.getElementById('activity-chart');
    const ctx = canvas.getContext('2d');

    // Получаем данные за последние 7 дней
    const last7Days = this.getLast7DaysData();

    // Настройки графика
    const padding = 40;
    const chartWidth = canvas.width - 2 * padding;
    const chartHeight = canvas.height - 2 * padding;
    const barWidth = chartWidth / 7;
    const maxValue = Math.max(...last7Days.map(d =&gt; d.visits), 1);

    // Очищаем canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Рисуем оси
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, canvas.height - padding);
    ctx.lineTo(canvas.width - padding, canvas.height - padding);
    ctx.stroke();

    // Рисуем столбцы
    last7Days.forEach((day, index) =&gt; {
        const barHeight = (day.visits / maxValue) * chartHeight;
        const x = padding + index * barWidth + barWidth * 0.1;
        const y = canvas.height - padding - barHeight;
        const width = barWidth * 0.8;

        // Градиент для столбца
        const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
        gradient.addColorStop(0, '#667eea');
        gradient.addColorStop(1, '#764ba2');

        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, width, barHeight);

        // Подписи дней
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(day.label, x + width / 2, canvas.height - padding + 20);

        // Значения
        if (day.visits &gt; 0) {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.fillText(day.visits, x + width / 2, y - 5);
        }
    });
}

// Получение данных за последние 7 дней
getLast7DaysData() {
    const days = [];
    const today = new Date();

    for (let i = 6; i &gt;= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateString = date.toDateString();
        const visits = this.data.dailyActivity[dateString] || 0;

        days.push({
            date: dateString,
            label: date.toLocaleDateString('ru-RU', { weekday: 'short' }),
            visits: visits
        });
    }

    return days;
}

// Сброс статистики
resetStats() {
    if (confirm('Вы уверены, что хотите сбросить всю статистику? Это действие нельзя отменить.')) {
        localStorage.removeItem(this.storageKey);
        this.data = this.loadData();
        this.updateDisplay();
        this.displayWelcomeMessage();
        this.drawActivityChart();
        this.showNotification('Статистика сброшена!');
    }
}

// Экспорт данных
exportData() {
    const dataStr = JSON.stringify(this.data, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);

    const link = document.createElement('a');
    link.href = url;
    link.download = 'user-counter-data.json';
    link.click();

    URL.revokeObjectURL(url);
    this.showNotification('Данные экспортированы!');
}

// Симуляция посещений (для демонстрации)
simulateVisits() {
    const visitsToAdd = Math.floor(Math.random() * 10) + 1;
    this.data.totalVisits += visitsToAdd;
    this.data.totalSessions += Math.floor(visitsToAdd / 2);
    this.data.totalTimeSpent += Math.random() * 3600000; // До 1 часа

    // Добавляем активность за случайные дни
    for (let i = 0; i &lt; 7; i++) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateString = date.toDateString();

        if (!this.data.dailyActivity[dateString]) {
            this.data.dailyActivity[dateString] = 0;
        }
        this.data.dailyActivity[dateString] += Math.floor(Math.random() * 5);
    }

    this.saveData();
    this.updateDisplay();
    this.drawActivityChart();
    this.showNotification(`Добавлено ${visitsToAdd} посещений для демонстрации!`);
}

// Настройка обработчиков событий
setupEventListeners() {
    document.getElementById('save-name').addEventListener('click', () =&gt; {
        this.saveUserName();
    });

    document.getElementById('user-name').addEventListener('keypress', (e) =&gt; {
        if (e.key === 'Enter') {
            this.saveUserName();
        }
    });

    document.getElementById('reset-stats').addEventListener('click', () =&gt; {
        this.resetStats();
    });

    document.getElementById('export-data').addEventListener('click', () =&gt; {
        this.exportData();
    });

    document.getElementById('simulate-visits').addEventListener('click', () =&gt; {
        this.simulateVisits();
    });

    // Сохранение времени при закрытии страницы
    window.addEventListener('beforeunload', () =&gt; {
        const sessionTime = Date.now() - this.sessionStartTime;
        this.data.totalTimeSpent += sessionTime;
        this.saveData();
    });

    // Обновление графика при изменении размера окна
    window.addEventListener('resize', () =&gt; {
        setTimeout(() =&gt; this.drawActivityChart(), 100);
    });
}
</code></pre>
<p>}</p>
<p>// Инициализация счетчика при загрузке страницы
document.addEventListener('DOMContentLoaded', () =&gt; {
    new UserCounter();
});
```</p>
</li>
</ol>
<h4>Шаг 4: Тестирование и отладка</h4>
<ol>
<li><strong>Откройте <code>index.html</code> через Live Server:</strong> Убедитесь, что счетчик корректно отображается и функционирует.</li>
<li><strong>Протестируйте функциональность:</strong><ul>
<li>Обновите страницу несколько раз и убедитесь, что счетчик посещений увеличивается.</li>
<li>Введите свое имя и сохраните его.</li>
<li>Проверьте, что время сессии обновляется каждую секунду.</li>
<li>Используйте кнопку "Симулировать посещения" для генерации тестовых данных.</li>
<li>Проверьте график активности.</li>
<li>Экспортируйте данные и убедитесь, что файл загружается.</li>
<li>Сбросьте статистику и убедитесь, что все данные очищаются.</li>
</ul>
</li>
<li><strong>Проверьте Local Storage:</strong> Откройте инструменты разработчика (F12), перейдите на вкладку Application (или Storage), найдите Local Storage и убедитесь, что данные сохраняются.</li>
<li><strong>Проверьте адаптивность:</strong> Используйте инструменты разработчика для эмуляции мобильных устройств.</li>
</ol>
<h3>Критерии оценки Практической работы 8:</h3>
<ul>
<li>Реализован функциональный счетчик посещений с сохранением в Local Storage.</li>
<li>Корректно отображается статистика посещений, сессий и времени на сайте.</li>
<li>Работает система персонализированных приветствий.</li>
<li>Функционирует отслеживание времени сессии в реальном времени.</li>
<li>Реализована визуализация активности с помощью графика на Canvas.</li>
<li>Работают функции сброса статистики и экспорта данных.</li>
<li>Интерфейс адаптивен и корректно отображается на мобильных устройствах.</li>
<li>Код JavaScript хорошо структурирован и использует современные практики.</li>
</ul>
<hr />
<h2>Дополнительные материалы: Подборка российских сайтов для изучения</h2>
<h3>Цель изучения:</h3>
<p>Анализ современных российских веб-сайтов поможет студентам понять актуальные тренды в веб-дизайне, изучить различные подходы к решению дизайнерских задач и получить вдохновение для собственных проектов.</p>
<h3>Подборка из 20 простых и красивых российских сайтов:</h3>
<h4>1. <strong>Superjet 200</strong> - superjet200.com</h4>
<ul>
<li><strong>Категория:</strong> Авиационная промышленность</li>
<li><strong>Особенности:</strong> Минималистичный дизайн, качественная 3D-графика, голубая цветовая палитра</li>
<li><strong>Что изучить:</strong> Работа с 3D-элементами, промышленный дизайн</li>
</ul>
<h4>2. <strong>Яндекс</strong> - yandex.ru</h4>
<ul>
<li><strong>Категория:</strong> IT-сервисы</li>
<li><strong>Особенности:</strong> Функциональный минимализм, быстрая загрузка, адаптивность</li>
<li><strong>Что изучить:</strong> UX для поисковых систем, производительность</li>
</ul>
<h4>3. <strong>ВКонтакте</strong> - vk.com</h4>
<ul>
<li><strong>Категория:</strong> Социальная сеть</li>
<li><strong>Особенности:</strong> Современный flat design, синяя палитра, интерактивность</li>
<li><strong>Что изучить:</strong> Социальные интерфейсы, интерактивные элементы</li>
</ul>
<h4>4. <strong>Тинькофф Банк</strong> - tinkoff.ru</h4>
<ul>
<li><strong>Категория:</strong> Финансы</li>
<li><strong>Особенности:</strong> Яркий желтый цвет, дружелюбный дизайн, четкая типографика</li>
<li><strong>Что изучить:</strong> Финтех дизайн, доверие пользователей</li>
</ul>
<h4>5. <strong>Ozon</strong> - ozon.ru</h4>
<ul>
<li><strong>Категория:</strong> E-commerce</li>
<li><strong>Особенности:</strong> Синий корпоративный стиль, удобная навигация, карточки товаров</li>
<li><strong>Что изучить:</strong> Интернет-магазины, каталоги</li>
</ul>
<h4>6. <strong>Сбербанк</strong> - sberbank.ru</h4>
<ul>
<li><strong>Категория:</strong> Банковские услуги</li>
<li><strong>Особенности:</strong> Зеленый корпоративный цвет, консервативный надежный дизайн</li>
<li><strong>Что изучить:</strong> Банковские интерфейсы, безопасность</li>
</ul>
<h4>7. <strong>Авито</strong> - avito.ru</h4>
<ul>
<li><strong>Категория:</strong> Объявления</li>
<li><strong>Особенности:</strong> Зеленая палитра, удобные фильтры, геолокация</li>
<li><strong>Что изучить:</strong> Классифайды, поиск и фильтрация</li>
</ul>
<h4>8. <strong>Wildberries</strong> - wildberries.ru</h4>
<ul>
<li><strong>Категория:</strong> Маркетплейс</li>
<li><strong>Особенности:</strong> Фиолетовый цвет, система отзывов, мобильная оптимизация</li>
<li><strong>Что изучить:</strong> Маркетплейсы, отзывы и рейтинги</li>
</ul>
<h4>9. <strong>Mail.ru</strong> - mail.ru</h4>
<ul>
<li><strong>Категория:</strong> Интернет-портал</li>
<li><strong>Особенности:</strong> Портальная структура, агрегация контента, персонализация</li>
<li><strong>Что изучить:</strong> Порталы, множественные сервисы</li>
</ul>
<h4>10. <strong>Лента.ру</strong> - lenta.ru</h4>
<ul>
<li><strong>Категория:</strong> Новости</li>
<li><strong>Особенности:</strong> Информационная архитектура, типографическая иерархия</li>
<li><strong>Что изучить:</strong> Новостные сайты, контент-стратегия</li>
</ul>
<h4>11. <strong>РБК</strong> - rbc.ru</h4>
<ul>
<li><strong>Категория:</strong> Деловые новости</li>
<li><strong>Особенности:</strong> Строгий деловой стиль, красные акценты, аналитика</li>
<li><strong>Что изучить:</strong> Деловые медиа, информационная плотность</li>
</ul>
<h4>12. <strong>Карта истории России</strong> - kartaistorii.ru</h4>
<ul>
<li><strong>Категория:</strong> Образование</li>
<li><strong>Особенности:</strong> Интерактивная игровая механика, яркий дизайн</li>
<li><strong>Что изучить:</strong> Образовательные интерфейсы, геймификация</li>
</ul>
<h4>13. <strong>Four Element</strong> - four-element.ru</h4>
<ul>
<li><strong>Категория:</strong> Туризм</li>
<li><strong>Особенности:</strong> Природные цвета, качественная фотография, эмоциональность</li>
<li><strong>Что изучить:</strong> Туристические сайты, эмоциональный дизайн</li>
</ul>
<h4>14. <strong>PetSend</strong> - petsend.ru</h4>
<ul>
<li><strong>Категория:</strong> Услуги</li>
<li><strong>Особенности:</strong> Дружелюбный дизайн, креативные иллюстрации</li>
<li><strong>Что изучить:</strong> Сервисные сайты, иллюстрации</li>
</ul>
<h4>15. <strong>Kubachi VIP</strong> - kubachivip.ru</h4>
<ul>
<li><strong>Категория:</strong> Ювелирные изделия</li>
<li><strong>Особенности:</strong> Премиум-дизайн, черный фон, акцент на продукции</li>
<li><strong>Что изучить:</strong> Luxury дизайн, продуктовая фотография</li>
</ul>
<h4>16. <strong>300LUX</strong> - 300lux.ru</h4>
<ul>
<li><strong>Категория:</strong> Промышленность</li>
<li><strong>Особенности:</strong> Технологичный дизайн, промышленная эстетика</li>
<li><strong>Что изучить:</strong> B2B дизайн, техническая документация</li>
</ul>
<h4>17. <strong>WoodMax</strong> - woodmax-tomsk.ru</h4>
<ul>
<li><strong>Категория:</strong> Мебель</li>
<li><strong>Особенности:</strong> Светлые тона, семейные образы, качественные интерьеры</li>
<li><strong>Что изучить:</strong> Мебельные сайты, интерьерная фотография</li>
</ul>
<h4>18. <strong>Georgia Guide</strong> - georgia-guide.com</h4>
<ul>
<li><strong>Категория:</strong> Туризм</li>
<li><strong>Особенности:</strong> Культурная аутентичность, теплые цвета</li>
<li><strong>Что изучить:</strong> Культурный дизайн, туристические гиды</li>
</ul>
<h4>19. <strong>Guide Dogs</strong> - guidedogs.ru</h4>
<ul>
<li><strong>Категория:</strong> Социальный проект</li>
<li><strong>Особенности:</strong> Социальная значимость, эмоциональные образы</li>
<li><strong>Что изучить:</strong> Социальные проекты, эмоциональное воздействие</li>
</ul>
<h4>20. <strong>История русской поп-музыки</strong> - popsa.lenta.ru</h4>
<ul>
<li><strong>Категория:</strong> Мультимедиа</li>
<li><strong>Особенности:</strong> Ностальгический дизайн, креативная типографика</li>
<li><strong>Что изучить:</strong> Мультимедийные проекты, сторителлинг</li>
</ul>
<h3>Практические задания для работы с подборкой:</h3>
<h4>Задание 1: Анализ цветовых схем</h4>
<ol>
<li>Выберите 5 сайтов из подборки</li>
<li>Определите основные и акцентные цвета каждого сайта</li>
<li>Создайте цветовые палитры в CSS</li>
<li>Проанализируйте, как цвета влияют на восприятие бренда</li>
</ol>
<h4>Задание 2: Изучение типографики</h4>
<ol>
<li>Исследуйте шрифты на 3-4 сайтах</li>
<li>Определите иерархию заголовков</li>
<li>Воссоздайте типографическую систему в CSS</li>
<li>Создайте собственную типографическую схему</li>
</ol>
<h4>Задание 3: Анализ навигации</h4>
<ol>
<li>Изучите структуру меню на разных сайтах</li>
<li>Сравните подходы к организации информации</li>
<li>Создайте схему навигации для собственного проекта</li>
<li>Реализуйте адаптивное меню</li>
</ol>
<h4>Задание 4: Responsive дизайн</h4>
<ol>
<li>Откройте 3-5 сайтов на мобильном устройстве</li>
<li>Проанализируйте, как изменяется интерфейс</li>
<li>Создайте собственную адаптивную сетку</li>
<li>Протестируйте на разных разрешениях</li>
</ol>
<h4>Задание 5: Интерактивные элементы</h4>
<ol>
<li>Найдите интересные hover-эффекты</li>
<li>Изучите анимации и переходы</li>
<li>Воссоздайте понравившиеся эффекты</li>
<li>Создайте собственную библиотеку эффектов</li>
</ol>
<h3>Методика изучения:</h3>
<h4>Шаг 1: Первое впечатление</h4>
<ul>
<li>Откройте сайт и зафиксируйте первое впечатление</li>
<li>Что привлекает внимание в первую очередь?</li>
<li>Понятна ли цель сайта с первого взгляда?</li>
</ul>
<h4>Шаг 2: Детальный анализ</h4>
<ul>
<li>Изучите структуру страницы</li>
<li>Проанализируйте использование пространства</li>
<li>Обратите внимание на баланс элементов</li>
</ul>
<h4>Шаг 3: Техническое исследование</h4>
<ul>
<li>Откройте инструменты разработчика</li>
<li>Изучите HTML-структуру</li>
<li>Проанализируйте CSS-стили</li>
<li>Обратите внимание на JavaScript-функциональность</li>
</ul>
<h4>Шаг 4: Практическое применение</h4>
<ul>
<li>Воссоздайте понравившиеся элементы</li>
<li>Адаптируйте решения под свои задачи</li>
<li>Создайте собственные вариации</li>
</ul>
<h3>Критерии оценки работы с подборкой:</h3>
<ul>
<li>Глубина анализа выбранных сайтов</li>
<li>Качество воссозданных элементов</li>
<li>Понимание принципов дизайна</li>
<li>Способность адаптировать решения</li>
<li>Создание собственных креативных вариаций</li>
</ul>
<hr />
        </section>

        <section id="code-examples">
            <h2>Примеры кода</h2>
            <h1>Руководство по примерам кода</h1>
<h2>Обзор</h2>
<p>Данная папка содержит практические примеры кода для демонстрации концепций, изучаемых в курсе веб-разработки. Каждый пример представляет собой полноценный HTML-файл с встроенными CSS и JavaScript, который можно открыть в браузере для изучения и тестирования.</p>
<h2>Структура папки</h2>
<p><code>code_examples/
├── html_basics/
│   ├── basic_structure.html
│   └── forms_example.html
├── css_basics/
│   ├── selectors_demo.html
│   └── flexbox_demo.html
├── responsive_design/
│   └── media_queries_demo.html
├── javascript_basics/
│   └── dom_manipulation.html
└── final_project/
    └── portfolio_template.html</code></p>
<h2>Описание примеров</h2>
<h3>HTML Basics (Основы HTML)</h3>
<h4>1. basic_structure.html</h4>
<p><strong>Цель:</strong> Демонстрация базовой структуры HTML-документа и основных тегов.</p>
<p><strong>Что демонстрирует:</strong>
- Правильная структура HTML-документа
- Иерархия заголовков (h1-h6)
- Работа с текстом (параграфы, форматирование)
- Различные типы списков (ul, ol, dl)
- Ссылки (внешние, внутренние, email, телефон)
- Вставка изображений с атрибутами</p>
<p><strong>Как использовать:</strong>
1. Откройте файл в браузере
2. Изучите исходный код
3. Попробуйте изменить содержимое и посмотреть результат
4. Обратите внимание на семантическую разметку</p>
<h4>2. forms_example.html</h4>
<p><strong>Цель:</strong> Изучение различных типов форм и полей ввода.</p>
<p><strong>Что демонстрирует:</strong>
- Базовая форма регистрации
- Различные типы input полей
- Радиокнопки и чекбоксы
- Выпадающие списки (select)
- Группировка полей (fieldset)
- Валидация форм
- Обработка событий форм</p>
<p><strong>Как использовать:</strong>
1. Откройте файл в браузере
2. Заполните различные формы
3. Протестируйте валидацию
4. Изучите JavaScript код для обработки форм</p>
<h3>CSS Basics (Основы CSS)</h3>
<h4>1. selectors_demo.html</h4>
<p><strong>Цель:</strong> Демонстрация различных типов CSS селекторов.</p>
<p><strong>Что демонстрирует:</strong>
- Селекторы по тегу, классу, ID
- Комбинированные селекторы
- Псевдоклассы (:hover, :first-child, :nth-child)
- Псевдоэлементы (::before, ::after, ::first-letter)
- Селекторы атрибутов
- Специфичность селекторов
- Группировка селекторов</p>
<p><strong>Как использовать:</strong>
1. Откройте файл в браузере
2. Наведите курсор на различные элементы
3. Изучите CSS код в секции <style>
4. Попробуйте изменить селекторы и стили</p>
<h4>2. flexbox_demo.html</h4>
<p><strong>Цель:</strong> Полное изучение CSS Flexbox.</p>
<p><strong>Что демонстрирует:</strong>
- Основы Flexbox (display: flex)
- Направление flex-direction
- Перенос строк flex-wrap
- Выравнивание justify-content и align-items
- Свойства flex элементов (grow, shrink, basis)
- Практические примеры макетов
- Адаптивность с Flexbox</p>
<p><strong>Как использовать:</strong>
1. Откройте файл в браузере
2. Изучите каждый раздел демонстрации
3. Измените размер окна браузера для проверки адаптивности
4. Экспериментируйте с CSS свойствами</p>
<h3>Responsive Design (Адаптивный дизайн)</h3>
<h4>media_queries_demo.html</h4>
<p><strong>Цель:</strong> Демонстрация адаптивного дизайна и медиа-запросов.</p>
<p><strong>Что демонстрирует:</strong>
- Различные типы медиа-запросов
- Точки останова (breakpoints)
- Адаптивные сетки (CSS Grid)
- Адаптивные изображения
- Мобильная навигация
- Адаптивная типографика
- Индикатор размера экрана</p>
<p><strong>Как использовать:</strong>
1. Откройте файл в браузере
2. Изменяйте размер окна браузера
3. Обратите внимание на индикатор размера экрана
4. Протестируйте на мобильных устройствах
5. Изучите медиа-запросы в CSS</p>
<h3>JavaScript Basics (Основы JavaScript)</h3>
<h4>dom_manipulation.html</h4>
<p><strong>Цель:</strong> Изучение работы с DOM и событиями в JavaScript.</p>
<p><strong>Что демонстрирует:</strong>
- Поиск и выбор элементов
- Изменение содержимого (innerHTML, textContent)
- Работа с атрибутами
- Изменение стилей через JavaScript
- Создание и удаление элементов
- Обработка событий
- Практические примеры (Todo List, счетчик, табы)</p>
<p><strong>Как использовать:</strong>
1. Откройте файл в браузере
2. Взаимодействуйте с различными элементами
3. Изучите JavaScript код
4. Откройте консоль разработчика для отладки
5. Попробуйте модифицировать код</p>
<h4>dom_basics.html</h4>
<p><strong>Цель:</strong> Демонстрация базовых манипуляций с DOM и обработки событий.</p>
<p><strong>Что демонстрирует:</strong>
- Получение элементов по ID
- Изменение текстового содержимого и стилей
- Добавление/удаление классов
- Динамическое создание и добавление элементов в список
- Обработка событий клика</p>
<h3>Final Project (Итоговый проект)</h3>
<h4>portfolio_template.html</h4>
<p><strong>Цель:</strong> Шаблон портфолио как пример итогового проекта.</p>
<p><strong>Что демонстрирует:</strong>
- Полноценный одностраничный сайт
- Современный дизайн
- Адаптивная верстка
- Интерактивные элементы
- Анимации и эффекты
- Модальные окна
- Формы обратной связи
- Мобильная навигация</p>
<p><strong>Как использовать:</strong>
1. Откройте файл в браузере
2. Протестируйте все функции
3. Адаптируйте под свои нужды
4. Используйте как основу для итогового проекта</p>
<h2>Рекомендации по изучению</h2>
<h3>Для преподавателей:</h3>
<ol>
<li><strong>Последовательность изучения:</strong></li>
<li>Начните с basic_structure.html</li>
<li>Переходите к forms_example.html</li>
<li>Изучите selectors_demo.html</li>
<li>Освойте flexbox_demo.html</li>
<li>Изучите media_queries_demo.html</li>
<li>Практикуйтесь с dom_manipulation.html</li>
<li>
<p>Завершите portfolio_template.html</p>
</li>
<li>
<p><strong>Методика преподавания:</strong></p>
</li>
<li>Демонстрируйте примеры на проекторе</li>
<li>Предлагайте студентам изменять код</li>
<li>Объясняйте каждую строку кода</li>
<li>
<p>Поощряйте эксперименты</p>
</li>
<li>
<p><strong>Практические задания:</strong></p>
</li>
<li>Модификация существующих примеров</li>
<li>Создание аналогичных примеров</li>
<li>Комбинирование техник из разных примеров</li>
</ol>
<h3>Для студентов:</h3>
<ol>
<li><strong>Как изучать:</strong></li>
<li>Откройте файл в браузере</li>
<li>Изучите исходный код</li>
<li>Попробуйте изменить что-то</li>
<li>Посмотрите на результат</li>
<li>
<p>Повторите процесс</p>
</li>
<li>
<p><strong>Инструменты разработчика:</strong></p>
</li>
<li>Используйте F12 для открытия DevTools</li>
<li>Изучайте вкладку Elements</li>
<li>Экспериментируйте в Console</li>
<li>
<p>Проверяйте адаптивность в Device Mode</p>
</li>
<li>
<p><strong>Практические упражнения:</strong></p>
</li>
<li>Создайте свои варианты примеров</li>
<li>Комбинируйте разные техники</li>
<li>Добавляйте новые функции</li>
<li>Исправляйте намеренно внесенные ошибки</li>
</ol>
<h2>Технические требования</h2>
<ul>
<li>Современный браузер (Chrome, Firefox, Safari, Edge)</li>
<li>Текстовый редактор для изучения кода</li>
<li>Базовые знания HTML, CSS, JavaScript</li>
</ul>
<h2>Дополнительные ресурсы</h2>
<ul>
<li><a href="https://developer.mozilla.org/">MDN Web Docs</a></li>
<li><a href="https://www.w3schools.com/">W3Schools</a></li>
<li><a href="https://css-tricks.com/">CSS-Tricks</a></li>
<li><a href="https://javascript.info/">JavaScript.info</a></li>
</ul>
<h2>Поддержка</h2>
<p>Если у вас возникли вопросы по примерам кода:
1. Внимательно изучите комментарии в коде
2. Проверьте консоль браузера на наличие ошибок
3. Сравните с рабочими примерами
4. Обратитесь к преподавателю за помощью</p>
<hr />
<p><em>Примеры кода созданы для образовательных целей и демонстрируют лучшие практики веб-разработки.</em></p>
        </section>

        <section id="final-topics">
            <h2>Темы для итоговых работ</h2>
            <h1>20 Тем для итоговых работ: Социокультурная сфера, Искусство и Медиаискусство</h1>
<p>Данная подборка тем для итоговых работ ориентирована на создание веб-сайтов, которые исследуют, представляют или взаимодействуют с социокультурной сферой, уделяя особое внимание искусству и медиаискусству. Каждая тема предполагает разработку интерактивного и визуально привлекательного проекта, использующего HTML, CSS и JavaScript.</p>
<h2>Категория 1: Виртуальные галереи и выставки</h2>
<ol>
<li>
<p><strong>Виртуальная галерея современного искусства:</strong> Создание онлайн-платформы для демонстрации работ молодых художников, с возможностью просмотра в 3D-пространстве (имитация) или интерактивными элементами для изучения каждой работы.</p>
<ul>
<li><strong>Акцент:</strong> Представление искусства, интерактивность, UX/UI для галерей.</li>
</ul>
</li>
<li>
<p><strong>Архив медиаискусства:</strong> Разработка веб-архива, посвященного истории и развитию медиаискусства в России или мире, с каталогом работ, биографиями художников и временной шкалой.</p>
<ul>
<li><strong>Акцент:</strong> Документирование, исторический контекст, мультимедийный контент.</li>
</ul>
</li>
<li>
<p><strong>Интерактивная выставка цифрового искусства:</strong> Создание веб-сайта, представляющего собой интерактивную выставку, где пользователи могут взаимодействовать с цифровыми инсталляциями, генеративным искусством или NFT-коллекциями.</p>
<ul>
<li><strong>Акцент:</strong> Цифровое искусство, интерактивность, новые медиа.</li>
</ul>
</li>
<li>
<p><strong>Портфолио художника/медиахудожника:</strong> Разработка персонального веб-портфолио для вымышленного или реального художника, специализирующегося на медиаискусстве, с демонстрацией работ, биографией и контактной информацией.</p>
<ul>
<li><strong>Акцент:</strong> Самопрезентация, визуальный сторителлинг, адаптивный дизайн.</li>
</ul>
</li>
</ol>
<h2>Категория 2: Образовательные и просветительские проекты</h2>
<ol>
<li>
<p><strong>Образовательный портал по истории искусства:</strong> Создание интерактивного ресурса для изучения ключевых направлений и периодов в искусстве, с тестами, инфографикой и галереями изображений.</p>
<ul>
<li><strong>Акцент:</strong> Образование, визуализация данных, интерактивное обучение.</li>
</ul>
</li>
<li>
<p><strong>Глоссарий терминов медиаискусства:</strong> Разработка онлайн-глоссария с определениями, примерами и ссылками на работы, объясняющего сложные концепции медиаискусства.</p>
<ul>
<li><strong>Акцент:</strong> Специализированный контент, удобство поиска, кросс-ссылки.</li>
</ul>
</li>
<li>
<p>**Курс </p>
</li>
</ol>
<p>по основам цифровой живописи:<strong> Создание интерактивного веб-курса, который шаг за шагом обучает основам цифровой живописи, с уроками, примерами и возможностью загрузки работ.
    *   </strong>Акцент:** Практическое обучение, пошаговые инструкции, сообщество.</p>
<ol>
<li><strong>Интерактивная карта культурных объектов города:</strong> Разработка веб-карты, на которой отмечены музеи, галереи, театры, арт-пространства и другие культурные объекты города, с информацией о каждом месте и расписанием событий.<ul>
<li><strong>Акцент:</strong> Геолокация, событийный календарь, культурный туризм.</li>
</ul>
</li>
</ol>
<h2>Категория 3: Социальные и интерактивные платформы</h2>
<ol>
<li>
<p><strong>Платформа для коллабораций художников:</strong> Создание социальной сети или платформы, где художники могут находить друг друга для совместных проектов, обмениваться идеями и демонстрировать процесс работы.</p>
<ul>
<li><strong>Акцент:</strong> Социальное взаимодействие, совместное творчество, нетворкинг.</li>
</ul>
</li>
<li>
<p><strong>Форум по обсуждению медиаискусства:</strong> Разработка онлайн-форума, посвященного дискуссиям о медиаискусстве, новых технологиях, этических вопросах и влиянии на общество.</p>
<ul>
<li><strong>Акцент:</strong> Дискуссии, модерирование контента, сообщество.</li>
</ul>
</li>
<li>
<p><strong>Сервис для создания интерактивных историй:</strong> Создание инструмента, позволяющего пользователям без навыков программирования создавать простые интерактивные истории или квесты с использованием текста, изображений и звука.</p>
<ul>
<li><strong>Акцент:</strong> Пользовательский контент, сторителлинг, простота использования.</li>
</ul>
</li>
<li>
<p><strong>Платформа для краудфандинга культурных проектов:</strong> Разработка веб-сайта, где культурные проекты (выставки, фестивали, перформансы) могут собирать средства от сообщества.</p>
<ul>
<li><strong>Акцент:</strong> Финансирование искусства, социальное воздействие, прозрачность.</li>
</ul>
</li>
</ol>
<h2>Категория 4: Перформанс и интерактивные инсталляции</h2>
<ol>
<li>
<p><strong>Веб-сайт для онлайн-перформанса:</strong> Создание платформы, где художники могут проводить онлайн-перформансы, а зрители — взаимодействовать с ними в реальном времени через веб-интерфейс.</p>
<ul>
<li><strong>Акцент:</strong> Живое искусство, интерактивность, потоковое вещание (имитация).</li>
</ul>
</li>
<li>
<p><strong>Генеративная музыкальная инсталляция:</strong> Разработка веб-сайта, который генерирует уникальную музыку или звуковые ландшафты на основе пользовательского ввода или случайных параметров.</p>
<ul>
<li><strong>Акцент:</strong> Генеративное искусство, аудио-визуализация, алгоритмическое творчество.</li>
</ul>
</li>
<li>
<p><strong>Интерактивная световая инсталляция (симуляция):</strong> Создание веб-приложения, имитирующего световую инсталляцию, где пользователи могут управлять цветом, интенсивностью и паттернами света.</p>
<ul>
<li><strong>Акцент:</strong> Визуализация, пользовательский контроль, симуляция физических явлений.</li>
</ul>
</li>
</ol>
<h2>Категория 5: Критика и аналитика</h2>
<ol>
<li>
<p><strong>Блог или журнал о медиаискусстве:</strong> Разработка онлайн-издания, публикующего статьи, рецензии, интервью и аналитические материалы о медиаискусстве и его влиянии на современное общество.</p>
<ul>
<li><strong>Акцент:</strong> Журналистика, критический анализ, кураторство контента.</li>
</ul>
</li>
<li>
<p><strong>Система голосования за лучшие арт-проекты:</strong> Создание платформы, где пользователи могут голосовать за понравившиеся арт-проекты, оставлять комментарии и формировать рейтинги.</p>
<ul>
<li><strong>Акцент:</strong> Общественное мнение, рейтинги, вовлечение аудитории.</li>
</ul>
</li>
<li>
<p><strong>Интерактивная инфографика по статистике культурных событий:</strong> Разработка веб-страницы с динамической инфографикой, отображающей статистику посещаемости музеев, галерей, театров, данные о продажах билетов и т.д.</p>
<ul>
<li><strong>Акцент:</strong> Визуализация данных, аналитика, информационный дизайн.</li>
</ul>
</li>
</ol>
<h2>Категория 6: Экспериментальные и гибридные проекты</h2>
<ol>
<li>
<p><strong>Веб-сайт для создания ASCII-арта:</strong> Инструмент, позволяющий пользователям загружать изображения и конвертировать их в ASCII-арт, с возможностью настройки параметров и сохранения результата.</p>
<ul>
<li><strong>Акцент:</strong> Экспериментальное искусство, обработка изображений, пользовательские инструменты.</li>
</ul>
</li>
<li>
<p><strong>Интерактивный генератор стихов/текстов:</strong> Веб-приложение, которое генерирует короткие стихи или фрагменты текстов на основе заданных ключевых слов или тем, используя простые алгоритмы.</p>
<ul>
<li><strong>Акцент:</strong> Генеративный текст, креативное программирование, лингвистические эксперименты.</li>
</ul>
</li>
</ol>
<hr />
<h3>Рекомендации по выполнению:</h3>
<ul>
<li><strong>Исследование:</strong> Перед началом работы тщательно изучите выбранную тему, соберите референсы и определите целевую аудиторию.</li>
<li><strong>Планирование:</strong> Разработайте структуру сайта, продумайте пользовательский путь и функциональность.</li>
<li><strong>Дизайн:</strong> Уделите внимание визуальной составляющей, создайте уникальный и привлекательный дизайн, соответствующий тематике.</li>
<li><strong>Реализация:</strong> Используйте HTML для структуры, CSS для стилизации и JavaScript для интерактивности. Применяйте принципы адаптивного дизайна.</li>
<li><strong>Тестирование:</strong> Тщательно протестируйте проект на разных устройствах и в разных браузерах.</li>
<li><strong>Презентация:</strong> Подготовьте краткое описание проекта, его целей, использованных технологий и особенностей.</li>
</ul>
<hr />
<p><em>Эти темы призваны вдохновить студентов на создание креативных и значимых веб-проектов, демонстрирующих их навыки в веб-разработке и понимание социокультурного контекста.</em></p>
        </section>

        <section id="additional-materials">
            <h2>Дополнительные материалы</h2>
            <h1>Подборка из 20 простых и красивых российских сайтов</h1>
<h2>Для изучения веб-разработки и дизайна</h2>
<p>Данная подборка создана специально для студентов, изучающих веб-разработку. Каждый сайт представляет собой отличный пример современного дизайна, удобной навигации и грамотного использования HTML, CSS и JavaScript.</p>
<hr />
<h2>1. Карта истории России</h2>
<p><strong>URL:</strong> kartaistorii.ru<br />
<strong>Категория:</strong> Интерактивный образовательный проект<br />
<strong>Особенности дизайна:</strong>
- Интерактивная игровая механика
- Яркий контрастный дизайн с фиолетовыми оттенками
- Крупная типографика
- Эффектная анимация и переходы
- Минималистичный интерфейс с акцентом на главном действии</p>
<p><strong>Что изучить:</strong> Интерактивность, работа с анимацией, создание игровых интерфейсов</p>
<hr />
<h2>2. История русской поп-музыки (Лента.ру)</h2>
<p><strong>URL:</strong> popsa.lenta.ru<br />
<strong>Категория:</strong> Мультимедийный спецпроект<br />
<strong>Особенности дизайна:</strong>
- Ностальгический дизайн в стиле 2000-х
- Яркие контрастные цвета
- Креативная типографика
- Анимированные элементы
- Адаптивная верстка</p>
<p><strong>Что изучить:</strong> Тематический дизайн, работа с мультимедиа, создание атмосферы</p>
<hr />
<h2>3. WoodMax - кухни на заказ</h2>
<p><strong>URL:</strong> woodmax-tomsk.ru<br />
<strong>Категория:</strong> Коммерческий сайт (мебель)<br />
<strong>Особенности дизайна:</strong>
- Светлая цветовая палитра
- Качественные фотографии интерьеров
- Четкая структура информации
- Удобные формы обратной связи
- Семейные образы в дизайне</p>
<p><strong>Что изучить:</strong> Коммерческий дизайн, работа с изображениями, UX для продаж</p>
<hr />
<h2>4. Four Element - эко-отели</h2>
<p><strong>URL:</strong> four-element.ru<br />
<strong>Категория:</strong> Туризм и гостиничный бизнес<br />
<strong>Особенности дизайна:</strong>
- Природные цвета и текстуры
- Качественная фотография природы
- Минималистичный дизайн
- Акцент на атмосфере и эмоциях
- Гармоничное сочетание текста и изображений</p>
<p><strong>Что изучить:</strong> Эмоциональный дизайн, работа с фотографией, создание атмосферы</p>
<hr />
<h2>5. Kubachi VIP - ювелирный завод</h2>
<p><strong>URL:</strong> kubachivip.ru<br />
<strong>Категория:</strong> Ювелирные изделия<br />
<strong>Особенности дизайна:</strong>
- Элегантный черный фон
- Акцент на качестве изображений продукции
- Минималистичная типографика
- Премиальное позиционирование
- Фокус на деталях и мастерстве</p>
<p><strong>Что изучить:</strong> Премиум-дизайн, работа с продуктовой фотографией, минимализм</p>
<hr />
<h2>6. 300LUX - светодиодное оборудование</h2>
<p><strong>URL:</strong> 300lux.ru<br />
<strong>Категория:</strong> Промышленное оборудование<br />
<strong>Особенности дизайна:</strong>
- Технологичный дизайн
- Темная цветовая схема
- Акцент на масштабе проектов
- Четкое позиционирование
- Промышленная эстетика</p>
<p><strong>Что изучить:</strong> B2B дизайн, техническая эстетика, презентация услуг</p>
<hr />
<h2>7. PetSend - перевозка животных</h2>
<p><strong>URL:</strong> petsend.ru<br />
<strong>Категория:</strong> Услуги для животных<br />
<strong>Особенности дизайна:</strong>
- Дружелюбный и веселый дизайн
- Яркие жизнерадостные цвета
- Креативные иллюстрации
- Эмоциональная подача
- Понятная навигация</p>
<p><strong>Что изучить:</strong> Эмоциональный дизайн, работа с иллюстрациями, дружелюбный UX</p>
<hr />
<h2>8. Georgia Guide - гайд по Грузии</h2>
<p><strong>URL:</strong> georgia-guide.com<br />
<strong>Категория:</strong> Туристический гид<br />
<strong>Особенности дизайна:</strong>
- Аутентичная грузинская эстетика
- Теплые цвета и текстуры
- Качественная фотография еды и пейзажей
- Понятная структура информации
- Культурные элементы в дизайне</p>
<p><strong>Что изучить:</strong> Культурный дизайн, туристические сайты, работа с контентом</p>
<hr />
<h2>9. История холодильника</h2>
<p><strong>URL:</strong> holod2022.tilda.ws<br />
<strong>Категория:</strong> Образовательный лонгрид<br />
<strong>Особенности дизайна:</strong>
- Сторителлинг в дизайне
- Последовательная подача информации
- Интересная типографика
- Исторические элементы
- Адаптивная верстка</p>
<p><strong>Что изучить:</strong> Лонгриды, сторителлинг, образовательный контент</p>
<hr />
<h2>10. Guide Dogs - собаки-поводыри</h2>
<p><strong>URL:</strong> guidedogs.ru<br />
<strong>Категория:</strong> Социальный проект<br />
<strong>Особенности дизайна:</strong>
- Социально значимая тематика
- Эмоциональные образы
- Четкая подача информации
- Призывы к действию
- Доступный дизайн</p>
<p><strong>Что изучить:</strong> Социальный дизайн, эмоциональное воздействие, доступность</p>
<hr />
<h2>11. Яндекс</h2>
<p><strong>URL:</strong> yandex.ru<br />
<strong>Категория:</strong> Поисковая система и IT-сервисы<br />
<strong>Особенности дизайна:</strong>
- Минималистичный интерфейс
- Функциональность превыше всего
- Адаптивная верстка
- Быстрая загрузка
- Интуитивная навигация</p>
<p><strong>Что изучить:</strong> Минимализм, функциональность, производительность</p>
<hr />
<h2>12. ВКонтакте</h2>
<p><strong>URL:</strong> vk.com<br />
<strong>Категория:</strong> Социальная сеть<br />
<strong>Особенности дизайна:</strong>
- Современный плоский дизайн
- Синяя корпоративная палитра
- Удобная навигация
- Адаптивность под разные устройства
- Интерактивные элементы</p>
<p><strong>Что изучить:</strong> Социальные сети, интерактивность, адаптивность</p>
<hr />
<h2>13. Тинькофф Банк</h2>
<p><strong>URL:</strong> tinkoff.ru<br />
<strong>Категория:</strong> Финансовые услуги<br />
<strong>Особенности дизайна:</strong>
- Яркий желтый корпоративный цвет
- Современная типографика
- Четкая структура информации
- Удобные формы
- Доверительный дизайн</p>
<p><strong>Что изучить:</strong> Финтех дизайн, формы, доверие пользователей</p>
<hr />
<h2>14. Ozon</h2>
<p><strong>URL:</strong> ozon.ru<br />
<strong>Категория:</strong> Интернет-магазин<br />
<strong>Особенности дизайна:</strong>
- Синий корпоративный цвет
- Удобная навигация по категориям
- Карточки товаров
- Поисковая функциональность
- Адаптивная сетка</p>
<p><strong>Что изучить:</strong> E-commerce, каталоги товаров, поиск и фильтры</p>
<hr />
<h2>15. Лента.ру</h2>
<p><strong>URL:</strong> lenta.ru<br />
<strong>Категория:</strong> Новостной портал<br />
<strong>Особенности дизайна:</strong>
- Информационная архитектура
- Типографическая иерархия
- Быстрая загрузка контента
- Адаптивная верстка
- Удобная навигация по разделам</p>
<p><strong>Что изучить:</strong> Новостные сайты, типографика, информационная архитектура</p>
<hr />
<h2>16. Авито</h2>
<p><strong>URL:</strong> avito.ru<br />
<strong>Категория:</strong> Доска объявлений<br />
<strong>Особенности дизайна:</strong>
- Зеленый корпоративный цвет
- Удобные фильтры поиска
- Карточки объявлений
- Геолокация
- Мобильная оптимизация</p>
<p><strong>Что изучить:</strong> Классифайды, поиск и фильтрация, геосервисы</p>
<hr />
<h2>17. Сбербанк</h2>
<p><strong>URL:</strong> sberbank.ru<br />
<strong>Категория:</strong> Банковские услуги<br />
<strong>Особенности дизайна:</strong>
- Зеленый корпоративный стиль
- Надежный и консервативный дизайн
- Четкая навигация по услугам
- Безопасность и доверие
- Адаптивность</p>
<p><strong>Что изучить:</strong> Банковский дизайн, безопасность, доверие</p>
<hr />
<h2>18. Mail.ru</h2>
<p><strong>URL:</strong> mail.ru<br />
<strong>Категория:</strong> Интернет-портал<br />
<strong>Особенности дизайна:</strong>
- Портальная структура
- Множество сервисов на одной странице
- Новостные блоки
- Социальные элементы
- Персонализация</p>
<p><strong>Что изучить:</strong> Порталы, агрегация контента, персонализация</p>
<hr />
<h2>19. Wildberries</h2>
<p><strong>URL:</strong> wildberries.ru<br />
<strong>Категория:</strong> Интернет-магазин<br />
<strong>Особенности дизайна:</strong>
- Фиолетовый корпоративный цвет
- Каталог с фильтрами
- Карточки товаров с отзывами
- Система рейтингов
- Мобильная оптимизация</p>
<p><strong>Что изучить:</strong> Маркетплейсы, отзывы и рейтинги, мобильная коммерция</p>
<hr />
<h2>20. РБК</h2>
<p><strong>URL:</strong> rbc.ru<br />
<strong>Категория:</strong> Деловые новости<br />
<strong>Особенности дизайна:</strong>
- Строгий деловой стиль
- Красный акцентный цвет
- Информационная плотность
- Быстрый доступ к новостям
- Аналитические материалы</p>
<p><strong>Что изучить:</strong> Деловые медиа, информационная архитектура, аналитика</p>
<hr />
<h2>Рекомендации по изучению</h2>
<h3>Для начинающих:</h3>
<ol>
<li>Начните с простых сайтов (Яндекс, простые лендинги)</li>
<li>Изучите базовую структуру и навигацию</li>
<li>Обратите внимание на цветовые схемы</li>
<li>Проанализируйте типографику</li>
</ol>
<h3>Для продвинутых:</h3>
<ol>
<li>Изучите интерактивные элементы</li>
<li>Проанализируйте адаптивность</li>
<li>Исследуйте анимации и переходы</li>
<li>Изучите UX-паттерны</li>
</ol>
<h3>Практические задания:</h3>
<ol>
<li>Воссоздайте элементы понравившихся сайтов</li>
<li>Адаптируйте дизайн под мобильные устройства</li>
<li>Создайте собственные вариации</li>
<li>Проанализируйте код через инструменты разработчика</li>
</ol>
<hr />
<p><em>Подборка составлена для образовательных целей. Все права на дизайн принадлежат соответствующим компаниям и авторам.</em></p>
<p>Дополнительные полезные ресурсы:</p><ul><li><a href="https://developer.mozilla.org/" target="_blank">MDN Web Docs</a></li><li><a href="https://www.w3schools.com/" target="_blank">W3Schools</a></li><li><a href="https://caniuse.com/" target="_blank">Can I Use</a></li><li><a href="https://css-tricks.com/" target="_blank">CSS-Tricks</a></li><li><a href="https://javascript.info/" target="_blank">JavaScript.info</a></li></ul>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Manus AI. Все права защищены.</p>
    </footer>

    <script src="script.js"></script>
</body>
</html>

